{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\n\n\nfunction quote(s\n/*: string*/\n)\n/*: string*/\n{\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\n\n\nfunction _getClassNameFromQueries(queries\n/*: Array<ParseQuery>*/\n)\n/*: ?string*/\n{\n  let className = null;\n  queries.forEach(q => {\n    if (!className) {\n      className = q.className;\n    }\n\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\n\n\nfunction handleSelectResult(data\n/*: any*/\n, select\n/*: Array<string>*/\n) {\n  const serverDataMask = {};\n  select.forEach(field => {\n    const hasSubObjectSelect = field.indexOf('.') !== -1;\n\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      pathComponents.forEach((component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !obj.hasOwnProperty(component)) {\n          obj[component] = undefined;\n        }\n\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        } //add this path component to the server mask so we can fill it in later if needed\n\n\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n\n  if (Object.keys(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\n\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\n\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = order.slice(0, 1);\n  const isDescending = operator === '-';\n\n  if (isDescending) {\n    order = order.substring(1);\n  }\n\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n\n  if (sorts.length > 1) {\n    const remainingSorts = sorts.slice(1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\n\n\nclass ParseQuery {\n  /**\n   * @property {string} className\n   */\n\n  /*:: className: string;*/\n\n  /*:: _where: any;*/\n\n  /*:: _include: Array<string>;*/\n\n  /*:: _exclude: Array<string>;*/\n\n  /*:: _select: Array<string>;*/\n\n  /*:: _limit: number;*/\n\n  /*:: _skip: number;*/\n\n  /*:: _count: boolean;*/\n\n  /*:: _order: Array<string>;*/\n\n  /*:: _readPreference: string;*/\n\n  /*:: _includeReadPreference: string;*/\n\n  /*:: _subqueryReadPreference: string;*/\n\n  /*:: _queriesLocalDatastore: boolean;*/\n\n  /*:: _localDatastorePinName: any;*/\n\n  /*:: _extraOptions: { [key: string]: mixed };*/\n\n  /*:: _hint: mixed;*/\n\n  /*:: _explain: boolean;*/\n\n  /*:: _xhrRequest: any;*/\n\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass\n  /*: string | ParseObject*/\n  ) {\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      if (typeof objectClass.className === 'string') {\n        this.className = objectClass.className;\n      } else {\n        const obj = new objectClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n\n    this._where = {};\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n  }\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _orQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _andQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _norQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n\n\n  _addCondition(key\n  /*: string*/\n  , condition\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n\n\n  _regexStartWith(string\n  /*: string*/\n  )\n  /*: string*/\n  {\n    return '^' + quote(string);\n  }\n\n  async _handleOfflineQuery(params\n  /*: any*/\n  ) {\n    _OfflineQuery.default.validateQuery(this);\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = objects.map((json, index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n\n      return object;\n    }).filter(object => object !== null);\n\n    if (params.keys) {\n      let keys = params.keys.split(',');\n      keys = keys.concat(['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = results.map(object => {\n        const json = object._toFullJSON();\n\n        Object.keys(json).forEach(key => {\n          if (!keys.includes(key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n\n    if (params.order) {\n      const sorts = params.order.split(',');\n      results.sort((a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    }\n\n    let count; // count total before applying limit/skip\n\n    if (params.count) {\n      count = results.length; // total count from response\n    }\n\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = results.splice(params.skip, results.length);\n      }\n    }\n\n    let limit = results.length;\n\n    if (params.limit !== 0 && params.limit < results.length) {\n      limit = params.limit;\n    }\n\n    results = results.splice(0, limit);\n\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n\n    return results;\n  }\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n\n\n  toJSON()\n  /*: QueryJSON*/\n  {\n    const params\n    /*: QueryJSON*/\n    = {\n      where: this._where\n    };\n\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n\n    if (this._count) {\n      params.count = 1;\n    }\n\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n\n    if (this._explain) {\n      params.explain = true;\n    }\n\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n\n    return params;\n  }\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withJSON(json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    if (json.where) {\n      this._where = json.where;\n    }\n\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n\n    if (json.keys) {\n      this._select = json.keys.split(',');\n    }\n\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n\n    for (const key in json) {\n      if (json.hasOwnProperty(key)) {\n        if (['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain'].indexOf(key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n\n\n  static fromJSON(className\n  /*: string*/\n  , json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  get(objectId\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject>*/\n  {\n    this.equalTo('objectId', objectId);\n    const firstOptions = {};\n\n    if (options && options.hasOwnProperty('useMasterKey')) {\n      firstOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options && options.hasOwnProperty('sessionToken')) {\n      firstOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options && options.hasOwnProperty('context') && typeof options.context === 'object') {\n      firstOptions.context = options.context;\n    }\n\n    if (options && options.hasOwnProperty('json')) {\n      firstOptions.json = options.json;\n    }\n\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return Promise.reject(errorObject);\n    });\n  }\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  find(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n\n    return controller.find(this.className, this.toJSON(), findOptions).then(response => {\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n\n      const results = response.results.map(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n\n        if (!data.className) {\n          data.className = override;\n        } // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n\n\n        if (select) {\n          handleSelectResult(data, select);\n        }\n\n        if (options.json) {\n          return data;\n        } else {\n          return _ParseObject.default.fromJSON(data, !select);\n        }\n      });\n      const count = response.count;\n\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      } else {\n        return results;\n      }\n    });\n  }\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  async findAll(options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    let result\n    /*: ParseObject[]*/\n    = [];\n    await this.eachBatch((objects\n    /*: ParseObject[]*/\n    ) => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n\n\n  count(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<number>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return controller.find(this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  distinct(key\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const distinctOptions = {};\n    distinctOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      distinctOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(distinctOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @param {object} options Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  aggregate(pipeline\n  /*: mixed*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const aggregateOptions = {};\n    aggregateOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      aggregateOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(aggregateOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    if (!Array.isArray(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n\n    if (Object.keys(this._where || {}).length) {\n      if (!Array.isArray(pipeline)) {\n        pipeline = [pipeline];\n      }\n\n      pipeline.unshift({\n        match: this._where\n      });\n    }\n\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n\n\n  first(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject | void>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n\n        return objects[0];\n      });\n    }\n\n    return controller.find(this.className, params, findOptions).then(response => {\n      const objects = response.results;\n\n      if (!objects[0]) {\n        return undefined;\n      }\n\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      } // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n\n\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n\n      if (options.json) {\n        return objects[0];\n      } else {\n        return _ParseObject.default.fromJSON(objects[0], !select);\n      }\n    });\n  }\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  eachBatch(callback\n  /*: (objs: Array<ParseObject>) => Promise<*>*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n\n    if (this._order || this._skip || this._limit >= 0) {\n      return Promise.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n\n    const query = new ParseQuery(this.className);\n    query._limit = options.batchSize || 100;\n    query._include = this._include.map(i => {\n      return i;\n    });\n\n    if (this._select) {\n      query._select = this._select.map(s => {\n        return s;\n      });\n    }\n\n    query._hint = this._hint;\n    query._where = {};\n\n    for (const attr in this._where) {\n      const val = this._where[attr];\n\n      if (Array.isArray(val)) {\n        query._where[attr] = val.map(v => {\n          return v;\n        });\n      } else if (val && typeof val === 'object') {\n        const conditionMap = {};\n        query._where[attr] = conditionMap;\n\n        for (const cond in val) {\n          conditionMap[cond] = val[cond];\n        }\n      } else {\n        query._where[attr] = val;\n      }\n    }\n\n    query.ascending('objectId');\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await Promise.all([query.find(findOptions), Promise.resolve(previousResults.length > 0 && callback(previousResults))]);\n\n      if (results.length >= query._limit) {\n        query.greaterThan('objectId', results[results.length - 1].id);\n        previousResults = results;\n      } else if (results.length > 0) {\n        await Promise.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  each(callback\n  /*: (obj: ParseObject) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    return this.eachBatch(results => {\n      let callbacksDone = Promise.resolve();\n      results.forEach(result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  hint(value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n\n    this._hint = value;\n    return this;\n  }\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  explain(explain\n  /*: boolean*/\n  = true)\n  /*: ParseQuery*/\n  {\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n\n    this._explain = explain;\n    return this;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async map(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async reduce(callback\n  /*: (accumulator: any, currentObject: ParseObject, index: number) => any*/\n  , initialValue\n  /*: any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n\n      return Promise.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n\n    return accumulator;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async filter(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => boolean*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /** Query Conditions **/\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  equalTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(([k, val]) => this.equalTo(k, val));\n      return this;\n    }\n\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notEqualTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(([k, val]) => this.notEqualTo(k, val));\n      return this;\n    }\n\n    return this._addCondition(key, '$ne', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$in', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notContainedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$nin', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedBy(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$containedBy', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAll(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$all', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAllStartingWith(key\n  /*: string*/\n  , values\n  /*: Array<string>*/\n  )\n  /*: ParseQuery*/\n  {\n    const _this = this;\n\n    if (!Array.isArray(values)) {\n      values = [values];\n    }\n\n    const regexObject = values.map(value => {\n      return {\n        $regex: _this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exists(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', true);\n  }\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotExist(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', false);\n  }\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matches(key\n  /*: string*/\n  , regex\n  /*: RegExp*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._addCondition(key, '$regex', regex);\n\n    if (!modifiers) {\n      modifiers = '';\n    }\n\n    if (regex.ignoreCase) {\n      modifiers += 'i';\n    }\n\n    if (regex.multiline) {\n      modifiers += 'm';\n    }\n\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n\n    return this;\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  contains(key\n  /*: string*/\n  , substring\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fullText(key\n  /*: string*/\n  , value\n  /*: string*/\n  , options\n  /*: ?Object*/\n  )\n  /*: ParseQuery*/\n  {\n    options = options || {};\n\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    const fullOptions = {};\n    fullOptions.$term = value;\n\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  startsWith(key\n  /*: string*/\n  , prefix\n  /*: string*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this.matches(key, this._regexStartWith(prefix), modifiers);\n  }\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  endsWith(key\n  /*: string*/\n  , suffix\n  /*: string*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this.matches(key, quote(suffix) + '$', modifiers);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  near(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n\n    return this._addCondition(key, '$nearSphere', point);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinRadians(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    } else {\n      return this._addCondition(key, '$geoWithin', {\n        $centerSphere: [[point.longitude, point.latitude], maxDistance]\n      });\n    }\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinMiles(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinKilometers(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinGeoBox(key\n  /*: string*/\n  , southwest\n  /*: ParseGeoPoint*/\n  , northeast\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinPolygon(key\n  /*: string*/\n  , points\n  /*: Array<Array<number>>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  polygonContains(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n  /** Query Orderings **/\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  ascending(...keys)\n  /*: ParseQuery*/\n  {\n    this._order = [];\n    return this.addAscending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addAscending(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  descending(...keys)\n  /*: ParseQuery*/\n  {\n    this._order = [];\n    return this.addDescending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addDescending(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(',').map(k => {\n        return '-' + k;\n      }));\n    });\n    return this;\n  }\n  /** Query Options **/\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  skip(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n\n    this._skip = n;\n    return this;\n  }\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  limit(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n\n    this._limit = n;\n    return this;\n  }\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withCount(includeCount\n  /*: boolean*/\n  = true)\n  /*: ParseQuery*/\n  {\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  include(...keys)\n  /*: ParseQuery*/\n  {\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._include = this._include.concat(key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Includes all nested Parse.Objects one level deep.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  includeAll()\n  /*: ParseQuery*/\n  {\n    return this.include('*');\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  select(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._select) {\n      this._select = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._select = this._select.concat(key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exclude(...keys)\n  /*: ParseQuery*/\n  {\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._exclude = this._exclude.concat(key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  readPreference(readPreference\n  /*: string*/\n  , includeReadPreference\n  /*:: ?: string*/\n  , subqueryReadPreference\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference;\n    this._subqueryReadPreference = subqueryReadPreference;\n    return this;\n  }\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n\n\n  async subscribe(sessionToken\n  /*:: ?: string*/\n  )\n  /*: Promise<LiveQuerySubscription>*/\n  {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n    }\n\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n\n\n  static or(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._orQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n\n\n  static and(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._andQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n\n\n  static nor(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._norQuery(queries);\n\n    return query;\n  }\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromNetwork()\n  /*: ParseQuery*/\n  {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromLocalDatastore()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(null);\n  }\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPin()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPinWithName(name\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n\n    return this;\n  }\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  cancel()\n  /*: ParseQuery*/\n  {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n\n      this._xhrRequest.task.abort();\n\n      this._xhrRequest.task = null;\n\n      this._xhrRequest.onchange = () => {};\n\n      return this;\n    }\n\n    return this._xhrRequest.onchange = () => this.cancel();\n  }\n\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n\n      this._xhrRequest.onchange();\n    };\n  }\n\n}\n\nconst DefaultController = {\n  find(className\n  /*: string*/\n  , params\n  /*: QueryJSON*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n\n  aggregate(className\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n\n};\n\n_CoreManager.default.setQueryController(DefaultController);\n\nvar _default = ParseQuery;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseQuery.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_encode","_promiseUtils","_ParseError","_ParseGeoPoint","_ParseObject","_OfflineQuery","_LocalDatastoreUtils","obj","__esModule","quote","s","replace","_getClassNameFromQueries","queries","className","forEach","q","Error","handleSelectResult","data","select","serverDataMask","field","hasSubObjectSelect","indexOf","hasOwnProperty","undefined","pathComponents","split","serverMask","component","index","arr","length","keys","serverData","getObjectStateController","getServerData","id","objectId","copyMissingDataWithMask","src","dest","mask","copyThisLevel","key","handleOfflineSort","a","b","sorts","order","operator","slice","isDescending","substring","test","INVALID_KEY_NAME","field1","get","field2","remainingSorts","ParseQuery","constructor","objectClass","TypeError","_where","_include","_exclude","_count","_limit","_skip","_readPreference","_includeReadPreference","_subqueryReadPreference","_queriesLocalDatastore","_localDatastorePinName","_extraOptions","_xhrRequest","task","onchange","_orQuery","queryJSON","map","toJSON","where","$or","_andQuery","$and","_norQuery","$nor","_addCondition","condition","_regexStartWith","string","_handleOfflineQuery","params","validateQuery","localDatastore","getLocalDatastore","objects","_serializeObjectsFromPinName","results","json","object","fromJSON","_localId","matchesQuery","filter","concat","_toFullJSON","includes","sort","count","skip","splice","limit","include","join","excludeKeys","_select","_order","readPreference","includeReadPreference","subqueryReadPreference","_hint","hint","_explain","explain","withJSON","query","options","equalTo","firstOptions","useMasterKey","sessionToken","context","first","then","response","errorObject","OBJECT_NOT_FOUND","Promise","reject","find","findOptions","_setRequestTask","controller","getQueryController","override","findAll","result","eachBatch","distinct","distinctOptions","aggregate","pipeline","aggregateOptions","Array","isArray","unshift","match","callback","batchSize","i","attr","val","v","conditionMap","cond","ascending","finished","previousResults","continueWhile","all","resolve","greaterThan","each","callbacksDone","array","push","reduce","initialValue","accumulator","flag","entries","k","doesNotExist","notEqualTo","lessThan","lessThanOrEqualTo","greaterThanOrEqualTo","containedIn","notContainedIn","containedBy","values","containsAll","containsAllStartingWith","_this","regexObject","$regex","exists","matches","regex","modifiers","ignoreCase","multiline","doesNotMatchQuery","matchesKeyInQuery","queryKey","doesNotMatchKeyInQuery","contains","fullText","fullOptions","$term","option","$language","$caseSensitive","$diacriticSensitive","$search","sortByTextScore","startsWith","prefix","endsWith","suffix","near","point","withinRadians","maxDistance","sorted","$centerSphere","longitude","latitude","withinMiles","withinKilometers","withinGeoBox","southwest","northeast","$box","withinPolygon","points","$polygon","polygonContains","$point","addAscending","apply","descending","addDescending","n","withCount","includeCount","includeAll","exclude","subscribe","currentUser","getUserController","currentUserAsync","getSessionToken","liveQueryClient","getLiveQueryController","getDefaultLiveQueryClient","shouldOpen","open","subscription","subscribePromise","or","and","nor","fromNetwork","fromLocalDatastore","fromPinWithName","fromPin","DEFAULT_PIN","name","checkIfEnabled","cancel","abort","_aborted","requestTask","DefaultController","RESTController","getRESTController","request","setQueryController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\n\n\nfunction quote(s\n/*: string*/\n)\n/*: string*/\n{\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\n\n\nfunction _getClassNameFromQueries(queries\n/*: Array<ParseQuery>*/\n)\n/*: ?string*/\n{\n  let className = null;\n  queries.forEach(q => {\n    if (!className) {\n      className = q.className;\n    }\n\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\n\n\nfunction handleSelectResult(data\n/*: any*/\n, select\n/*: Array<string>*/\n) {\n  const serverDataMask = {};\n  select.forEach(field => {\n    const hasSubObjectSelect = field.indexOf('.') !== -1;\n\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      pathComponents.forEach((component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !obj.hasOwnProperty(component)) {\n          obj[component] = undefined;\n        }\n\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        } //add this path component to the server mask so we can fill it in later if needed\n\n\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n\n  if (Object.keys(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\n\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\n\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = order.slice(0, 1);\n  const isDescending = operator === '-';\n\n  if (isDescending) {\n    order = order.substring(1);\n  }\n\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n\n  if (sorts.length > 1) {\n    const remainingSorts = sorts.slice(1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\n\n\nclass ParseQuery {\n  /**\n   * @property {string} className\n   */\n\n  /*:: className: string;*/\n\n  /*:: _where: any;*/\n\n  /*:: _include: Array<string>;*/\n\n  /*:: _exclude: Array<string>;*/\n\n  /*:: _select: Array<string>;*/\n\n  /*:: _limit: number;*/\n\n  /*:: _skip: number;*/\n\n  /*:: _count: boolean;*/\n\n  /*:: _order: Array<string>;*/\n\n  /*:: _readPreference: string;*/\n\n  /*:: _includeReadPreference: string;*/\n\n  /*:: _subqueryReadPreference: string;*/\n\n  /*:: _queriesLocalDatastore: boolean;*/\n\n  /*:: _localDatastorePinName: any;*/\n\n  /*:: _extraOptions: { [key: string]: mixed };*/\n\n  /*:: _hint: mixed;*/\n\n  /*:: _explain: boolean;*/\n\n  /*:: _xhrRequest: any;*/\n\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass\n  /*: string | ParseObject*/\n  ) {\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      if (typeof objectClass.className === 'string') {\n        this.className = objectClass.className;\n      } else {\n        const obj = new objectClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n\n    this._where = {};\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n  }\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _orQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _andQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  _norQuery(queries\n  /*: Array<ParseQuery>*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = queries.map(q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n\n\n  _addCondition(key\n  /*: string*/\n  , condition\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n\n\n  _regexStartWith(string\n  /*: string*/\n  )\n  /*: string*/\n  {\n    return '^' + quote(string);\n  }\n\n  async _handleOfflineQuery(params\n  /*: any*/\n  ) {\n    _OfflineQuery.default.validateQuery(this);\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = objects.map((json, index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n\n      return object;\n    }).filter(object => object !== null);\n\n    if (params.keys) {\n      let keys = params.keys.split(',');\n      keys = keys.concat(['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = results.map(object => {\n        const json = object._toFullJSON();\n\n        Object.keys(json).forEach(key => {\n          if (!keys.includes(key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n\n    if (params.order) {\n      const sorts = params.order.split(',');\n      results.sort((a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    }\n\n    let count; // count total before applying limit/skip\n\n    if (params.count) {\n      count = results.length; // total count from response\n    }\n\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = results.splice(params.skip, results.length);\n      }\n    }\n\n    let limit = results.length;\n\n    if (params.limit !== 0 && params.limit < results.length) {\n      limit = params.limit;\n    }\n\n    results = results.splice(0, limit);\n\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n\n    return results;\n  }\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n\n\n  toJSON()\n  /*: QueryJSON*/\n  {\n    const params\n    /*: QueryJSON*/\n    = {\n      where: this._where\n    };\n\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n\n    if (this._count) {\n      params.count = 1;\n    }\n\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n\n    if (this._explain) {\n      params.explain = true;\n    }\n\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n\n    return params;\n  }\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withJSON(json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    if (json.where) {\n      this._where = json.where;\n    }\n\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n\n    if (json.keys) {\n      this._select = json.keys.split(',');\n    }\n\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n\n    for (const key in json) {\n      if (json.hasOwnProperty(key)) {\n        if (['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain'].indexOf(key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n\n\n  static fromJSON(className\n  /*: string*/\n  , json\n  /*: QueryJSON*/\n  )\n  /*: ParseQuery*/\n  {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  get(objectId\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject>*/\n  {\n    this.equalTo('objectId', objectId);\n    const firstOptions = {};\n\n    if (options && options.hasOwnProperty('useMasterKey')) {\n      firstOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options && options.hasOwnProperty('sessionToken')) {\n      firstOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options && options.hasOwnProperty('context') && typeof options.context === 'object') {\n      firstOptions.context = options.context;\n    }\n\n    if (options && options.hasOwnProperty('json')) {\n      firstOptions.json = options.json;\n    }\n\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return Promise.reject(errorObject);\n    });\n  }\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  find(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n\n    return controller.find(this.className, this.toJSON(), findOptions).then(response => {\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n\n      const results = response.results.map(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n\n        if (!data.className) {\n          data.className = override;\n        } // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n\n\n        if (select) {\n          handleSelectResult(data, select);\n        }\n\n        if (options.json) {\n          return data;\n        } else {\n          return _ParseObject.default.fromJSON(data, !select);\n        }\n      });\n      const count = response.count;\n\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      } else {\n        return results;\n      }\n    });\n  }\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n\n\n  async findAll(options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    let result\n    /*: ParseObject[]*/\n    = [];\n    await this.eachBatch((objects\n    /*: ParseObject[]*/\n    ) => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n\n\n  count(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<number>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return controller.find(this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  distinct(key\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const distinctOptions = {};\n    distinctOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      distinctOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(distinctOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @param {object} options Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n\n\n  aggregate(pipeline\n  /*: mixed*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    options = options || {};\n    const aggregateOptions = {};\n    aggregateOptions.useMasterKey = true;\n\n    if (options.hasOwnProperty('sessionToken')) {\n      aggregateOptions.sessionToken = options.sessionToken;\n    }\n\n    this._setRequestTask(aggregateOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    if (!Array.isArray(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n\n    if (Object.keys(this._where || {}).length) {\n      if (!Array.isArray(pipeline)) {\n        pipeline = [pipeline];\n      }\n\n      pipeline.unshift({\n        match: this._where\n      });\n    }\n\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   *\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n\n\n  first(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseObject | void>*/\n  {\n    options = options || {};\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    this._setRequestTask(findOptions);\n\n    const controller = _CoreManager.default.getQueryController();\n\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n\n        return objects[0];\n      });\n    }\n\n    return controller.find(this.className, params, findOptions).then(response => {\n      const objects = response.results;\n\n      if (!objects[0]) {\n        return undefined;\n      }\n\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      } // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n\n\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n\n      if (options.json) {\n        return objects[0];\n      } else {\n        return _ParseObject.default.fromJSON(objects[0], !select);\n      }\n    });\n  }\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  eachBatch(callback\n  /*: (objs: Array<ParseObject>) => Promise<*>*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n\n    if (this._order || this._skip || this._limit >= 0) {\n      return Promise.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n\n    const query = new ParseQuery(this.className);\n    query._limit = options.batchSize || 100;\n    query._include = this._include.map(i => {\n      return i;\n    });\n\n    if (this._select) {\n      query._select = this._select.map(s => {\n        return s;\n      });\n    }\n\n    query._hint = this._hint;\n    query._where = {};\n\n    for (const attr in this._where) {\n      const val = this._where[attr];\n\n      if (Array.isArray(val)) {\n        query._where[attr] = val.map(v => {\n          return v;\n        });\n      } else if (val && typeof val === 'object') {\n        const conditionMap = {};\n        query._where[attr] = conditionMap;\n\n        for (const cond in val) {\n          conditionMap[cond] = val[cond];\n        }\n      } else {\n        query._where[attr] = val;\n      }\n    }\n\n    query.ascending('objectId');\n    const findOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await Promise.all([query.find(findOptions), Promise.resolve(previousResults.length > 0 && callback(previousResults))]);\n\n      if (results.length >= query._limit) {\n        query.greaterThan('objectId', results[results.length - 1].id);\n        previousResults = results;\n      } else if (results.length > 0) {\n        await Promise.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  each(callback\n  /*: (obj: ParseObject) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    return this.eachBatch(results => {\n      let callbacksDone = Promise.resolve();\n      results.forEach(result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  hint(value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n\n    this._hint = value;\n    return this;\n  }\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  explain(explain\n  /*: boolean*/\n  = true)\n  /*: ParseQuery*/\n  {\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n\n    this._explain = explain;\n    return this;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async map(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async reduce(callback\n  /*: (accumulator: any, currentObject: ParseObject, index: number) => any*/\n  , initialValue\n  /*: any*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<any>>*/\n  {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n\n      return Promise.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n\n    return accumulator;\n  }\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n\n\n  async filter(callback\n  /*: (currentObject: ParseObject, index: number, query: ParseQuery) => boolean*/\n  , options\n  /*:: ?: BatchOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return Promise.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n  /** Query Conditions **/\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  equalTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(([k, val]) => this.equalTo(k, val));\n      return this;\n    }\n\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notEqualTo(key\n  /*: string | { [key: string]: any }*/\n  , value\n  /*: ?mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    if (key && typeof key === 'object') {\n      Object.entries(key).forEach(([k, val]) => this.notEqualTo(k, val));\n      return this;\n    }\n\n    return this._addCondition(key, '$ne', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThan(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gt', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  lessThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$lte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  greaterThanOrEqualTo(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$gte', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$in', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  notContainedIn(key\n  /*: string*/\n  , value\n  /*: mixed*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$nin', value);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containedBy(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$containedBy', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAll(key\n  /*: string*/\n  , values\n  /*: Array<mixed>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$all', values);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  containsAllStartingWith(key\n  /*: string*/\n  , values\n  /*: Array<string>*/\n  )\n  /*: ParseQuery*/\n  {\n    const _this = this;\n\n    if (!Array.isArray(values)) {\n      values = [values];\n    }\n\n    const regexObject = values.map(value => {\n      return {\n        $regex: _this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exists(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', true);\n  }\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotExist(key\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$exists', false);\n  }\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matches(key\n  /*: string*/\n  , regex\n  /*: RegExp*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._addCondition(key, '$regex', regex);\n\n    if (!modifiers) {\n      modifiers = '';\n    }\n\n    if (regex.ignoreCase) {\n      modifiers += 'i';\n    }\n\n    if (regex.multiline) {\n      modifiers += 'm';\n    }\n\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n\n    return this;\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchQuery(key\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  matchesKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  doesNotMatchKeyInQuery(key\n  /*: string*/\n  , queryKey\n  /*: string*/\n  , query\n  /*: ParseQuery*/\n  )\n  /*: ParseQuery*/\n  {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  contains(key\n  /*: string*/\n  , substring\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fullText(key\n  /*: string*/\n  , value\n  /*: string*/\n  , options\n  /*: ?Object*/\n  )\n  /*: ParseQuery*/\n  {\n    options = options || {};\n\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    const fullOptions = {};\n    fullOptions.$term = value;\n\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  startsWith(key\n  /*: string*/\n  , prefix\n  /*: string*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this.matches(key, this._regexStartWith(prefix), modifiers);\n  }\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  endsWith(key\n  /*: string*/\n  , suffix\n  /*: string*/\n  , modifiers\n  /*: string*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n\n    return this.matches(key, quote(suffix) + '$', modifiers);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  near(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n\n    return this._addCondition(key, '$nearSphere', point);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinRadians(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    } else {\n      return this._addCondition(key, '$geoWithin', {\n        $centerSphere: [[point.longitude, point.latitude], maxDistance]\n      });\n    }\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinMiles(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinKilometers(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  , maxDistance\n  /*: number*/\n  , sorted\n  /*: boolean*/\n  )\n  /*: ParseQuery*/\n  {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinGeoBox(key\n  /*: string*/\n  , southwest\n  /*: ParseGeoPoint*/\n  , northeast\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n\n    return this;\n  }\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withinPolygon(key\n  /*: string*/\n  , points\n  /*: Array<Array<number>>*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  polygonContains(key\n  /*: string*/\n  , point\n  /*: ParseGeoPoint*/\n  )\n  /*: ParseQuery*/\n  {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n  /** Query Orderings **/\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  ascending(...keys)\n  /*: ParseQuery*/\n  {\n    this._order = [];\n    return this.addAscending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addAscending(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  descending(...keys)\n  /*: ParseQuery*/\n  {\n    this._order = [];\n    return this.addDescending.apply(this, keys);\n  }\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  addDescending(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._order) {\n      this._order = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        key = key.join();\n      }\n\n      this._order = this._order.concat(key.replace(/\\s/g, '').split(',').map(k => {\n        return '-' + k;\n      }));\n    });\n    return this;\n  }\n  /** Query Options **/\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  skip(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n\n    this._skip = n;\n    return this;\n  }\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  limit(n\n  /*: number*/\n  )\n  /*: ParseQuery*/\n  {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n\n    this._limit = n;\n    return this;\n  }\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  withCount(includeCount\n  /*: boolean*/\n  = true)\n  /*: ParseQuery*/\n  {\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  include(...keys)\n  /*: ParseQuery*/\n  {\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._include = this._include.concat(key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Includes all nested Parse.Objects one level deep.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  includeAll()\n  /*: ParseQuery*/\n  {\n    return this.include('*');\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  select(...keys)\n  /*: ParseQuery*/\n  {\n    if (!this._select) {\n      this._select = [];\n    }\n\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._select = this._select.concat(key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  exclude(...keys)\n  /*: ParseQuery*/\n  {\n    keys.forEach(key => {\n      if (Array.isArray(key)) {\n        this._exclude = this._exclude.concat(key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  readPreference(readPreference\n  /*: string*/\n  , includeReadPreference\n  /*:: ?: string*/\n  , subqueryReadPreference\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference;\n    this._subqueryReadPreference = subqueryReadPreference;\n    return this;\n  }\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n\n\n  async subscribe(sessionToken\n  /*:: ?: string*/\n  )\n  /*: Promise<LiveQuerySubscription>*/\n  {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() : undefined;\n    }\n\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n\n\n  static or(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._orQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n\n\n  static and(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._andQuery(queries);\n\n    return query;\n  }\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n\n\n  static nor(...queries)\n  /*: ParseQuery*/\n  {\n    const className = _getClassNameFromQueries(queries);\n\n    const query = new ParseQuery(className);\n\n    query._norQuery(queries);\n\n    return query;\n  }\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromNetwork()\n  /*: ParseQuery*/\n  {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromLocalDatastore()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(null);\n  }\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPin()\n  /*: ParseQuery*/\n  {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  fromPinWithName(name\n  /*:: ?: string*/\n  )\n  /*: ParseQuery*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n\n    return this;\n  }\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n\n\n  cancel()\n  /*: ParseQuery*/\n  {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n\n      this._xhrRequest.task.abort();\n\n      this._xhrRequest.task = null;\n\n      this._xhrRequest.onchange = () => {};\n\n      return this;\n    }\n\n    return this._xhrRequest.onchange = () => this.cancel();\n  }\n\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n\n      this._xhrRequest.onchange();\n    };\n  }\n\n}\n\nconst DefaultController = {\n  find(className\n  /*: string*/\n  , params\n  /*: QueryJSON*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<ParseObject>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n\n  aggregate(className\n  /*: string*/\n  , params\n  /*: any*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<mixed>>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n\n};\n\n_CoreManager.default.setQueryController(DefaultController);\n\nvar _default = ParseQuery;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}