{"ast":null,"code":"\"use strict\";\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/* global XMLHttpRequest, XDomainRequest */\n\n\nconst uuidv4 = require('./uuid');\n\nlet XHR = null;\n\nif (typeof XMLHttpRequest !== 'undefined') {\n  XHR = XMLHttpRequest;\n}\n\nXHR = require('xmlhttprequest').XMLHttpRequest;\nlet useXDomainRequest = false;\n\nif (typeof XDomainRequest !== 'undefined' && !('withCredentials' in new XMLHttpRequest())) {\n  useXDomainRequest = true;\n}\n\nfunction ajaxIE9(method\n/*: string*/\n, url\n/*: string*/\n, data\n/*: any*/\n, headers\n/*:: ?: any*/\n, options\n/*:: ?: FullOptions*/\n) {\n  return new Promise((resolve, reject) => {\n    const xdr = new XDomainRequest();\n\n    xdr.onload = function () {\n      let response;\n\n      try {\n        response = JSON.parse(xdr.responseText);\n      } catch (e) {\n        reject(e);\n      }\n\n      if (response) {\n        resolve({\n          response\n        });\n      }\n    };\n\n    xdr.onerror = xdr.ontimeout = function () {\n      // Let's fake a real error message.\n      const fakeResponse = {\n        responseText: JSON.stringify({\n          code: _ParseError.default.X_DOMAIN_REQUEST,\n          error: \"IE's XDomainRequest does not supply error info.\"\n        })\n      };\n      reject(fakeResponse);\n    };\n\n    xdr.onprogress = function () {\n      if (options && typeof options.progress === 'function') {\n        options.progress(xdr.responseText);\n      }\n    };\n\n    xdr.open(method, url);\n    xdr.send(data);\n\n    if (options && typeof options.requestTask === 'function') {\n      options.requestTask(xdr);\n    }\n  });\n}\n\nconst RESTController = {\n  ajax(method\n  /*: string*/\n  , url\n  /*: string*/\n  , data\n  /*: any*/\n  , headers\n  /*:: ?: any*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (useXDomainRequest) {\n      return ajaxIE9(method, url, data, headers, options);\n    }\n\n    const promise = (0, _promiseUtils.resolvingPromise)();\n    const isIdempotent = _CoreManager.default.get('IDEMPOTENCY') && ['POST', 'PUT'].includes(method);\n    const requestId = isIdempotent ? uuidv4() : '';\n    let attempts = 0;\n\n    const dispatch = function () {\n      if (XHR == null) {\n        throw new Error('Cannot make a request: No definition of XMLHttpRequest was found.');\n      }\n\n      let handled = false;\n      const xhr = new XHR();\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState !== 4 || handled || xhr._aborted) {\n          return;\n        }\n\n        handled = true;\n\n        if (xhr.status >= 200 && xhr.status < 300) {\n          let response;\n\n          try {\n            response = JSON.parse(xhr.responseText);\n\n            if (typeof xhr.getResponseHeader === 'function') {\n              if ((xhr.getAllResponseHeaders() || '').includes('x-parse-job-status-id: ')) {\n                response = xhr.getResponseHeader('x-parse-job-status-id');\n              }\n\n              if ((xhr.getAllResponseHeaders() || '').includes('x-parse-push-status-id: ')) {\n                response = xhr.getResponseHeader('x-parse-push-status-id');\n              }\n            }\n          } catch (e) {\n            promise.reject(e.toString());\n          }\n\n          if (response) {\n            promise.resolve({\n              response,\n              status: xhr.status,\n              xhr\n            });\n          }\n        } else if (xhr.status >= 500 || xhr.status === 0) {\n          // retry on 5XX or node-xmlhttprequest error\n          if (++attempts < _CoreManager.default.get('REQUEST_ATTEMPT_LIMIT')) {\n            // Exponentially-growing random delay\n            const delay = Math.round(Math.random() * 125 * Math.pow(2, attempts));\n            setTimeout(dispatch, delay);\n          } else if (xhr.status === 0) {\n            promise.reject('Unable to connect to the Parse API');\n          } else {\n            // After the retry limit is reached, fail\n            promise.reject(xhr);\n          }\n        } else {\n          promise.reject(xhr);\n        }\n      };\n\n      headers = headers || {};\n\n      if (typeof headers['Content-Type'] !== 'string') {\n        headers['Content-Type'] = 'text/plain'; // Avoid pre-flight\n      }\n\n      if (_CoreManager.default.get('IS_NODE')) {\n        headers['User-Agent'] = 'Parse/' + _CoreManager.default.get('VERSION') + ' (NodeJS ' + process.versions.node + ')';\n      }\n\n      if (isIdempotent) {\n        headers['X-Parse-Request-Id'] = requestId;\n      }\n\n      if (_CoreManager.default.get('SERVER_AUTH_TYPE') && _CoreManager.default.get('SERVER_AUTH_TOKEN')) {\n        headers['Authorization'] = _CoreManager.default.get('SERVER_AUTH_TYPE') + ' ' + _CoreManager.default.get('SERVER_AUTH_TOKEN');\n      }\n\n      const customHeaders = _CoreManager.default.get('REQUEST_HEADERS');\n\n      for (const key in customHeaders) {\n        headers[key] = customHeaders[key];\n      }\n\n      function handleProgress(type, event) {\n        if (options && typeof options.progress === 'function') {\n          if (event.lengthComputable) {\n            options.progress(event.loaded / event.total, event.loaded, event.total, {\n              type\n            });\n          } else {\n            options.progress(null, null, null, {\n              type\n            });\n          }\n        }\n      }\n\n      xhr.onprogress = event => {\n        handleProgress('download', event);\n      };\n\n      if (xhr.upload) {\n        xhr.upload.onprogress = event => {\n          handleProgress('upload', event);\n        };\n      }\n\n      xhr.open(method, url, true);\n\n      for (const h in headers) {\n        xhr.setRequestHeader(h, headers[h]);\n      }\n\n      xhr.onabort = function () {\n        promise.resolve({\n          response: {\n            results: []\n          },\n          status: 0,\n          xhr\n        });\n      };\n\n      xhr.send(data);\n\n      if (options && typeof options.requestTask === 'function') {\n        options.requestTask(xhr);\n      }\n    };\n\n    dispatch();\n    return promise;\n  },\n\n  request(method\n  /*: string*/\n  , path\n  /*: string*/\n  , data\n  /*: mixed*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n\n    let url = _CoreManager.default.get('SERVER_URL');\n\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n\n    url += path;\n    const payload = {};\n\n    if (data && typeof data === 'object') {\n      for (const k in data) {\n        payload[k] = data[k];\n      }\n    } // Add context\n\n\n    const context = options.context;\n\n    if (context !== undefined) {\n      payload._context = context;\n    }\n\n    if (method !== 'POST') {\n      payload._method = method;\n      method = 'POST';\n    }\n\n    payload._ApplicationId = _CoreManager.default.get('APPLICATION_ID');\n\n    const jsKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n\n    if (jsKey) {\n      payload._JavaScriptKey = jsKey;\n    }\n\n    payload._ClientVersion = _CoreManager.default.get('VERSION');\n    let useMasterKey = options.useMasterKey;\n\n    if (typeof useMasterKey === 'undefined') {\n      useMasterKey = _CoreManager.default.get('USE_MASTER_KEY');\n    }\n\n    if (useMasterKey) {\n      if (_CoreManager.default.get('MASTER_KEY')) {\n        delete payload._JavaScriptKey;\n        payload._MasterKey = _CoreManager.default.get('MASTER_KEY');\n      } else {\n        throw new Error('Cannot use the Master Key, it has not been provided.');\n      }\n    }\n\n    if (_CoreManager.default.get('FORCE_REVOCABLE_SESSION')) {\n      payload._RevocableSession = '1';\n    }\n\n    const installationId = options.installationId;\n    let installationIdPromise;\n\n    if (installationId && typeof installationId === 'string') {\n      installationIdPromise = Promise.resolve(installationId);\n    } else {\n      const installationController = _CoreManager.default.getInstallationController();\n\n      installationIdPromise = installationController.currentInstallationId();\n    }\n\n    return installationIdPromise.then(iid => {\n      payload._InstallationId = iid;\n\n      const userController = _CoreManager.default.getUserController();\n\n      if (options && typeof options.sessionToken === 'string') {\n        return Promise.resolve(options.sessionToken);\n      } else if (userController) {\n        return userController.currentUserAsync().then(user => {\n          if (user) {\n            return Promise.resolve(user.getSessionToken());\n          }\n\n          return Promise.resolve(null);\n        });\n      }\n\n      return Promise.resolve(null);\n    }).then(token => {\n      if (token) {\n        payload._SessionToken = token;\n      }\n\n      const payloadString = JSON.stringify(payload);\n      return RESTController.ajax(method, url, payloadString, {}, options).then(({\n        response,\n        status\n      }) => {\n        if (options.returnStatus) {\n          return _objectSpread(_objectSpread({}, response), {}, {\n            _status: status\n          });\n        } else {\n          return response;\n        }\n      });\n    }).catch(RESTController.handleError);\n  },\n\n  handleError(response) {\n    // Transform the error into an instance of ParseError by trying to parse\n    // the error string as JSON\n    let error;\n\n    if (response && response.responseText) {\n      try {\n        const errorJSON = JSON.parse(response.responseText);\n        error = new _ParseError.default(errorJSON.code, errorJSON.error);\n      } catch (e) {\n        // If we fail to parse the error text, that's okay.\n        error = new _ParseError.default(_ParseError.default.INVALID_JSON, 'Received an error with invalid JSON from Parse: ' + response.responseText);\n      }\n    } else {\n      const message = response.message ? response.message : response;\n      error = new _ParseError.default(_ParseError.default.CONNECTION_FAILED, 'XMLHttpRequest failed: ' + JSON.stringify(message));\n    }\n\n    return Promise.reject(error);\n  },\n\n  _setXHR(xhr\n  /*: any*/\n  ) {\n    XHR = xhr;\n  },\n\n  _getXHR() {\n    return XHR;\n  }\n\n};\nmodule.exports = RESTController;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/RESTController.js"],"names":["_CoreManager","_interopRequireDefault","require","_ParseError","_promiseUtils","obj","__esModule","default","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","value","configurable","writable","uuidv4","XHR","XMLHttpRequest","useXDomainRequest","XDomainRequest","ajaxIE9","method","url","data","headers","options","Promise","resolve","reject","xdr","onload","response","JSON","parse","responseText","e","onerror","ontimeout","fakeResponse","stringify","code","X_DOMAIN_REQUEST","error","onprogress","progress","open","send","requestTask","RESTController","ajax","promise","resolvingPromise","isIdempotent","get","includes","requestId","attempts","dispatch","Error","handled","xhr","onreadystatechange","readyState","_aborted","status","getResponseHeader","getAllResponseHeaders","toString","delay","Math","round","random","pow","setTimeout","process","versions","node","customHeaders","handleProgress","type","event","lengthComputable","loaded","total","upload","h","setRequestHeader","onabort","results","request","path","payload","k","context","undefined","_context","_method","_ApplicationId","jsKey","_JavaScriptKey","_ClientVersion","useMasterKey","_MasterKey","_RevocableSession","installationId","installationIdPromise","installationController","getInstallationController","currentInstallationId","then","iid","_InstallationId","userController","getUserController","sessionToken","currentUserAsync","user","getSessionToken","token","_SessionToken","payloadString","returnStatus","_status","catch","handleError","errorJSON","INVALID_JSON","message","CONNECTION_FAILED","_setXHR","_getXHR","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/* global XMLHttpRequest, XDomainRequest */\n\n\nconst uuidv4 = require('./uuid');\n\nlet XHR = null;\n\nif (typeof XMLHttpRequest !== 'undefined') {\n  XHR = XMLHttpRequest;\n}\n\nXHR = require('xmlhttprequest').XMLHttpRequest;\nlet useXDomainRequest = false;\n\nif (typeof XDomainRequest !== 'undefined' && !('withCredentials' in new XMLHttpRequest())) {\n  useXDomainRequest = true;\n}\n\nfunction ajaxIE9(method\n/*: string*/\n, url\n/*: string*/\n, data\n/*: any*/\n, headers\n/*:: ?: any*/\n, options\n/*:: ?: FullOptions*/\n) {\n  return new Promise((resolve, reject) => {\n    const xdr = new XDomainRequest();\n\n    xdr.onload = function () {\n      let response;\n\n      try {\n        response = JSON.parse(xdr.responseText);\n      } catch (e) {\n        reject(e);\n      }\n\n      if (response) {\n        resolve({\n          response\n        });\n      }\n    };\n\n    xdr.onerror = xdr.ontimeout = function () {\n      // Let's fake a real error message.\n      const fakeResponse = {\n        responseText: JSON.stringify({\n          code: _ParseError.default.X_DOMAIN_REQUEST,\n          error: \"IE's XDomainRequest does not supply error info.\"\n        })\n      };\n      reject(fakeResponse);\n    };\n\n    xdr.onprogress = function () {\n      if (options && typeof options.progress === 'function') {\n        options.progress(xdr.responseText);\n      }\n    };\n\n    xdr.open(method, url);\n    xdr.send(data);\n\n    if (options && typeof options.requestTask === 'function') {\n      options.requestTask(xdr);\n    }\n  });\n}\n\nconst RESTController = {\n  ajax(method\n  /*: string*/\n  , url\n  /*: string*/\n  , data\n  /*: any*/\n  , headers\n  /*:: ?: any*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (useXDomainRequest) {\n      return ajaxIE9(method, url, data, headers, options);\n    }\n\n    const promise = (0, _promiseUtils.resolvingPromise)();\n    const isIdempotent = _CoreManager.default.get('IDEMPOTENCY') && ['POST', 'PUT'].includes(method);\n    const requestId = isIdempotent ? uuidv4() : '';\n    let attempts = 0;\n\n    const dispatch = function () {\n      if (XHR == null) {\n        throw new Error('Cannot make a request: No definition of XMLHttpRequest was found.');\n      }\n\n      let handled = false;\n      const xhr = new XHR();\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState !== 4 || handled || xhr._aborted) {\n          return;\n        }\n\n        handled = true;\n\n        if (xhr.status >= 200 && xhr.status < 300) {\n          let response;\n\n          try {\n            response = JSON.parse(xhr.responseText);\n\n            if (typeof xhr.getResponseHeader === 'function') {\n              if ((xhr.getAllResponseHeaders() || '').includes('x-parse-job-status-id: ')) {\n                response = xhr.getResponseHeader('x-parse-job-status-id');\n              }\n\n              if ((xhr.getAllResponseHeaders() || '').includes('x-parse-push-status-id: ')) {\n                response = xhr.getResponseHeader('x-parse-push-status-id');\n              }\n            }\n          } catch (e) {\n            promise.reject(e.toString());\n          }\n\n          if (response) {\n            promise.resolve({\n              response,\n              status: xhr.status,\n              xhr\n            });\n          }\n        } else if (xhr.status >= 500 || xhr.status === 0) {\n          // retry on 5XX or node-xmlhttprequest error\n          if (++attempts < _CoreManager.default.get('REQUEST_ATTEMPT_LIMIT')) {\n            // Exponentially-growing random delay\n            const delay = Math.round(Math.random() * 125 * Math.pow(2, attempts));\n            setTimeout(dispatch, delay);\n          } else if (xhr.status === 0) {\n            promise.reject('Unable to connect to the Parse API');\n          } else {\n            // After the retry limit is reached, fail\n            promise.reject(xhr);\n          }\n        } else {\n          promise.reject(xhr);\n        }\n      };\n\n      headers = headers || {};\n\n      if (typeof headers['Content-Type'] !== 'string') {\n        headers['Content-Type'] = 'text/plain'; // Avoid pre-flight\n      }\n\n      if (_CoreManager.default.get('IS_NODE')) {\n        headers['User-Agent'] = 'Parse/' + _CoreManager.default.get('VERSION') + ' (NodeJS ' + process.versions.node + ')';\n      }\n\n      if (isIdempotent) {\n        headers['X-Parse-Request-Id'] = requestId;\n      }\n\n      if (_CoreManager.default.get('SERVER_AUTH_TYPE') && _CoreManager.default.get('SERVER_AUTH_TOKEN')) {\n        headers['Authorization'] = _CoreManager.default.get('SERVER_AUTH_TYPE') + ' ' + _CoreManager.default.get('SERVER_AUTH_TOKEN');\n      }\n\n      const customHeaders = _CoreManager.default.get('REQUEST_HEADERS');\n\n      for (const key in customHeaders) {\n        headers[key] = customHeaders[key];\n      }\n\n      function handleProgress(type, event) {\n        if (options && typeof options.progress === 'function') {\n          if (event.lengthComputable) {\n            options.progress(event.loaded / event.total, event.loaded, event.total, {\n              type\n            });\n          } else {\n            options.progress(null, null, null, {\n              type\n            });\n          }\n        }\n      }\n\n      xhr.onprogress = event => {\n        handleProgress('download', event);\n      };\n\n      if (xhr.upload) {\n        xhr.upload.onprogress = event => {\n          handleProgress('upload', event);\n        };\n      }\n\n      xhr.open(method, url, true);\n\n      for (const h in headers) {\n        xhr.setRequestHeader(h, headers[h]);\n      }\n\n      xhr.onabort = function () {\n        promise.resolve({\n          response: {\n            results: []\n          },\n          status: 0,\n          xhr\n        });\n      };\n\n      xhr.send(data);\n\n      if (options && typeof options.requestTask === 'function') {\n        options.requestTask(xhr);\n      }\n    };\n\n    dispatch();\n    return promise;\n  },\n\n  request(method\n  /*: string*/\n  , path\n  /*: string*/\n  , data\n  /*: mixed*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n\n    let url = _CoreManager.default.get('SERVER_URL');\n\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n\n    url += path;\n    const payload = {};\n\n    if (data && typeof data === 'object') {\n      for (const k in data) {\n        payload[k] = data[k];\n      }\n    } // Add context\n\n\n    const context = options.context;\n\n    if (context !== undefined) {\n      payload._context = context;\n    }\n\n    if (method !== 'POST') {\n      payload._method = method;\n      method = 'POST';\n    }\n\n    payload._ApplicationId = _CoreManager.default.get('APPLICATION_ID');\n\n    const jsKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n\n    if (jsKey) {\n      payload._JavaScriptKey = jsKey;\n    }\n\n    payload._ClientVersion = _CoreManager.default.get('VERSION');\n    let useMasterKey = options.useMasterKey;\n\n    if (typeof useMasterKey === 'undefined') {\n      useMasterKey = _CoreManager.default.get('USE_MASTER_KEY');\n    }\n\n    if (useMasterKey) {\n      if (_CoreManager.default.get('MASTER_KEY')) {\n        delete payload._JavaScriptKey;\n        payload._MasterKey = _CoreManager.default.get('MASTER_KEY');\n      } else {\n        throw new Error('Cannot use the Master Key, it has not been provided.');\n      }\n    }\n\n    if (_CoreManager.default.get('FORCE_REVOCABLE_SESSION')) {\n      payload._RevocableSession = '1';\n    }\n\n    const installationId = options.installationId;\n    let installationIdPromise;\n\n    if (installationId && typeof installationId === 'string') {\n      installationIdPromise = Promise.resolve(installationId);\n    } else {\n      const installationController = _CoreManager.default.getInstallationController();\n\n      installationIdPromise = installationController.currentInstallationId();\n    }\n\n    return installationIdPromise.then(iid => {\n      payload._InstallationId = iid;\n\n      const userController = _CoreManager.default.getUserController();\n\n      if (options && typeof options.sessionToken === 'string') {\n        return Promise.resolve(options.sessionToken);\n      } else if (userController) {\n        return userController.currentUserAsync().then(user => {\n          if (user) {\n            return Promise.resolve(user.getSessionToken());\n          }\n\n          return Promise.resolve(null);\n        });\n      }\n\n      return Promise.resolve(null);\n    }).then(token => {\n      if (token) {\n        payload._SessionToken = token;\n      }\n\n      const payloadString = JSON.stringify(payload);\n      return RESTController.ajax(method, url, payloadString, {}, options).then(({\n        response,\n        status\n      }) => {\n        if (options.returnStatus) {\n          return _objectSpread(_objectSpread({}, response), {}, {\n            _status: status\n          });\n        } else {\n          return response;\n        }\n      });\n    }).catch(RESTController.handleError);\n  },\n\n  handleError(response) {\n    // Transform the error into an instance of ParseError by trying to parse\n    // the error string as JSON\n    let error;\n\n    if (response && response.responseText) {\n      try {\n        const errorJSON = JSON.parse(response.responseText);\n        error = new _ParseError.default(errorJSON.code, errorJSON.error);\n      } catch (e) {\n        // If we fail to parse the error text, that's okay.\n        error = new _ParseError.default(_ParseError.default.INVALID_JSON, 'Received an error with invalid JSON from Parse: ' + response.responseText);\n      }\n    } else {\n      const message = response.message ? response.message : response;\n      error = new _ParseError.default(_ParseError.default.CONNECTION_FAILED, 'XMLHttpRequest failed: ' + JSON.stringify(message));\n    }\n\n    return Promise.reject(error);\n  },\n\n  _setXHR(xhr\n  /*: any*/\n  ) {\n    XHR = xhr;\n  },\n\n  _getXHR() {\n    return XHR;\n  }\n\n};\nmodule.exports = RESTController;"]},"metadata":{},"sourceType":"script"}