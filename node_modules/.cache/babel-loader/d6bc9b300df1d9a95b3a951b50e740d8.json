{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nconst PUBLIC_KEY = '*';\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\n\nclass ParseACL {\n  /*:: permissionsById: ByIdMap;*/\n\n  /**\n   * @param {(Parse.User | object)} arg1 The user to initialize the ACL for\n   */\n  constructor(arg1\n  /*: ParseUser | ByIdMap*/\n  ) {\n    this.permissionsById = {};\n\n    if (arg1 && typeof arg1 === 'object') {\n      if (arg1 instanceof _ParseUser.default) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (const userId in arg1) {\n          const accessList = arg1[userId];\n          this.permissionsById[userId] = {};\n\n          for (const permission in accessList) {\n            const allowed = accessList[permission];\n\n            if (permission !== 'read' && permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n\n            this.permissionsById[userId][permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: ByIdMap*/\n  {\n    const permissions = {};\n\n    for (const p in this.permissionsById) {\n      permissions[p] = this.permissionsById[p];\n    }\n\n    return permissions;\n  }\n  /**\n   * Returns whether this ACL is equal to another object\n   *\n   * @param {ParseACL} other The other object's ACL to compare to\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: ParseACL*/\n  )\n  /*: boolean*/\n  {\n    if (!(other instanceof ParseACL)) {\n      return false;\n    }\n\n    const users = Object.keys(this.permissionsById);\n    const otherUsers = Object.keys(other.permissionsById);\n\n    if (users.length !== otherUsers.length) {\n      return false;\n    }\n\n    for (const u in this.permissionsById) {\n      if (!other.permissionsById[u]) {\n        return false;\n      }\n\n      if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n        return false;\n      }\n\n      if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _setAccess(accessType\n  /*: string*/\n  , userId\n  /*: ParseUser | ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n    } else if (userId instanceof _ParseRole.default) {\n      const name = userId.getName();\n\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n\n      userId = 'role:' + name;\n    }\n\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n\n    let permissions = this.permissionsById[userId];\n\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n    }\n\n    if (allowed) {\n      this.permissionsById[userId][accessType] = true;\n    } else {\n      delete permissions[accessType];\n\n      if (Object.keys(permissions).length === 0) {\n        delete this.permissionsById[userId];\n      }\n    }\n  }\n\n  _getAccess(accessType\n  /*: string*/\n  , userId\n  /*: ParseUser | ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n\n      if (!userId) {\n        throw new Error('Cannot get access for a ParseUser without an ID');\n      }\n    } else if (userId instanceof _ParseRole.default) {\n      const name = userId.getName();\n\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n\n      userId = 'role:' + name;\n    }\n\n    const permissions = this.permissionsById[userId];\n\n    if (!permissions) {\n      return false;\n    }\n\n    return !!permissions[accessType];\n  }\n  /**\n   * Sets whether the given user is allowed to read this object.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed Whether that user should have read access.\n   */\n\n\n  setReadAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('read', userId, allowed);\n  }\n  /**\n   * Get whether the given user id is *explicitly* allowed to read this object.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getReadAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('read', userId);\n  }\n  /**\n   * Sets whether the given user id is allowed to write this object.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n\n\n  setWriteAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('write', userId, allowed);\n  }\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write this object.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getWriteAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('write', userId);\n  }\n  /**\n   * Sets whether the public is allowed to read this object.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicReadAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to read this object.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicReadAccess()\n  /*: boolean*/\n  {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n  /**\n   * Sets whether the public is allowed to write this object.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicWriteAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to write this object.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicWriteAccess()\n  /*: boolean*/\n  {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleReadAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    return this.getReadAccess('role:' + role);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleWriteAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    return this.getWriteAccess('role:' + role);\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleReadAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    this.setReadAccess('role:' + role, allowed);\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleWriteAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    this.setWriteAccess('role:' + role, allowed);\n  }\n\n}\n\nvar _default = ParseACL;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseACL.js"],"names":["Object","defineProperty","exports","value","default","_ParseRole","_interopRequireDefault","require","_ParseUser","obj","__esModule","PUBLIC_KEY","ParseACL","constructor","arg1","permissionsById","setReadAccess","setWriteAccess","userId","accessList","permission","allowed","TypeError","toJSON","permissions","p","equals","other","users","keys","otherUsers","length","u","read","write","_setAccess","accessType","id","name","getName","_getAccess","Error","getReadAccess","getWriteAccess","setPublicReadAccess","getPublicReadAccess","setPublicWriteAccess","getPublicWriteAccess","getRoleReadAccess","role","getRoleWriteAccess","setRoleReadAccess","setRoleWriteAccess","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nconst PUBLIC_KEY = '*';\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\n\nclass ParseACL {\n  /*:: permissionsById: ByIdMap;*/\n\n  /**\n   * @param {(Parse.User | object)} arg1 The user to initialize the ACL for\n   */\n  constructor(arg1\n  /*: ParseUser | ByIdMap*/\n  ) {\n    this.permissionsById = {};\n\n    if (arg1 && typeof arg1 === 'object') {\n      if (arg1 instanceof _ParseUser.default) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (const userId in arg1) {\n          const accessList = arg1[userId];\n          this.permissionsById[userId] = {};\n\n          for (const permission in accessList) {\n            const allowed = accessList[permission];\n\n            if (permission !== 'read' && permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n\n            this.permissionsById[userId][permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: ByIdMap*/\n  {\n    const permissions = {};\n\n    for (const p in this.permissionsById) {\n      permissions[p] = this.permissionsById[p];\n    }\n\n    return permissions;\n  }\n  /**\n   * Returns whether this ACL is equal to another object\n   *\n   * @param {ParseACL} other The other object's ACL to compare to\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: ParseACL*/\n  )\n  /*: boolean*/\n  {\n    if (!(other instanceof ParseACL)) {\n      return false;\n    }\n\n    const users = Object.keys(this.permissionsById);\n    const otherUsers = Object.keys(other.permissionsById);\n\n    if (users.length !== otherUsers.length) {\n      return false;\n    }\n\n    for (const u in this.permissionsById) {\n      if (!other.permissionsById[u]) {\n        return false;\n      }\n\n      if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n        return false;\n      }\n\n      if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _setAccess(accessType\n  /*: string*/\n  , userId\n  /*: ParseUser | ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n    } else if (userId instanceof _ParseRole.default) {\n      const name = userId.getName();\n\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n\n      userId = 'role:' + name;\n    }\n\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n\n    let permissions = this.permissionsById[userId];\n\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n    }\n\n    if (allowed) {\n      this.permissionsById[userId][accessType] = true;\n    } else {\n      delete permissions[accessType];\n\n      if (Object.keys(permissions).length === 0) {\n        delete this.permissionsById[userId];\n      }\n    }\n  }\n\n  _getAccess(accessType\n  /*: string*/\n  , userId\n  /*: ParseUser | ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n\n      if (!userId) {\n        throw new Error('Cannot get access for a ParseUser without an ID');\n      }\n    } else if (userId instanceof _ParseRole.default) {\n      const name = userId.getName();\n\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n\n      userId = 'role:' + name;\n    }\n\n    const permissions = this.permissionsById[userId];\n\n    if (!permissions) {\n      return false;\n    }\n\n    return !!permissions[accessType];\n  }\n  /**\n   * Sets whether the given user is allowed to read this object.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed Whether that user should have read access.\n   */\n\n\n  setReadAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('read', userId, allowed);\n  }\n  /**\n   * Get whether the given user id is *explicitly* allowed to read this object.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getReadAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('read', userId);\n  }\n  /**\n   * Sets whether the given user id is allowed to write this object.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n\n\n  setWriteAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('write', userId, allowed);\n  }\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write this object.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getWriteAccess(userId\n  /*: ParseUser | ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('write', userId);\n  }\n  /**\n   * Sets whether the public is allowed to read this object.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicReadAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to read this object.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicReadAccess()\n  /*: boolean*/\n  {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n  /**\n   * Sets whether the public is allowed to write this object.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicWriteAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to write this object.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicWriteAccess()\n  /*: boolean*/\n  {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleReadAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    return this.getReadAccess('role:' + role);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleWriteAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    return this.getWriteAccess('role:' + role);\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleReadAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    this.setReadAccess('role:' + role, allowed);\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleWriteAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n\n    this.setWriteAccess('role:' + role, allowed);\n  }\n\n}\n\nvar _default = ParseACL;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}