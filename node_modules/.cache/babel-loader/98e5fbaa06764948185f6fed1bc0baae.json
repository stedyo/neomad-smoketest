{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnsetOp = exports.SetOp = exports.RemoveOp = exports.RelationOp = exports.Op = exports.IncrementOp = exports.AddUniqueOp = exports.AddOp = void 0;\nexports.opFromJSON = opFromJSON;\n\nvar _arrayContainsObject = _interopRequireDefault(require(\"./arrayContainsObject\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction opFromJSON(json\n/*: { [key: string]: any }*/\n)\n/*: ?Op*/\n{\n  if (!json || !json.__op) {\n    return null;\n  }\n\n  switch (json.__op) {\n    case 'Delete':\n      return new UnsetOp();\n\n    case 'Increment':\n      return new IncrementOp(json.amount);\n\n    case 'Add':\n      return new AddOp((0, _decode.default)(json.objects));\n\n    case 'AddUnique':\n      return new AddUniqueOp((0, _decode.default)(json.objects));\n\n    case 'Remove':\n      return new RemoveOp((0, _decode.default)(json.objects));\n\n    case 'AddRelation':\n      {\n        const toAdd = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toAdd)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp(toAdd, []);\n      }\n\n    case 'RemoveRelation':\n      {\n        const toRemove = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toRemove)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp([], toRemove);\n      }\n\n    case 'Batch':\n      {\n        let toAdd = [];\n        let toRemove = [];\n\n        for (let i = 0; i < json.ops.length; i++) {\n          if (json.ops[i].__op === 'AddRelation') {\n            toAdd = toAdd.concat((0, _decode.default)(json.ops[i].objects));\n          } else if (json.ops[i].__op === 'RemoveRelation') {\n            toRemove = toRemove.concat((0, _decode.default)(json.ops[i].objects));\n          }\n        }\n\n        return new RelationOp(toAdd, toRemove);\n      }\n  }\n\n  return null;\n}\n\nclass Op {\n  // Empty parent class\n  applyTo()\n  /*: mixed*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  mergeWith()\n  /*: ?Op*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  toJSON()\n  /*: mixed*/\n  {}\n\n}\n\nexports.Op = Op;\n\nclass SetOp extends Op {\n  /*:: _value: ?mixed;*/\n  constructor(value\n  /*: mixed*/\n  ) {\n    super();\n    this._value = value;\n  }\n\n  applyTo()\n  /*: mixed*/\n  {\n    return this._value;\n  }\n\n  mergeWith()\n  /*: SetOp*/\n  {\n    return new SetOp(this._value);\n  }\n\n  toJSON(offline\n  /*:: ?: boolean*/\n  ) {\n    return (0, _encode.default)(this._value, false, true, undefined, offline);\n  }\n\n}\n\nexports.SetOp = SetOp;\n\nclass UnsetOp extends Op {\n  applyTo() {\n    return undefined;\n  }\n\n  mergeWith()\n  /*: UnsetOp*/\n  {\n    return new UnsetOp();\n  }\n\n  toJSON()\n  /*: { __op: string }*/\n  {\n    return {\n      __op: 'Delete'\n    };\n  }\n\n}\n\nexports.UnsetOp = UnsetOp;\n\nclass IncrementOp extends Op {\n  /*:: _amount: number;*/\n  constructor(amount\n  /*: number*/\n  ) {\n    super();\n\n    if (typeof amount !== 'number') {\n      throw new TypeError('Increment Op must be initialized with a numeric amount.');\n    }\n\n    this._amount = amount;\n  }\n\n  applyTo(value\n  /*: ?mixed*/\n  )\n  /*: number*/\n  {\n    if (typeof value === 'undefined') {\n      return this._amount;\n    }\n\n    if (typeof value !== 'number') {\n      throw new TypeError('Cannot increment a non-numeric value.');\n    }\n\n    return this._amount + value;\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._amount);\n    }\n\n    if (previous instanceof IncrementOp) {\n      return new IncrementOp(this.applyTo(previous._amount));\n    }\n\n    throw new Error('Cannot merge Increment Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, amount: number }*/\n  {\n    return {\n      __op: 'Increment',\n      amount: this._amount\n    };\n  }\n\n}\n\nexports.IncrementOp = IncrementOp;\n\nclass AddOp extends Op {\n  /*:: _value: Array<mixed>;*/\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n    this._value = Array.isArray(value) ? value : [value];\n  }\n\n  applyTo(value\n  /*: mixed*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value;\n    }\n\n    if (Array.isArray(value)) {\n      return value.concat(this._value);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddOp) {\n      return new AddOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge Add Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Add',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddOp = AddOp;\n\nclass AddUniqueOp extends Op {\n  /*:: _value: Array<mixed>;*/\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value || [];\n    }\n\n    if (Array.isArray(value)) {\n      const toAdd = [];\n\n      this._value.forEach(v => {\n        if (v instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(value, v)) {\n            toAdd.push(v);\n          }\n        } else {\n          if (value.indexOf(v) < 0) {\n            toAdd.push(v);\n          }\n        }\n      });\n\n      return value.concat(toAdd);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddUniqueOp) {\n      return new AddUniqueOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge AddUnique Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'AddUnique',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddUniqueOp = AddUniqueOp;\n\nclass RemoveOp extends Op {\n  /*:: _value: Array<mixed>;*/\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return [];\n    }\n\n    if (Array.isArray(value)) {\n      // var i = value.indexOf(this._value);\n      const removed = value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        let index = removed.indexOf(this._value[i]);\n\n        while (index > -1) {\n          removed.splice(index, 1);\n          index = removed.indexOf(this._value[i]);\n        }\n\n        if (this._value[i] instanceof _ParseObject.default && this._value[i].id) {\n          for (let j = 0; j < removed.length; j++) {\n            if (removed[j] instanceof _ParseObject.default && this._value[i].id === removed[j].id) {\n              removed.splice(j, 1);\n              j--;\n            }\n          }\n        }\n      }\n\n      return removed;\n    }\n\n    throw new Error('Cannot remove elements from a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new UnsetOp();\n    }\n\n    if (previous instanceof RemoveOp) {\n      const uniques = previous._value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        if (this._value[i] instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(uniques, this._value[i])) {\n            uniques.push(this._value[i]);\n          }\n        } else {\n          if (uniques.indexOf(this._value[i]) < 0) {\n            uniques.push(this._value[i]);\n          }\n        }\n      }\n\n      return new RemoveOp(uniques);\n    }\n\n    throw new Error('Cannot merge Remove Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Remove',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.RemoveOp = RemoveOp;\n\nclass RelationOp extends Op {\n  /*:: _targetClassName: ?string;*/\n\n  /*:: relationsToAdd: Array<string>;*/\n\n  /*:: relationsToRemove: Array<string>;*/\n  constructor(adds\n  /*: Array<ParseObject | string>*/\n  , removes\n  /*: Array<ParseObject | string>*/\n  ) {\n    super();\n    this._targetClassName = null;\n\n    if (Array.isArray(adds)) {\n      this.relationsToAdd = (0, _unique.default)(adds.map(this._extractId, this));\n    }\n\n    if (Array.isArray(removes)) {\n      this.relationsToRemove = (0, _unique.default)(removes.map(this._extractId, this));\n    }\n  }\n\n  _extractId(obj\n  /*: string | ParseObject*/\n  )\n  /*: string*/\n  {\n    if (typeof obj === 'string') {\n      return obj;\n    }\n\n    if (!obj.id) {\n      throw new Error('You cannot add or remove an unsaved Parse Object from a relation');\n    }\n\n    if (!this._targetClassName) {\n      this._targetClassName = obj.className;\n    }\n\n    if (this._targetClassName !== obj.className) {\n      throw new Error('Tried to create a Relation with 2 different object types: ' + this._targetClassName + ' and ' + obj.className + '.');\n    }\n\n    return obj.id;\n  }\n\n  applyTo(value\n  /*: mixed*/\n  , object\n  /*:: ?: { className: string, id: ?string }*/\n  , key\n  /*:: ?: string*/\n  )\n  /*: ?ParseRelation*/\n  {\n    if (!value) {\n      if (!object || !key) {\n        throw new Error('Cannot apply a RelationOp without either a previous value, or an object and a key');\n      }\n\n      const parent = new _ParseObject.default(object.className);\n\n      if (object.id && object.id.indexOf('local') === 0) {\n        parent._localId = object.id;\n      } else if (object.id) {\n        parent.id = object.id;\n      }\n\n      const relation = new _ParseRelation.default(parent, key);\n      relation.targetClassName = this._targetClassName;\n      return relation;\n    }\n\n    if (value instanceof _ParseRelation.default) {\n      if (this._targetClassName) {\n        if (value.targetClassName) {\n          if (this._targetClassName !== value.targetClassName) {\n            throw new Error('Related object must be a ' + value.targetClassName + ', but a ' + this._targetClassName + ' was passed in.');\n          }\n        } else {\n          value.targetClassName = this._targetClassName;\n        }\n      }\n\n      return value;\n    } else {\n      throw new Error('Relation cannot be applied to a non-relation field');\n    }\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    } else if (previous instanceof UnsetOp) {\n      throw new Error('You cannot modify a relation after deleting it.');\n    } else if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {\n      return this;\n    } else if (previous instanceof RelationOp) {\n      if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {\n        throw new Error('Related object must be of class ' + previous._targetClassName + ', but ' + (this._targetClassName || 'null') + ' was passed in.');\n      }\n\n      const newAdd = previous.relationsToAdd.concat([]);\n      this.relationsToRemove.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index > -1) {\n          newAdd.splice(index, 1);\n        }\n      });\n      this.relationsToAdd.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index < 0) {\n          newAdd.push(r);\n        }\n      });\n      const newRemove = previous.relationsToRemove.concat([]);\n      this.relationsToAdd.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index > -1) {\n          newRemove.splice(index, 1);\n        }\n      });\n      this.relationsToRemove.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index < 0) {\n          newRemove.push(r);\n        }\n      });\n      const newRelation = new RelationOp(newAdd, newRemove);\n      newRelation._targetClassName = this._targetClassName;\n      return newRelation;\n    }\n\n    throw new Error('Cannot merge Relation Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op?: string, objects?: mixed, ops?: mixed }*/\n  {\n    const idToPointer = id => {\n      return {\n        __type: 'Pointer',\n        className: this._targetClassName,\n        objectId: id\n      };\n    };\n\n    let adds = null;\n    let removes = null;\n    let pointers = null;\n\n    if (this.relationsToAdd.length > 0) {\n      pointers = this.relationsToAdd.map(idToPointer);\n      adds = {\n        __op: 'AddRelation',\n        objects: pointers\n      };\n    }\n\n    if (this.relationsToRemove.length > 0) {\n      pointers = this.relationsToRemove.map(idToPointer);\n      removes = {\n        __op: 'RemoveRelation',\n        objects: pointers\n      };\n    }\n\n    if (adds && removes) {\n      return {\n        __op: 'Batch',\n        ops: [adds, removes]\n      };\n    }\n\n    return adds || removes || {};\n  }\n\n}\n\nexports.RelationOp = RelationOp;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseOp.js"],"names":["Object","defineProperty","exports","value","UnsetOp","SetOp","RemoveOp","RelationOp","Op","IncrementOp","AddUniqueOp","AddOp","opFromJSON","_arrayContainsObject","_interopRequireDefault","require","_decode","_encode","_ParseObject","_ParseRelation","_unique","obj","__esModule","default","json","__op","amount","objects","toAdd","Array","isArray","toRemove","i","ops","length","concat","applyTo","mergeWith","toJSON","constructor","_value","offline","undefined","TypeError","_amount","previous","Error","forEach","v","push","indexOf","removed","index","splice","id","j","uniques","adds","removes","_targetClassName","relationsToAdd","map","_extractId","relationsToRemove","className","object","key","parent","_localId","relation","targetClassName","newAdd","r","newRemove","newRelation","idToPointer","__type","objectId","pointers"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnsetOp = exports.SetOp = exports.RemoveOp = exports.RelationOp = exports.Op = exports.IncrementOp = exports.AddUniqueOp = exports.AddOp = void 0;\nexports.opFromJSON = opFromJSON;\n\nvar _arrayContainsObject = _interopRequireDefault(require(\"./arrayContainsObject\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction opFromJSON(json\n/*: { [key: string]: any }*/\n)\n/*: ?Op*/\n{\n  if (!json || !json.__op) {\n    return null;\n  }\n\n  switch (json.__op) {\n    case 'Delete':\n      return new UnsetOp();\n\n    case 'Increment':\n      return new IncrementOp(json.amount);\n\n    case 'Add':\n      return new AddOp((0, _decode.default)(json.objects));\n\n    case 'AddUnique':\n      return new AddUniqueOp((0, _decode.default)(json.objects));\n\n    case 'Remove':\n      return new RemoveOp((0, _decode.default)(json.objects));\n\n    case 'AddRelation':\n      {\n        const toAdd = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toAdd)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp(toAdd, []);\n      }\n\n    case 'RemoveRelation':\n      {\n        const toRemove = (0, _decode.default)(json.objects);\n\n        if (!Array.isArray(toRemove)) {\n          return new RelationOp([], []);\n        }\n\n        return new RelationOp([], toRemove);\n      }\n\n    case 'Batch':\n      {\n        let toAdd = [];\n        let toRemove = [];\n\n        for (let i = 0; i < json.ops.length; i++) {\n          if (json.ops[i].__op === 'AddRelation') {\n            toAdd = toAdd.concat((0, _decode.default)(json.ops[i].objects));\n          } else if (json.ops[i].__op === 'RemoveRelation') {\n            toRemove = toRemove.concat((0, _decode.default)(json.ops[i].objects));\n          }\n        }\n\n        return new RelationOp(toAdd, toRemove);\n      }\n  }\n\n  return null;\n}\n\nclass Op {\n  // Empty parent class\n  applyTo()\n  /*: mixed*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  mergeWith()\n  /*: ?Op*/\n  {}\n  /* eslint-disable-line no-unused-vars */\n\n\n  toJSON()\n  /*: mixed*/\n  {}\n\n}\n\nexports.Op = Op;\n\nclass SetOp extends Op {\n  /*:: _value: ?mixed;*/\n  constructor(value\n  /*: mixed*/\n  ) {\n    super();\n    this._value = value;\n  }\n\n  applyTo()\n  /*: mixed*/\n  {\n    return this._value;\n  }\n\n  mergeWith()\n  /*: SetOp*/\n  {\n    return new SetOp(this._value);\n  }\n\n  toJSON(offline\n  /*:: ?: boolean*/\n  ) {\n    return (0, _encode.default)(this._value, false, true, undefined, offline);\n  }\n\n}\n\nexports.SetOp = SetOp;\n\nclass UnsetOp extends Op {\n  applyTo() {\n    return undefined;\n  }\n\n  mergeWith()\n  /*: UnsetOp*/\n  {\n    return new UnsetOp();\n  }\n\n  toJSON()\n  /*: { __op: string }*/\n  {\n    return {\n      __op: 'Delete'\n    };\n  }\n\n}\n\nexports.UnsetOp = UnsetOp;\n\nclass IncrementOp extends Op {\n  /*:: _amount: number;*/\n  constructor(amount\n  /*: number*/\n  ) {\n    super();\n\n    if (typeof amount !== 'number') {\n      throw new TypeError('Increment Op must be initialized with a numeric amount.');\n    }\n\n    this._amount = amount;\n  }\n\n  applyTo(value\n  /*: ?mixed*/\n  )\n  /*: number*/\n  {\n    if (typeof value === 'undefined') {\n      return this._amount;\n    }\n\n    if (typeof value !== 'number') {\n      throw new TypeError('Cannot increment a non-numeric value.');\n    }\n\n    return this._amount + value;\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._amount);\n    }\n\n    if (previous instanceof IncrementOp) {\n      return new IncrementOp(this.applyTo(previous._amount));\n    }\n\n    throw new Error('Cannot merge Increment Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, amount: number }*/\n  {\n    return {\n      __op: 'Increment',\n      amount: this._amount\n    };\n  }\n\n}\n\nexports.IncrementOp = IncrementOp;\n\nclass AddOp extends Op {\n  /*:: _value: Array<mixed>;*/\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n    this._value = Array.isArray(value) ? value : [value];\n  }\n\n  applyTo(value\n  /*: mixed*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value;\n    }\n\n    if (Array.isArray(value)) {\n      return value.concat(this._value);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddOp) {\n      return new AddOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge Add Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Add',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddOp = AddOp;\n\nclass AddUniqueOp extends Op {\n  /*:: _value: Array<mixed>;*/\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return this._value || [];\n    }\n\n    if (Array.isArray(value)) {\n      const toAdd = [];\n\n      this._value.forEach(v => {\n        if (v instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(value, v)) {\n            toAdd.push(v);\n          }\n        } else {\n          if (value.indexOf(v) < 0) {\n            toAdd.push(v);\n          }\n        }\n      });\n\n      return value.concat(toAdd);\n    }\n\n    throw new Error('Cannot add elements to a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new SetOp(this._value);\n    }\n\n    if (previous instanceof AddUniqueOp) {\n      return new AddUniqueOp(this.applyTo(previous._value));\n    }\n\n    throw new Error('Cannot merge AddUnique Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'AddUnique',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.AddUniqueOp = AddUniqueOp;\n\nclass RemoveOp extends Op {\n  /*:: _value: Array<mixed>;*/\n  constructor(value\n  /*: mixed | Array<mixed>*/\n  ) {\n    super();\n    this._value = (0, _unique.default)(Array.isArray(value) ? value : [value]);\n  }\n\n  applyTo(value\n  /*: mixed | Array<mixed>*/\n  )\n  /*: Array<mixed>*/\n  {\n    if (value == null) {\n      return [];\n    }\n\n    if (Array.isArray(value)) {\n      // var i = value.indexOf(this._value);\n      const removed = value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        let index = removed.indexOf(this._value[i]);\n\n        while (index > -1) {\n          removed.splice(index, 1);\n          index = removed.indexOf(this._value[i]);\n        }\n\n        if (this._value[i] instanceof _ParseObject.default && this._value[i].id) {\n          for (let j = 0; j < removed.length; j++) {\n            if (removed[j] instanceof _ParseObject.default && this._value[i].id === removed[j].id) {\n              removed.splice(j, 1);\n              j--;\n            }\n          }\n        }\n      }\n\n      return removed;\n    }\n\n    throw new Error('Cannot remove elements from a non-array value');\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    }\n\n    if (previous instanceof SetOp) {\n      return new SetOp(this.applyTo(previous._value));\n    }\n\n    if (previous instanceof UnsetOp) {\n      return new UnsetOp();\n    }\n\n    if (previous instanceof RemoveOp) {\n      const uniques = previous._value.concat([]);\n\n      for (let i = 0; i < this._value.length; i++) {\n        if (this._value[i] instanceof _ParseObject.default) {\n          if (!(0, _arrayContainsObject.default)(uniques, this._value[i])) {\n            uniques.push(this._value[i]);\n          }\n        } else {\n          if (uniques.indexOf(this._value[i]) < 0) {\n            uniques.push(this._value[i]);\n          }\n        }\n      }\n\n      return new RemoveOp(uniques);\n    }\n\n    throw new Error('Cannot merge Remove Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op: string, objects: mixed }*/\n  {\n    return {\n      __op: 'Remove',\n      objects: (0, _encode.default)(this._value, false, true)\n    };\n  }\n\n}\n\nexports.RemoveOp = RemoveOp;\n\nclass RelationOp extends Op {\n  /*:: _targetClassName: ?string;*/\n\n  /*:: relationsToAdd: Array<string>;*/\n\n  /*:: relationsToRemove: Array<string>;*/\n  constructor(adds\n  /*: Array<ParseObject | string>*/\n  , removes\n  /*: Array<ParseObject | string>*/\n  ) {\n    super();\n    this._targetClassName = null;\n\n    if (Array.isArray(adds)) {\n      this.relationsToAdd = (0, _unique.default)(adds.map(this._extractId, this));\n    }\n\n    if (Array.isArray(removes)) {\n      this.relationsToRemove = (0, _unique.default)(removes.map(this._extractId, this));\n    }\n  }\n\n  _extractId(obj\n  /*: string | ParseObject*/\n  )\n  /*: string*/\n  {\n    if (typeof obj === 'string') {\n      return obj;\n    }\n\n    if (!obj.id) {\n      throw new Error('You cannot add or remove an unsaved Parse Object from a relation');\n    }\n\n    if (!this._targetClassName) {\n      this._targetClassName = obj.className;\n    }\n\n    if (this._targetClassName !== obj.className) {\n      throw new Error('Tried to create a Relation with 2 different object types: ' + this._targetClassName + ' and ' + obj.className + '.');\n    }\n\n    return obj.id;\n  }\n\n  applyTo(value\n  /*: mixed*/\n  , object\n  /*:: ?: { className: string, id: ?string }*/\n  , key\n  /*:: ?: string*/\n  )\n  /*: ?ParseRelation*/\n  {\n    if (!value) {\n      if (!object || !key) {\n        throw new Error('Cannot apply a RelationOp without either a previous value, or an object and a key');\n      }\n\n      const parent = new _ParseObject.default(object.className);\n\n      if (object.id && object.id.indexOf('local') === 0) {\n        parent._localId = object.id;\n      } else if (object.id) {\n        parent.id = object.id;\n      }\n\n      const relation = new _ParseRelation.default(parent, key);\n      relation.targetClassName = this._targetClassName;\n      return relation;\n    }\n\n    if (value instanceof _ParseRelation.default) {\n      if (this._targetClassName) {\n        if (value.targetClassName) {\n          if (this._targetClassName !== value.targetClassName) {\n            throw new Error('Related object must be a ' + value.targetClassName + ', but a ' + this._targetClassName + ' was passed in.');\n          }\n        } else {\n          value.targetClassName = this._targetClassName;\n        }\n      }\n\n      return value;\n    } else {\n      throw new Error('Relation cannot be applied to a non-relation field');\n    }\n  }\n\n  mergeWith(previous\n  /*: Op*/\n  )\n  /*: Op*/\n  {\n    if (!previous) {\n      return this;\n    } else if (previous instanceof UnsetOp) {\n      throw new Error('You cannot modify a relation after deleting it.');\n    } else if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {\n      return this;\n    } else if (previous instanceof RelationOp) {\n      if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {\n        throw new Error('Related object must be of class ' + previous._targetClassName + ', but ' + (this._targetClassName || 'null') + ' was passed in.');\n      }\n\n      const newAdd = previous.relationsToAdd.concat([]);\n      this.relationsToRemove.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index > -1) {\n          newAdd.splice(index, 1);\n        }\n      });\n      this.relationsToAdd.forEach(r => {\n        const index = newAdd.indexOf(r);\n\n        if (index < 0) {\n          newAdd.push(r);\n        }\n      });\n      const newRemove = previous.relationsToRemove.concat([]);\n      this.relationsToAdd.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index > -1) {\n          newRemove.splice(index, 1);\n        }\n      });\n      this.relationsToRemove.forEach(r => {\n        const index = newRemove.indexOf(r);\n\n        if (index < 0) {\n          newRemove.push(r);\n        }\n      });\n      const newRelation = new RelationOp(newAdd, newRemove);\n      newRelation._targetClassName = this._targetClassName;\n      return newRelation;\n    }\n\n    throw new Error('Cannot merge Relation Op with the previous Op');\n  }\n\n  toJSON()\n  /*: { __op?: string, objects?: mixed, ops?: mixed }*/\n  {\n    const idToPointer = id => {\n      return {\n        __type: 'Pointer',\n        className: this._targetClassName,\n        objectId: id\n      };\n    };\n\n    let adds = null;\n    let removes = null;\n    let pointers = null;\n\n    if (this.relationsToAdd.length > 0) {\n      pointers = this.relationsToAdd.map(idToPointer);\n      adds = {\n        __op: 'AddRelation',\n        objects: pointers\n      };\n    }\n\n    if (this.relationsToRemove.length > 0) {\n      pointers = this.relationsToRemove.map(idToPointer);\n      removes = {\n        __op: 'RemoveRelation',\n        objects: pointers\n      };\n    }\n\n    if (adds && removes) {\n      return {\n        __op: 'Batch',\n        ops: [adds, removes]\n      };\n    }\n\n    return adds || removes || {};\n  }\n\n}\n\nexports.RelationOp = RelationOp;"]},"metadata":{},"sourceType":"script"}