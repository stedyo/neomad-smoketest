{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _canBeSerialized = _interopRequireDefault(require(\"./canBeSerialized\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _escape = _interopRequireDefault(require(\"./escape\"));\n\nvar _EventuallyQueue = _interopRequireDefault(require(\"./EventuallyQueue\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _parseDate = _interopRequireDefault(require(\"./parseDate\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar SingleInstanceStateController = _interopRequireWildcard(require(\"./SingleInstanceStateController\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n\nvar UniqueInstanceStateController = _interopRequireWildcard(require(\"./UniqueInstanceStateController\"));\n\nvar _unsavedChildren = _interopRequireDefault(require(\"./unsavedChildren\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst uuidv4 = require('./uuid');\n/*:: export type Pointer = {\n  __type: string,\n  className: string,\n  objectId: string,\n};*/\n\n/*:: type SaveParams = {\n  method: string,\n  path: string,\n  body: AttributeMap,\n};*/\n\n/*:: export type SaveOptions = FullOptions & {\n  cascadeSave?: boolean,\n  context?: AttributeMap,\n};*/\n// Mapping of class names to constructors, so we can populate objects from the\n// server with appropriate subclasses of ParseObject\n\n\nconst classMap = {}; // Global counter for generating unique Ids for non-single-instance objects\n\nlet objectCount = 0; // On web clients, objects are single-instance: any two objects with the same Id\n// will have the same attributes. However, this may be dangerous default\n// behavior in a server scenario\n\nlet singleInstance = !_CoreManager.default.get('IS_NODE');\n\nif (singleInstance) {\n  _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n} else {\n  _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n}\n\nfunction getServerUrlPath() {\n  let serverUrl = _CoreManager.default.get('SERVER_URL');\n\n  if (serverUrl[serverUrl.length - 1] !== '/') {\n    serverUrl += '/';\n  }\n\n  const url = serverUrl.replace(/https?:\\/\\//, '');\n  return url.substr(url.indexOf('/'));\n}\n/**\n * Creates a new model with defined attributes.\n *\n * <p>You won't normally call this method directly.  It is recommended that\n * you use a subclass of <code>Parse.Object</code> instead, created by calling\n * <code>extend</code>.</p>\n *\n * <p>However, if you don't want to use a subclass, or aren't sure which\n * subclass is appropriate, you can use this form:<pre>\n *     var object = new Parse.Object(\"ClassName\");\n * </pre>\n * That is basically equivalent to:<pre>\n *     var MyClass = Parse.Object.extend(\"ClassName\");\n *     var object = new MyClass();\n * </pre></p>\n *\n * @alias Parse.Object\n */\n\n\nclass ParseObject {\n  /**\n   * @param {string} className The class name for the object\n   * @param {object} attributes The initial set of data to store in the object.\n   * @param {object} options The options for this object instance.\n   */\n  constructor(className\n  /*: ?string | { className: string, [attr: string]: mixed }*/\n  , attributes\n  /*:: ?: { [attr: string]: mixed }*/\n  , options\n  /*:: ?: { ignoreValidation: boolean }*/\n  ) {\n    // Enable legacy initializers\n    if (typeof this.initialize === 'function') {\n      this.initialize.apply(this, arguments);\n    }\n\n    let toSet = null;\n    this._objCount = objectCount++;\n\n    if (typeof className === 'string') {\n      this.className = className;\n\n      if (attributes && typeof attributes === 'object') {\n        toSet = attributes;\n      }\n    } else if (className && typeof className === 'object') {\n      this.className = className.className;\n      toSet = {};\n\n      for (const attr in className) {\n        if (attr !== 'className') {\n          toSet[attr] = className[attr];\n        }\n      }\n\n      if (attributes && typeof attributes === 'object') {\n        options = attributes;\n      }\n    }\n\n    if (toSet && !this.set(toSet, options)) {\n      throw new Error(\"Can't create an invalid Parse Object\");\n    }\n  }\n  /**\n   * The ID of this object, unique within its class.\n   *\n   * @property {string} id\n   */\n\n  /*:: id: ?string;*/\n\n  /*:: _localId: ?string;*/\n\n  /*:: _objCount: number;*/\n\n  /*:: className: string;*/\n\n  /** Prototype getters / setters **/\n\n\n  get attributes()\n  /*: AttributeMap*/\n  {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    return Object.freeze(stateController.estimateAttributes(this._getStateIdentifier()));\n  }\n  /**\n   * The first time this object was saved on the server.\n   *\n   * @property {Date} createdAt\n   * @returns {Date}\n   */\n\n\n  get createdAt()\n  /*: ?Date*/\n  {\n    return this._getServerData().createdAt;\n  }\n  /**\n   * The last time this object was updated on the server.\n   *\n   * @property {Date} updatedAt\n   * @returns {Date}\n   */\n\n\n  get updatedAt()\n  /*: ?Date*/\n  {\n    return this._getServerData().updatedAt;\n  }\n  /** Private methods **/\n\n  /**\n   * Returns a local or server Id used uniquely identify this object\n   *\n   * @returns {string}\n   */\n\n\n  _getId()\n  /*: string*/\n  {\n    if (typeof this.id === 'string') {\n      return this.id;\n    }\n\n    if (typeof this._localId === 'string') {\n      return this._localId;\n    }\n\n    const localId = 'local' + uuidv4();\n    this._localId = localId;\n    return localId;\n  }\n  /**\n   * Returns a unique identifier used to pull data from the State Controller.\n   *\n   * @returns {Parse.Object|object}\n   */\n\n\n  _getStateIdentifier()\n  /*: ParseObject | { id: string, className: string }*/\n  {\n    if (singleInstance) {\n      let id = this.id;\n\n      if (!id) {\n        id = this._getId();\n      }\n\n      return {\n        id: id,\n        className: this.className\n      };\n    } else {\n      return this;\n    }\n  }\n\n  _getServerData()\n  /*: AttributeMap*/\n  {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    return stateController.getServerData(this._getStateIdentifier());\n  }\n\n  _clearServerData() {\n    const serverData = this._getServerData();\n\n    const unset = {};\n\n    for (const attr in serverData) {\n      unset[attr] = undefined;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.setServerData(this._getStateIdentifier(), unset);\n  }\n\n  _getPendingOps()\n  /*: Array<OpsMap>*/\n  {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    return stateController.getPendingOps(this._getStateIdentifier());\n  }\n  /**\n   * @param {Array<string>} [keysToClear] - if specified, only ops matching\n   * these fields will be cleared\n   */\n\n\n  _clearPendingOps(keysToClear\n  /*:: ?: Array<string>*/\n  ) {\n    const pending = this._getPendingOps();\n\n    const latest = pending[pending.length - 1];\n    const keys = keysToClear || Object.keys(latest);\n    keys.forEach(key => {\n      delete latest[key];\n    });\n  }\n\n  _getDirtyObjectAttributes()\n  /*: AttributeMap*/\n  {\n    const attributes = this.attributes;\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const objectCache = stateController.getObjectCache(this._getStateIdentifier());\n    const dirty = {};\n\n    for (const attr in attributes) {\n      const val = attributes[attr];\n\n      if (val && typeof val === 'object' && !(val instanceof ParseObject) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n        // Due to the way browsers construct maps, the key order will not change\n        // unless the object is changed\n        try {\n          const json = (0, _encode.default)(val, false, true);\n          const stringified = JSON.stringify(json);\n\n          if (objectCache[attr] !== stringified) {\n            dirty[attr] = val;\n          }\n        } catch (e) {\n          // Error occurred, possibly by a nested unsaved pointer in a mutable container\n          // No matter how it happened, it indicates a change in the attribute\n          dirty[attr] = val;\n        }\n      }\n    }\n\n    return dirty;\n  }\n\n  _toFullJSON(seen\n  /*:: ?: Array<any>*/\n  , offline\n  /*:: ?: boolean*/\n  )\n  /*: AttributeMap*/\n  {\n    const json\n    /*: { [key: string]: mixed }*/\n    = this.toJSON(seen, offline);\n    json.__type = 'Object';\n    json.className = this.className;\n    return json;\n  }\n\n  _getSaveJSON()\n  /*: AttributeMap*/\n  {\n    const pending = this._getPendingOps();\n\n    const dirtyObjects = this._getDirtyObjectAttributes();\n\n    const json = {};\n\n    for (var attr in dirtyObjects) {\n      let isDotNotation = false;\n\n      for (let i = 0; i < pending.length; i += 1) {\n        for (const field in pending[i]) {\n          // Dot notation operations are handled later\n          if (field.includes('.')) {\n            const fieldName = field.split('.')[0];\n\n            if (fieldName === attr) {\n              isDotNotation = true;\n              break;\n            }\n          }\n        }\n      }\n\n      if (!isDotNotation) {\n        json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();\n      }\n    }\n\n    for (attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON();\n    }\n\n    return json;\n  }\n\n  _getSaveParams()\n  /*: SaveParams*/\n  {\n    let method = this.id ? 'PUT' : 'POST';\n\n    const body = this._getSaveJSON();\n\n    let path = 'classes/' + this.className;\n\n    if (_CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID')) {\n      if (!this.createdAt) {\n        method = 'POST';\n        body.objectId = this.id;\n      } else {\n        method = 'PUT';\n        path += '/' + this.id;\n      }\n    } else if (this.id) {\n      path += '/' + this.id;\n    } else if (this.className === '_User') {\n      path = 'users';\n    }\n\n    return {\n      method,\n      body,\n      path\n    };\n  }\n\n  _finishFetch(serverData\n  /*: AttributeMap*/\n  ) {\n    if (!this.id && serverData.objectId) {\n      this.id = serverData.objectId;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.initializeState(this._getStateIdentifier());\n    const decoded = {};\n\n    for (const attr in serverData) {\n      if (attr === 'ACL') {\n        decoded[attr] = new _ParseACL.default(serverData[attr]);\n      } else if (attr !== 'objectId') {\n        decoded[attr] = (0, _decode.default)(serverData[attr]);\n\n        if (decoded[attr] instanceof _ParseRelation.default) {\n          decoded[attr]._ensureParentAndKey(this, attr);\n        }\n      }\n    }\n\n    if (decoded.createdAt && typeof decoded.createdAt === 'string') {\n      decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);\n    }\n\n    if (decoded.updatedAt && typeof decoded.updatedAt === 'string') {\n      decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);\n    }\n\n    if (!decoded.updatedAt && decoded.createdAt) {\n      decoded.updatedAt = decoded.createdAt;\n    }\n\n    stateController.commitServerChanges(this._getStateIdentifier(), decoded);\n  }\n\n  _setExisted(existed\n  /*: boolean*/\n  ) {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const state = stateController.getState(this._getStateIdentifier());\n\n    if (state) {\n      state.existed = existed;\n    }\n  }\n\n  _migrateId(serverId\n  /*: string*/\n  ) {\n    if (this._localId && serverId) {\n      if (singleInstance) {\n        const stateController = _CoreManager.default.getObjectStateController();\n\n        const oldState = stateController.removeState(this._getStateIdentifier());\n        this.id = serverId;\n        delete this._localId;\n\n        if (oldState) {\n          stateController.initializeState(this._getStateIdentifier(), oldState);\n        }\n      } else {\n        this.id = serverId;\n        delete this._localId;\n      }\n    }\n  }\n\n  _handleSaveResponse(response\n  /*: AttributeMap*/\n  , status\n  /*: number*/\n  ) {\n    const changes = {};\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const pending = stateController.popPendingState(this._getStateIdentifier());\n\n    for (var attr in pending) {\n      if (pending[attr] instanceof _ParseOp.RelationOp) {\n        changes[attr] = pending[attr].applyTo(undefined, this, attr);\n      } else if (!(attr in response)) {\n        // Only SetOps and UnsetOps should not come back with results\n        changes[attr] = pending[attr].applyTo(undefined);\n      }\n    }\n\n    for (attr in response) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && typeof response[attr] === 'string') {\n        changes[attr] = (0, _parseDate.default)(response[attr]);\n      } else if (attr === 'ACL') {\n        changes[attr] = new _ParseACL.default(response[attr]);\n      } else if (attr !== 'objectId') {\n        const val = (0, _decode.default)(response[attr]);\n\n        if (val && Object.getPrototypeOf(val) === Object.prototype) {\n          changes[attr] = _objectSpread(_objectSpread({}, this.attributes[attr]), val);\n        } else {\n          changes[attr] = val;\n        }\n\n        if (changes[attr] instanceof _ParseOp.UnsetOp) {\n          changes[attr] = undefined;\n        }\n      }\n    }\n\n    if (changes.createdAt && !changes.updatedAt) {\n      changes.updatedAt = changes.createdAt;\n    }\n\n    this._migrateId(response.objectId);\n\n    if (status !== 201) {\n      this._setExisted(true);\n    }\n\n    stateController.commitServerChanges(this._getStateIdentifier(), changes);\n  }\n\n  _handleSaveError() {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.mergeFirstPendingState(this._getStateIdentifier());\n  }\n\n  static _getClassMap() {\n    return classMap;\n  }\n  /** Public methods **/\n\n\n  initialize() {} // NOOP\n\n  /**\n   * Returns a JSON version of the object suitable for saving to Parse.\n   *\n   * @param seen\n   * @param offline\n   * @returns {object}\n   */\n\n\n  toJSON(seen\n  /*: Array<any> | void*/\n  , offline\n  /*:: ?: boolean*/\n  )\n  /*: AttributeMap*/\n  {\n    const seenEntry = this.id ? this.className + ':' + this.id : this;\n    seen = seen || [seenEntry];\n    const json = {};\n    const attrs = this.attributes;\n\n    for (const attr in attrs) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && attrs[attr].toJSON) {\n        json[attr] = attrs[attr].toJSON();\n      } else {\n        json[attr] = (0, _encode.default)(attrs[attr], false, false, seen, offline);\n      }\n    }\n\n    const pending = this._getPendingOps();\n\n    for (const attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON(offline);\n    }\n\n    if (this.id) {\n      json.objectId = this.id;\n    }\n\n    return json;\n  }\n  /**\n   * Determines whether this ParseObject is equal to another ParseObject\n   *\n   * @param {object} other - An other object ot compare\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (this === other) {\n      return true;\n    }\n\n    return other instanceof ParseObject && this.className === other.className && this.id === other.id && typeof this.id !== 'undefined';\n  }\n  /**\n   * Returns true if this object has been modified since its last\n   * save/refresh.  If an attribute is specified, it returns true only if that\n   * particular attribute has been modified since the last save/refresh.\n   *\n   * @param {string} attr An attribute name (optional).\n   * @returns {boolean}\n   */\n\n\n  dirty(attr\n  /*:: ?: string*/\n  )\n  /*: boolean*/\n  {\n    if (!this.id) {\n      return true;\n    }\n\n    const pendingOps = this._getPendingOps();\n\n    const dirtyObjects = this._getDirtyObjectAttributes();\n\n    if (attr) {\n      if (dirtyObjects.hasOwnProperty(attr)) {\n        return true;\n      }\n\n      for (let i = 0; i < pendingOps.length; i++) {\n        if (pendingOps[i].hasOwnProperty(attr)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (Object.keys(pendingOps[0]).length !== 0) {\n      return true;\n    }\n\n    if (Object.keys(dirtyObjects).length !== 0) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Returns an array of keys that have been modified since last save/refresh\n   *\n   * @returns {string[]}\n   */\n\n\n  dirtyKeys()\n  /*: Array<string>*/\n  {\n    const pendingOps = this._getPendingOps();\n\n    const keys = {};\n\n    for (let i = 0; i < pendingOps.length; i++) {\n      for (const attr in pendingOps[i]) {\n        keys[attr] = true;\n      }\n    }\n\n    const dirtyObjects = this._getDirtyObjectAttributes();\n\n    for (const attr in dirtyObjects) {\n      keys[attr] = true;\n    }\n\n    return Object.keys(keys);\n  }\n  /**\n   * Returns true if the object has been fetched.\n   *\n   * @returns {boolean}\n   */\n\n\n  isDataAvailable()\n  /*: boolean*/\n  {\n    const serverData = this._getServerData();\n\n    return !!Object.keys(serverData).length;\n  }\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n\n\n  toPointer()\n  /*: Pointer*/\n  {\n    if (!this.id) {\n      throw new Error('Cannot create a pointer to an unsaved ParseObject');\n    }\n\n    return {\n      __type: 'Pointer',\n      className: this.className,\n      objectId: this.id\n    };\n  }\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n\n\n  toOfflinePointer()\n  /*: Pointer*/\n  {\n    if (!this._localId) {\n      throw new Error('Cannot create a offline pointer to a saved ParseObject');\n    }\n\n    return {\n      __type: 'Object',\n      className: this.className,\n      _localId: this._localId\n    };\n  }\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {*}\n   */\n\n\n  get(attr\n  /*: string*/\n  )\n  /*: mixed*/\n  {\n    return this.attributes[attr];\n  }\n  /**\n   * Gets a relation on the given class for the attribute.\n   *\n   * @param {string} attr The attribute to get the relation for.\n   * @returns {Parse.Relation}\n   */\n\n\n  relation(attr\n  /*: string*/\n  )\n  /*: ParseRelation*/\n  {\n    const value = this.get(attr);\n\n    if (value) {\n      if (!(value instanceof _ParseRelation.default)) {\n        throw new Error('Called relation() on non-relation field ' + attr);\n      }\n\n      value._ensureParentAndKey(this, attr);\n\n      return value;\n    }\n\n    return new _ParseRelation.default(this, attr);\n  }\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {string}\n   */\n\n\n  escape(attr\n  /*: string*/\n  )\n  /*: string*/\n  {\n    let val = this.attributes[attr];\n\n    if (val == null) {\n      return '';\n    }\n\n    if (typeof val !== 'string') {\n      if (typeof val.toString !== 'function') {\n        return '';\n      }\n\n      val = val.toString();\n    }\n\n    return (0, _escape.default)(val);\n  }\n  /**\n   * Returns <code>true</code> if the attribute contains a value that is not\n   * null or undefined.\n   *\n   * @param {string} attr The string name of the attribute.\n   * @returns {boolean}\n   */\n\n\n  has(attr\n  /*: string*/\n  )\n  /*: boolean*/\n  {\n    const attributes = this.attributes;\n\n    if (attributes.hasOwnProperty(attr)) {\n      return attributes[attr] != null;\n    }\n\n    return false;\n  }\n  /**\n   * Sets a hash of model attributes on the object.\n   *\n   * <p>You can call it with an object containing keys and values, with one\n   * key and value, or dot notation.  For example:<pre>\n   *   gameTurn.set({\n   *     player: player1,\n   *     diceRoll: 2\n   *   }, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"currentPlayer\", player2, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"finished\", true);</pre></p>\n   *\n   *   game.set(\"player.score\", 10);</pre></p>\n   *\n   * @param {(string|object)} key The key to set.\n   * @param {(string|object)} value The value to give it.\n   * @param {object} options A set of options for the set.\n   *     The only supported option is <code>error</code>.\n   * @returns {(ParseObject|boolean)} true if the set succeeded.\n   */\n\n\n  set(key\n  /*: mixed*/\n  , value\n  /*: mixed*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    let changes = {};\n    const newOps = {};\n\n    if (key && typeof key === 'object') {\n      changes = key;\n      options = value;\n    } else if (typeof key === 'string') {\n      changes[key] = value;\n    } else {\n      return this;\n    }\n\n    options = options || {};\n    let readonly = [];\n\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = readonly.concat(this.constructor.readOnlyAttributes());\n    }\n\n    for (const k in changes) {\n      if (k === 'createdAt' || k === 'updatedAt') {\n        // This property is read-only, but for legacy reasons we silently\n        // ignore it\n        continue;\n      }\n\n      if (readonly.indexOf(k) > -1) {\n        throw new Error('Cannot modify readonly attribute: ' + k);\n      }\n\n      if (options.unset) {\n        newOps[k] = new _ParseOp.UnsetOp();\n      } else if (changes[k] instanceof _ParseOp.Op) {\n        newOps[k] = changes[k];\n      } else if (changes[k] && typeof changes[k] === 'object' && typeof changes[k].__op === 'string') {\n        newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);\n      } else if (k === 'objectId' || k === 'id') {\n        if (typeof changes[k] === 'string') {\n          this.id = changes[k];\n        }\n      } else if (k === 'ACL' && typeof changes[k] === 'object' && !(changes[k] instanceof _ParseACL.default)) {\n        newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));\n      } else if (changes[k] instanceof _ParseRelation.default) {\n        const relation = new _ParseRelation.default(this, k);\n        relation.targetClassName = changes[k].targetClassName;\n        newOps[k] = new _ParseOp.SetOp(relation);\n      } else {\n        newOps[k] = new _ParseOp.SetOp(changes[k]);\n      }\n    }\n\n    const currentAttributes = this.attributes; // Calculate new values\n\n    const newValues = {};\n\n    for (const attr in newOps) {\n      if (newOps[attr] instanceof _ParseOp.RelationOp) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr], this, attr);\n      } else if (!(newOps[attr] instanceof _ParseOp.UnsetOp)) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr]);\n      }\n    } // Validate changes\n\n\n    if (!options.ignoreValidation) {\n      const validation = this.validate(newValues);\n\n      if (validation) {\n        if (typeof options.error === 'function') {\n          options.error(this, validation);\n        }\n\n        return false;\n      }\n    } // Consolidate Ops\n\n\n    const pendingOps = this._getPendingOps();\n\n    const last = pendingOps.length - 1;\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    for (const attr in newOps) {\n      const nextOp = newOps[attr].mergeWith(pendingOps[last][attr]);\n      stateController.setPendingOp(this._getStateIdentifier(), attr, nextOp);\n    }\n\n    return this;\n  }\n  /**\n   * Remove an attribute from the model. This is a noop if the attribute doesn't\n   * exist.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @param options\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  unset(attr\n  /*: string*/\n  , options\n  /*:: ?: { [opt: string]: mixed }*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    options = options || {};\n    options.unset = true;\n    return this.set(attr, null, options);\n  }\n  /**\n   * Atomically increments the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to increment by (optional).\n   * @returns {(ParseObject|boolean)}\n   */\n\n\n  increment(attr\n  /*: string*/\n  , amount\n  /*:: ?: number*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot increment by a non-numeric amount.');\n    }\n\n    return this.set(attr, new _ParseOp.IncrementOp(amount));\n  }\n  /**\n   * Atomically decrements the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to decrement by (optional).\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  decrement(attr\n  /*: string*/\n  , amount\n  /*:: ?: number*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot decrement by a non-numeric amount.');\n    }\n\n    return this.set(attr, new _ParseOp.IncrementOp(amount * -1));\n  }\n  /**\n   * Atomically add an object to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The item to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  add(attr\n  /*: string*/\n  , item\n  /*: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddOp([item]));\n  }\n  /**\n   * Atomically add the objects to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The items to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  addAll(attr\n  /*: string*/\n  , items\n  /*: Array<mixed>*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddOp(items));\n  }\n  /**\n   * Atomically add an object to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  addUnique(attr\n  /*: string*/\n  , item\n  /*: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddUniqueOp([item]));\n  }\n  /**\n   * Atomically add the objects to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The objects to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  addAllUnique(attr\n  /*: string*/\n  , items\n  /*: Array<mixed>*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddUniqueOp(items));\n  }\n  /**\n   * Atomically remove all instances of an object from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  remove(attr\n  /*: string*/\n  , item\n  /*: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.RemoveOp([item]));\n  }\n  /**\n   * Atomically remove all instances of the objects from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  removeAll(attr\n  /*: string*/\n  , items\n  /*: Array<mixed>*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.RemoveOp(items));\n  }\n  /**\n   * Returns an instance of a subclass of Parse.Op describing what kind of\n   * modification has been performed on this field since the last time it was\n   * saved. For example, after calling object.increment(\"x\"), calling\n   * object.op(\"x\") would return an instance of Parse.Op.Increment.\n   *\n   * @param attr {String} The key.\n   * @returns {Parse.Op} The operation, or undefined if none.\n   */\n\n\n  op(attr\n  /*: string*/\n  )\n  /*: ?Op*/\n  {\n    const pending = this._getPendingOps();\n\n    for (let i = pending.length; i--;) {\n      if (pending[i][attr]) {\n        return pending[i][attr];\n      }\n    }\n  }\n  /**\n   * Creates a new model with identical attributes to this one.\n   *\n   * @returns {Parse.Object}\n   */\n\n\n  clone()\n  /*: any*/\n  {\n    const clone = new this.constructor(this.className);\n    let attributes = this.attributes;\n\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      const readonly = this.constructor.readOnlyAttributes() || []; // Attributes are frozen, so we have to rebuild an object,\n      // rather than delete readonly keys\n\n      const copy = {};\n\n      for (const a in attributes) {\n        if (readonly.indexOf(a) < 0) {\n          copy[a] = attributes[a];\n        }\n      }\n\n      attributes = copy;\n    }\n\n    if (clone.set) {\n      clone.set(attributes);\n    }\n\n    return clone;\n  }\n  /**\n   * Creates a new instance of this object. Not to be confused with clone()\n   *\n   * @returns {Parse.Object}\n   */\n\n\n  newInstance()\n  /*: any*/\n  {\n    const clone = new this.constructor(this.className);\n    clone.id = this.id;\n\n    if (singleInstance) {\n      // Just return an object with the right id\n      return clone;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    if (stateController) {\n      stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());\n    }\n\n    return clone;\n  }\n  /**\n   * Returns true if this object has never been saved to Parse.\n   *\n   * @returns {boolean}\n   */\n\n\n  isNew()\n  /*: boolean*/\n  {\n    return !this.id;\n  }\n  /**\n   * Returns true if this object was created by the Parse server when the\n   * object might have already been there (e.g. in the case of a Facebook\n   * login)\n   *\n   * @returns {boolean}\n   */\n\n\n  existed()\n  /*: boolean*/\n  {\n    if (!this.id) {\n      return false;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const state = stateController.getState(this._getStateIdentifier());\n\n    if (state) {\n      return state.existed;\n    }\n\n    return false;\n  }\n  /**\n   * Returns true if this object exists on the Server\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object exists.\n   */\n\n\n  async exists(options\n  /*:: ?: RequestOptions*/\n  )\n  /*: Promise<boolean>*/\n  {\n    if (!this.id) {\n      return false;\n    }\n\n    try {\n      const query = new _ParseQuery.default(this.className);\n      await query.get(this.id, options);\n      return true;\n    } catch (e) {\n      if (e.code === _ParseError.default.OBJECT_NOT_FOUND) {\n        return false;\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Checks if the model is currently in a valid state.\n   *\n   * @returns {boolean}\n   */\n\n\n  isValid()\n  /*: boolean*/\n  {\n    return !this.validate(this.attributes);\n  }\n  /**\n   * You should not call this function directly unless you subclass\n   * <code>Parse.Object</code>, in which case you can override this method\n   * to provide additional validation on <code>set</code> and\n   * <code>save</code>.  Your implementation should return\n   *\n   * @param {object} attrs The current data to validate.\n   * @returns {Parse.Error|boolean} False if the data is valid.  An error object otherwise.\n   * @see Parse.Object#set\n   */\n\n\n  validate(attrs\n  /*: AttributeMap*/\n  )\n  /*: ParseError | boolean*/\n  {\n    if (attrs.hasOwnProperty('ACL') && !(attrs.ACL instanceof _ParseACL.default)) {\n      return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'ACL must be a Parse ACL.');\n    }\n\n    for (const key in attrs) {\n      if (!/^[A-Za-z][0-9A-Za-z_.]*$/.test(key)) {\n        return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Returns the ACL for this object.\n   *\n   * @returns {Parse.ACL} An instance of Parse.ACL.\n   * @see Parse.Object#get\n   */\n\n\n  getACL()\n  /*: ?ParseACL*/\n  {\n    const acl = this.get('ACL');\n\n    if (acl instanceof _ParseACL.default) {\n      return acl;\n    }\n\n    return null;\n  }\n  /**\n   * Sets the ACL to be used for this object.\n   *\n   * @param {Parse.ACL} acl An instance of Parse.ACL.\n   * @param {object} options\n   * @returns {(ParseObject | boolean)} Whether the set passed validation.\n   * @see Parse.Object#set\n   */\n\n\n  setACL(acl\n  /*: ParseACL*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set('ACL', acl, options);\n  }\n  /**\n   * Clears any (or specific) changes to this object made since the last call to save()\n   *\n   * @param {string} [keys] - specify which fields to revert\n   */\n\n\n  revert(...keys)\n  /*: void*/\n  {\n    let keysToRevert;\n\n    if (keys.length) {\n      keysToRevert = [];\n\n      for (const key of keys) {\n        if (typeof key === 'string') {\n          keysToRevert.push(key);\n        } else {\n          throw new Error('Parse.Object#revert expects either no, or a list of string, arguments.');\n        }\n      }\n    }\n\n    this._clearPendingOps(keysToRevert);\n  }\n  /**\n   * Clears all attributes on a model\n   *\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  clear()\n  /*: ParseObject | boolean*/\n  {\n    const attributes = this.attributes;\n    const erasable = {};\n    let readonly = ['createdAt', 'updatedAt'];\n\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = readonly.concat(this.constructor.readOnlyAttributes());\n    }\n\n    for (const attr in attributes) {\n      if (readonly.indexOf(attr) < 0) {\n        erasable[attr] = true;\n      }\n    }\n\n    return this.set(erasable, {\n      unset: true\n    });\n  }\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n\n\n  fetch(options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    options = options || {};\n    const fetchOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      fetchOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      fetchOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      fetchOptions.context = options.context;\n    }\n\n    if (options.hasOwnProperty('include')) {\n      fetchOptions.include = [];\n\n      if (Array.isArray(options.include)) {\n        options.include.forEach(key => {\n          if (Array.isArray(key)) {\n            fetchOptions.include = fetchOptions.include.concat(key);\n          } else {\n            fetchOptions.include.push(key);\n          }\n        });\n      } else {\n        fetchOptions.include.push(options.include);\n      }\n    }\n\n    const controller = _CoreManager.default.getObjectController();\n\n    return controller.fetch(this, true, fetchOptions);\n  }\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n\n\n  fetchWithInclude(keys\n  /*: String | Array<string | Array<string>>*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    options = options || {};\n    options.include = keys;\n    return this.fetch(options);\n  }\n  /**\n   * Saves this object to the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection, and don't need to know when the save completes.\n   * If there is some problem with the object such that it can't be saved, it will be silently discarded.\n   *\n   * Objects saved with this method will be stored locally in an on-disk cache until they can be delivered to Parse.\n   * They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection is\n   * available. Objects saved this way will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n\n\n  async saveEventually(options\n  /*: SaveOptions*/\n  )\n  /*: Promise*/\n  {\n    try {\n      await this.save(null, options);\n    } catch (e) {\n      if (e.message === 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n        await _EventuallyQueue.default.save(this, options);\n\n        _EventuallyQueue.default.poll();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Set a hash of model attributes, and save the model to the server.\n   * updatedAt will be updated when the request returns.\n   * You can either call it as:<pre>\n   * object.save();</pre>\n   * or<pre>\n   * object.save(attrs);</pre>\n   * or<pre>\n   * object.save(null, options);</pre>\n   * or<pre>\n   * object.save(attrs, options);</pre>\n   * or<pre>\n   * object.save(key, value);</pre>\n   * or<pre>\n   * object.save(key, value, options);</pre>\n   *\n   * Example 1: <pre>\n   * gameTurn.save({\n   * player: \"Jake Cutter\",\n   * diceRoll: 2\n   * }).then(function(gameTurnAgain) {\n   * // The save was successful.\n   * }, function(error) {\n   * // The save failed.  Error is an instance of Parse.Error.\n   * });</pre>\n   *\n   * Example 2: <pre>\n   * gameTurn.save(\"player\", \"Jake Cutter\");</pre>\n   *\n   * @param {string | object | null} [arg1]\n   * Valid options are:<ul>\n   * <li>`Object` - Key/value pairs to update on the object.</li>\n   * <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>\n   * <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>\n   * </ul>\n   * @param {string | object} [arg2]\n   * <ul>\n   * <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>\n   * <li>`Object` Options - Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * </li>\n   * </ul>\n   * @param {object} [arg3]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n\n\n  save(arg1\n  /*: ?string | { [attr: string]: mixed }*/\n  , arg2\n  /*: SaveOptions | mixed*/\n  , arg3\n  /*:: ?: SaveOptions*/\n  )\n  /*: Promise*/\n  {\n    let attrs;\n    let options;\n\n    if (typeof arg1 === 'object' || typeof arg1 === 'undefined') {\n      attrs = arg1;\n\n      if (typeof arg2 === 'object') {\n        options = arg2;\n      }\n    } else {\n      attrs = {};\n      attrs[arg1] = arg2;\n      options = arg3;\n    }\n\n    if (attrs) {\n      const validation = this.validate(attrs);\n\n      if (validation) {\n        return Promise.reject(validation);\n      }\n\n      this.set(attrs, options);\n    }\n\n    options = options || {};\n    const saveOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = !!options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken') && typeof options.sessionToken === 'string') {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('installationId') && typeof options.installationId === 'string') {\n      saveOptions.installationId = options.installationId;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n\n    const controller = _CoreManager.default.getObjectController();\n\n    const unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;\n    return controller.save(unsaved, saveOptions).then(() => {\n      return controller.save(this, saveOptions);\n    });\n  }\n  /**\n   * Deletes this object from the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection,\n   * and don't need to know when the delete completes. If there is some problem with the object\n   * such that it can't be deleted, the request will be silently discarded.\n   *\n   * Delete instructions made with this method will be stored locally in an on-disk cache until they can be transmitted\n   * to Parse. They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection\n   * is available. Delete requests will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n\n\n  async destroyEventually(options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    try {\n      await this.destroy(options);\n    } catch (e) {\n      if (e.message === 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n        await _EventuallyQueue.default.destroy(this, options);\n\n        _EventuallyQueue.default.poll();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Destroy this model on the server if it was already persisted.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n\n\n  destroy(options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    options = options || {};\n    const destroyOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n\n    if (!this.id) {\n      return Promise.resolve();\n    }\n\n    return _CoreManager.default.getObjectController().destroy(this, destroyOptions);\n  }\n  /**\n   * Asynchronously stores the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pin();\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n\n\n  pin()\n  /*: Promise<void>*/\n  {\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await object.unPin();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n\n\n  unPin()\n  /*: Promise<void>*/\n  {\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n  /**\n   * Asynchronously returns if the object is pinned\n   *\n   * <pre>\n   * const isPinned = await object.isPinned();\n   * </pre>\n   *\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.\n   */\n\n\n  async isPinned()\n  /*: Promise<boolean>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pin = await localDatastore.fromPinWithName(objectKey);\n    return pin.length > 0;\n  }\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pinWithName(name);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n\n\n  pinWithName(name\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    return ParseObject.pinAllWithName(name, [this]);\n  }\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore, recursively.\n   *\n   * <pre>\n   * await object.unPinWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n\n\n  unPinWithName(name\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    return ParseObject.unPinAllWithName(name, [this]);\n  }\n  /**\n   * Asynchronously loads data from the local datastore into this object.\n   *\n   * <pre>\n   * await object.fetchFromLocalDatastore();\n   * </pre>\n   *\n   * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>\n   * and then call <code>fetchFromLocalDatastore()</code> on it.\n   *\n   * @returns {Promise} A promise that is fulfilled when the fetch completes.\n   */\n\n\n  async fetchFromLocalDatastore()\n  /*: Promise<ParseObject>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      throw new Error('Parse.enableLocalDatastore() must be called first');\n    }\n\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pinned = await localDatastore._serializeObject(objectKey);\n\n    if (!pinned) {\n      throw new Error('Cannot fetch an unsaved ParseObject');\n    }\n\n    const result = ParseObject.fromJSON(pinned);\n\n    this._finishFetch(result.toJSON());\n\n    return this;\n  }\n  /** Static methods **/\n\n\n  static _clearAllState() {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.clearAllState();\n  }\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAll(list\n  /*: Array<ParseObject>*/\n  , options\n  /*: RequestOptions*/\n  = {}) {\n    const queryOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n\n    return _CoreManager.default.getObjectController().fetch(list, true, queryOptions);\n  }\n  /**\n   * Fetches the given list of Parse.Object.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAllWithInclude(list\n  /*: Array<ParseObject>*/\n  , keys\n  /*: String | Array<string | Array<string>>*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAll(list, options);\n  }\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeededWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAllIfNeededWithInclude(list\n  /*: Array<ParseObject>*/\n  , keys\n  /*: String | Array<string | Array<string>>*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAllIfNeeded(list, options);\n  }\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...])\n   *    .then((list) => {\n   *      // Objects were fetched and updated.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAllIfNeeded(list\n  /*: Array<ParseObject>*/\n  , options) {\n    options = options || {};\n    const queryOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n\n    return _CoreManager.default.getObjectController().fetch(list, false, queryOptions);\n  }\n\n  static handleIncludeOptions(options) {\n    let include = [];\n\n    if (Array.isArray(options.include)) {\n      options.include.forEach(key => {\n        if (Array.isArray(key)) {\n          include = include.concat(key);\n        } else {\n          include.push(key);\n        }\n      });\n    } else {\n      include.push(options.include);\n    }\n\n    return include;\n  }\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   * <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n   * array of other Parse.Error objects. Each error object in this array\n   * has an \"object\" property that references the object that could not be\n   * deleted (for instance, because that object could not be found).</li>\n   * <li>A non-aggregate Parse.Error. This indicates a serious error that\n   * caused the delete operation to be aborted partway through (for\n   * instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   * Parse.Object.destroyAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were deleted.\n   * }, (error) => {\n   * // An error occurred while deleting one or more of the objects.\n   * // If this is an aggregate error, then we can inspect each error\n   * // object individually to determine the reason why a particular\n   * // object was not deleted.\n   * if (error.code === Parse.Error.AGGREGATE_ERROR) {\n   * for (var i = 0; i < error.errors.length; i++) {\n   * console.log(\"Couldn't delete \" + error.errors[i].object.id +\n   * \"due to \" + error.errors[i].message);\n   * }\n   * } else {\n   * console.log(\"Delete aborted because of \" + error.message);\n   * }\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled when the destroyAll\n   * completes.\n   */\n\n\n  static destroyAll(list\n  /*: Array<ParseObject>*/\n  , options = {}) {\n    const destroyOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      destroyOptions.batchSize = options.batchSize;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n\n    return _CoreManager.default.getObjectController().destroy(list, destroyOptions);\n  }\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   * Parse.Object.saveAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were saved.\n   * }, (error) => {\n   * // An error occurred while saving one of the objects.\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static saveAll(list\n  /*: Array<ParseObject>*/\n  , options\n  /*: RequestOptions*/\n  = {}) {\n    const saveOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      saveOptions.batchSize = options.batchSize;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n\n    return _CoreManager.default.getObjectController().save(list, saveOptions);\n  }\n  /**\n   * Creates a reference to a subclass of Parse.Object with the given id. This\n   * does not exist on Parse.Object, only on subclasses.\n   *\n   * <p>A shortcut for: <pre>\n   *  var Foo = Parse.Object.extend(\"Foo\");\n   *  var pointerToFoo = new Foo();\n   *  pointerToFoo.id = \"myObjectId\";\n   * </pre>\n   *\n   * @param {string} id The ID of the object to create a reference to.\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference.\n   */\n\n\n  static createWithoutData(id\n  /*: string*/\n  ) {\n    const obj = new this();\n    obj.id = id;\n    return obj;\n  }\n  /**\n   * Creates a new instance of a Parse Object from a JSON representation.\n   *\n   * @param {object} json The JSON map of the Object's data\n   * @param {boolean} override In single instance mode, all old server data\n   *   is overwritten if this is set to true\n   * @param {boolean} dirty Whether the Parse.Object should set JSON keys to dirty\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference\n   */\n\n\n  static fromJSON(json\n  /*: any*/\n  , override\n  /*:: ?: boolean*/\n  , dirty\n  /*:: ?: boolean*/\n  ) {\n    if (!json.className) {\n      throw new Error('Cannot create an object without a className');\n    }\n\n    const constructor = classMap[json.className];\n    const o = constructor ? new constructor(json.className) : new ParseObject(json.className);\n    const otherAttributes = {};\n\n    for (const attr in json) {\n      if (attr !== 'className' && attr !== '__type') {\n        otherAttributes[attr] = json[attr];\n\n        if (dirty) {\n          o.set(attr, json[attr]);\n        }\n      }\n    }\n\n    if (override) {\n      // id needs to be set before clearServerData can work\n      if (otherAttributes.objectId) {\n        o.id = otherAttributes.objectId;\n      }\n\n      let preserved = null;\n\n      if (typeof o._preserveFieldsOnFetch === 'function') {\n        preserved = o._preserveFieldsOnFetch();\n      }\n\n      o._clearServerData();\n\n      if (preserved) {\n        o._finishFetch(preserved);\n      }\n    }\n\n    o._finishFetch(otherAttributes);\n\n    if (json.objectId) {\n      o._setExisted(true);\n    }\n\n    return o;\n  }\n  /**\n   * Registers a subclass of Parse.Object with a specific class name.\n   * When objects of that class are retrieved from a query, they will be\n   * instantiated with this subclass.\n   * This is only necessary when using ES6 subclassing.\n   *\n   * @param {string} className The class name of the subclass\n   * @param {Function} constructor The subclass\n   */\n\n\n  static registerSubclass(className\n  /*: string*/\n  , constructor\n  /*: any*/\n  ) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n\n    if (typeof constructor === 'undefined') {\n      throw new TypeError('You must supply a subclass constructor.');\n    }\n\n    if (typeof constructor !== 'function') {\n      throw new TypeError('You must register the subclass constructor. ' + 'Did you attempt to register an instance of the subclass?');\n    }\n\n    classMap[className] = constructor;\n\n    if (!constructor.className) {\n      constructor.className = className;\n    }\n  }\n  /**\n   * Unegisters a subclass of Parse.Object with a specific class name.\n   *\n   * @param {string} className The class name of the subclass\n   */\n\n\n  static unregisterSubclass(className\n  /*: string*/\n  ) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n\n    delete classMap[className];\n  }\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend(\"MyClass\", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: \"MyClass\",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {string} className The name of the Parse class backing this model.\n   * @param {object} protoProps Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {object} classProps Class properties to add the class returned from\n   *     this method.\n   * @returns {Parse.Object} A new subclass of Parse.Object.\n   */\n\n\n  static extend(className\n  /*: any*/\n  , protoProps\n  /*: any*/\n  , classProps\n  /*: any*/\n  ) {\n    if (typeof className !== 'string') {\n      if (className && typeof className.className === 'string') {\n        return ParseObject.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\"Parse.Object.extend's first argument should be the className.\");\n      }\n    }\n\n    let adjustedClassName = className;\n\n    if (adjustedClassName === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n      adjustedClassName = '_User';\n    }\n\n    let parentProto = ParseObject.prototype;\n\n    if (this.hasOwnProperty('__super__') && this.__super__) {\n      parentProto = this.prototype;\n    } else if (classMap[adjustedClassName]) {\n      parentProto = classMap[adjustedClassName].prototype;\n    }\n\n    const ParseObjectSubclass = function (attributes, options) {\n      this.className = adjustedClassName;\n      this._objCount = objectCount++; // Enable legacy initializers\n\n      if (typeof this.initialize === 'function') {\n        this.initialize.apply(this, arguments);\n      }\n\n      if (attributes && typeof attributes === 'object') {\n        if (!this.set(attributes || {}, options)) {\n          throw new Error(\"Can't create an invalid Parse Object\");\n        }\n      }\n    };\n\n    ParseObjectSubclass.className = adjustedClassName;\n    ParseObjectSubclass.__super__ = parentProto;\n    ParseObjectSubclass.prototype = Object.create(parentProto, {\n      constructor: {\n        value: ParseObjectSubclass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseObjectSubclass.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseObjectSubclass, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    ParseObjectSubclass.extend = function (name, protoProps, classProps) {\n      if (typeof name === 'string') {\n        return ParseObject.extend.call(ParseObjectSubclass, name, protoProps, classProps);\n      }\n\n      return ParseObject.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps);\n    };\n\n    ParseObjectSubclass.createWithoutData = ParseObject.createWithoutData;\n    classMap[adjustedClassName] = ParseObjectSubclass;\n    return ParseObjectSubclass;\n  }\n  /**\n   * Enable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * This is disabled by default in server environments, since it can lead to\n   * security issues.\n   *\n   * @static\n   */\n\n\n  static enableSingleInstance() {\n    singleInstance = true;\n\n    _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n  }\n  /**\n   * Disable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * When disabled, you can have two instances of the same object in memory\n   * without them sharing attributes.\n   *\n   * @static\n   */\n\n\n  static disableSingleInstance() {\n    singleInstance = false;\n\n    _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n  }\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAll([...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n\n\n  static pinAll(objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n\n\n  static pinAllWithName(name\n  /*: string*/\n  , objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore._handlePinAllWithName(name, objects);\n  }\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAll([...]);\n   * </pre>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAll(objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore, recursively.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAllWithName(name\n  /*: string*/\n  , objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore._handleUnPinAllWithName(name, objects);\n  }\n  /**\n   * Asynchronously removes all objects in the local datastore using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjects();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAllObjects()\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n  /**\n   * Asynchronously removes all objects with the specified pin name.\n   * Deletes the pin name also.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjectsWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAllObjectsWithName(name\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name);\n  }\n\n}\n\nconst DefaultController = {\n  fetch(target\n  /*: ParseObject | Array<ParseObject>*/\n  , forceFetch\n  /*: boolean*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<void> | ParseObject>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      const objs = [];\n      const ids = [];\n      let className = null;\n      const results = [];\n      let error = null;\n      target.forEach(el => {\n        if (error) {\n          return;\n        }\n\n        if (!className) {\n          className = el.className;\n        }\n\n        if (className !== el.className) {\n          error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, 'All objects should be of the same class');\n        }\n\n        if (!el.id) {\n          error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'All objects must have an ID');\n        }\n\n        if (forceFetch || !el.isDataAvailable()) {\n          ids.push(el.id);\n          objs.push(el);\n        }\n\n        results.push(el);\n      });\n\n      if (error) {\n        return Promise.reject(error);\n      }\n\n      const query = new _ParseQuery.default(className);\n      query.containedIn('objectId', ids);\n\n      if (options && options.include) {\n        query.include(options.include);\n      }\n\n      query._limit = ids.length;\n      return query.find(options).then(async objects => {\n        const idMap = {};\n        objects.forEach(o => {\n          idMap[o.id] = o;\n        });\n\n        for (let i = 0; i < objs.length; i++) {\n          const obj = objs[i];\n\n          if (!obj || !obj.id || !idMap[obj.id]) {\n            if (forceFetch) {\n              return Promise.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'All objects must exist on the server.'));\n            }\n          }\n        }\n\n        if (!singleInstance) {\n          // If single instance objects are disabled, we need to replace the\n          for (let i = 0; i < results.length; i++) {\n            const obj = results[i];\n\n            if (obj && obj.id && idMap[obj.id]) {\n              const id = obj.id;\n\n              obj._finishFetch(idMap[id].toJSON());\n\n              results[i] = idMap[id];\n            }\n          }\n        }\n\n        for (const object of results) {\n          await localDatastore._updateObjectIfPinned(object);\n        }\n\n        return Promise.resolve(results);\n      });\n    } else if (target instanceof ParseObject) {\n      if (!target.id) {\n        return Promise.reject(new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'Object does not have an ID'));\n      }\n\n      const RESTController = _CoreManager.default.getRESTController();\n\n      const params = {};\n\n      if (options && options.include) {\n        params.include = options.include.join();\n      }\n\n      return RESTController.request('GET', 'classes/' + target.className + '/' + target._getId(), params, options).then(async response => {\n        target._clearPendingOps();\n\n        target._clearServerData();\n\n        target._finishFetch(response);\n\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      });\n    }\n\n    return Promise.resolve();\n  },\n\n  async destroy(target\n  /*: ParseObject | Array<ParseObject>*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<void> | ParseObject>*/\n  {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      const batches = [[]];\n      target.forEach(obj => {\n        if (!obj.id) {\n          return;\n        }\n\n        batches[batches.length - 1].push(obj);\n\n        if (batches[batches.length - 1].length >= batchSize) {\n          batches.push([]);\n        }\n      });\n\n      if (batches[batches.length - 1].length === 0) {\n        // If the last batch is empty, remove it\n        batches.pop();\n      }\n\n      let deleteCompleted = Promise.resolve();\n      const errors = [];\n      batches.forEach(batch => {\n        deleteCompleted = deleteCompleted.then(() => {\n          return RESTController.request('POST', 'batch', {\n            requests: batch.map(obj => {\n              return {\n                method: 'DELETE',\n                path: getServerUrlPath() + 'classes/' + obj.className + '/' + obj._getId(),\n                body: {}\n              };\n            })\n          }, options).then(results => {\n            for (let i = 0; i < results.length; i++) {\n              if (results[i] && results[i].hasOwnProperty('error')) {\n                const err = new _ParseError.default(results[i].error.code, results[i].error.error);\n                err.object = batch[i];\n                errors.push(err);\n              }\n            }\n          });\n        });\n      });\n      return deleteCompleted.then(async () => {\n        if (errors.length) {\n          const aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);\n          aggregate.errors = errors;\n          return Promise.reject(aggregate);\n        }\n\n        for (const object of target) {\n          await localDatastore._destroyObjectIfPinned(object);\n        }\n\n        return Promise.resolve(target);\n      });\n    } else if (target instanceof ParseObject) {\n      return RESTController.request('DELETE', 'classes/' + target.className + '/' + target._getId(), {}, options).then(async () => {\n        await localDatastore._destroyObjectIfPinned(target);\n        return Promise.resolve(target);\n      });\n    }\n\n    return Promise.resolve(target);\n  },\n\n  save(target\n  /*: ParseObject | Array<ParseObject | ParseFile>*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const mapIdForPin = {};\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const allowCustomObjectId = _CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID');\n\n    options = options || {};\n    options.returnStatus = options.returnStatus || true;\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      let unsaved = target.concat();\n\n      for (let i = 0; i < target.length; i++) {\n        if (target[i] instanceof ParseObject) {\n          unsaved = unsaved.concat((0, _unsavedChildren.default)(target[i], true));\n        }\n      }\n\n      unsaved = (0, _unique.default)(unsaved);\n      const filesSaved\n      /*: Array<ParseFile>*/\n      = [];\n      let pending\n      /*: Array<ParseObject>*/\n      = [];\n      unsaved.forEach(el => {\n        if (el instanceof _ParseFile.default) {\n          filesSaved.push(el.save(options));\n        } else if (el instanceof ParseObject) {\n          if (allowCustomObjectId && !el.id) {\n            throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty, null or undefined');\n          }\n\n          pending.push(el);\n        }\n      });\n      return Promise.all(filesSaved).then(() => {\n        let objectError = null;\n        return (0, _promiseUtils.continueWhile)(() => {\n          return pending.length > 0;\n        }, () => {\n          const batch = [];\n          const nextPending = [];\n          pending.forEach(el => {\n            if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {\n              batch.push(el);\n            } else {\n              nextPending.push(el);\n            }\n          });\n          pending = nextPending;\n\n          if (batch.length < 1) {\n            return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));\n          } // Queue up tasks for each object in the batch.\n          // When every task is ready, the API request will execute\n\n\n          const batchReturned = new _promiseUtils.resolvingPromise();\n          const batchReady = [];\n          const batchTasks = [];\n          batch.forEach((obj, index) => {\n            const ready = new _promiseUtils.resolvingPromise();\n            batchReady.push(ready);\n            stateController.pushPendingState(obj._getStateIdentifier());\n            batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function () {\n              ready.resolve();\n              return batchReturned.then(responses => {\n                if (responses[index].hasOwnProperty('success')) {\n                  const objectId = responses[index].success.objectId;\n                  const status = responses[index]._status;\n                  delete responses[index]._status;\n                  mapIdForPin[objectId] = obj._localId;\n\n                  obj._handleSaveResponse(responses[index].success, status);\n                } else {\n                  if (!objectError && responses[index].hasOwnProperty('error')) {\n                    const serverError = responses[index].error;\n                    objectError = new _ParseError.default(serverError.code, serverError.error); // Cancel the rest of the save\n\n                    pending = [];\n                  }\n\n                  obj._handleSaveError();\n                }\n              });\n            }));\n          });\n          (0, _promiseUtils.when)(batchReady).then(() => {\n            // Kick off the batch request\n            return RESTController.request('POST', 'batch', {\n              requests: batch.map(obj => {\n                const params = obj._getSaveParams();\n\n                params.path = getServerUrlPath() + params.path;\n                return params;\n              })\n            }, options);\n          }).then(batchReturned.resolve, error => {\n            batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));\n          });\n          return (0, _promiseUtils.when)(batchTasks);\n        }).then(async () => {\n          if (objectError) {\n            return Promise.reject(objectError);\n          }\n\n          for (const object of target) {\n            await localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);\n            await localDatastore._updateObjectIfPinned(object);\n          }\n\n          return Promise.resolve(target);\n        });\n      });\n    } else if (target instanceof ParseObject) {\n      if (allowCustomObjectId && !target.id) {\n        throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty, null or undefined');\n      } // generate _localId in case if cascadeSave=false\n\n\n      target._getId();\n\n      const localId = target._localId; // copying target lets Flow guarantee the pointer isn't modified elsewhere\n\n      const targetCopy = target;\n\n      const task = function () {\n        const params = targetCopy._getSaveParams();\n\n        return RESTController.request(params.method, params.path, params.body, options).then(response => {\n          const status = response._status;\n          delete response._status;\n\n          targetCopy._handleSaveResponse(response, status);\n        }, error => {\n          targetCopy._handleSaveError();\n\n          return Promise.reject(error);\n        });\n      };\n\n      stateController.pushPendingState(target._getStateIdentifier());\n      return stateController.enqueueTask(target._getStateIdentifier(), task).then(async () => {\n        await localDatastore._updateLocalIdForObject(localId, target);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      }, error => {\n        return Promise.reject(error);\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n};\n\n_CoreManager.default.setObjectController(DefaultController);\n\nvar _default = ParseObject;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseObject.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_canBeSerialized","_decode","_encode","_escape","_EventuallyQueue","_ParseACL","_parseDate","_ParseError","_ParseFile","_promiseUtils","_LocalDatastoreUtils","_ParseOp","_ParseQuery","_ParseRelation","SingleInstanceStateController","_interopRequireWildcard","_unique","UniqueInstanceStateController","_unsavedChildren","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","uuidv4","classMap","objectCount","singleInstance","setObjectStateController","getServerUrlPath","serverUrl","url","replace","substr","indexOf","ParseObject","constructor","className","attributes","options","initialize","toSet","_objCount","attr","Error","stateController","getObjectStateController","freeze","estimateAttributes","_getStateIdentifier","createdAt","_getServerData","updatedAt","_getId","id","_localId","localId","getServerData","_clearServerData","serverData","unset","undefined","setServerData","_getPendingOps","getPendingOps","_clearPendingOps","keysToClear","pending","latest","_getDirtyObjectAttributes","objectCache","getObjectCache","dirty","val","json","stringified","JSON","stringify","e","_toFullJSON","seen","offline","toJSON","__type","_getSaveJSON","dirtyObjects","isDotNotation","field","includes","fieldName","split","SetOp","_getSaveParams","method","body","path","objectId","_finishFetch","initializeState","decoded","_ensureParentAndKey","commitServerChanges","_setExisted","existed","state","getState","_migrateId","serverId","oldState","removeState","_handleSaveResponse","response","status","changes","popPendingState","RelationOp","applyTo","getPrototypeOf","UnsetOp","_handleSaveError","mergeFirstPendingState","_getClassMap","seenEntry","attrs","equals","other","pendingOps","dirtyKeys","isDataAvailable","toPointer","toOfflinePointer","relation","escape","toString","newOps","readonly","readOnlyAttributes","concat","k","Op","__op","opFromJSON","targetClassName","currentAttributes","newValues","ignoreValidation","validation","validate","error","last","nextOp","mergeWith","setPendingOp","increment","amount","IncrementOp","decrement","add","item","AddOp","addAll","items","addUnique","AddUniqueOp","addAllUnique","remove","RemoveOp","removeAll","op","clone","copy","a","newInstance","duplicateState","isNew","exists","query","code","OBJECT_NOT_FOUND","isValid","ACL","OTHER_CAUSE","test","INVALID_KEY_NAME","getACL","acl","setACL","revert","keysToRevert","clear","erasable","fetch","fetchOptions","useMasterKey","sessionToken","context","include","Array","isArray","controller","getObjectController","fetchWithInclude","saveEventually","save","message","poll","arg1","arg2","arg3","Promise","reject","saveOptions","installationId","unsaved","cascadeSave","then","destroyEventually","destroy","destroyOptions","resolve","pin","pinAllWithName","DEFAULT_PIN","unPin","unPinAllWithName","isPinned","localDatastore","getLocalDatastore","isEnabled","objectKey","getKeyForObject","fromPinWithName","pinWithName","name","unPinWithName","fetchFromLocalDatastore","pinned","_serializeObject","result","fromJSON","_clearAllState","clearAllState","fetchAll","list","queryOptions","handleIncludeOptions","fetchAllWithInclude","fetchAllIfNeededWithInclude","fetchAllIfNeeded","destroyAll","batchSize","saveAll","createWithoutData","override","o","otherAttributes","preserved","_preserveFieldsOnFetch","registerSubclass","TypeError","unregisterSubclass","extend","protoProps","classProps","adjustedClassName","parentProto","__super__","ParseObjectSubclass","create","prop","enableSingleInstance","disableSingleInstance","pinAll","objects","_handlePinAllWithName","unPinAll","_handleUnPinAllWithName","unPinAllObjects","unPinAllObjectsWithName","PIN_PREFIX","DefaultController","forceFetch","objs","ids","results","el","INVALID_CLASS_NAME","MISSING_OBJECT_ID","containedIn","_limit","find","idMap","_updateObjectIfPinned","RESTController","getRESTController","params","join","request","batches","pop","deleteCompleted","errors","batch","requests","map","err","aggregate","AGGREGATE_ERROR","_destroyObjectIfPinned","mapIdForPin","allowCustomObjectId","returnStatus","filesSaved","all","objectError","continueWhile","nextPending","batchReturned","resolvingPromise","batchReady","batchTasks","index","ready","pushPendingState","enqueueTask","responses","success","_status","serverError","when","INCORRECT_TYPE","_updateLocalIdForObject","targetCopy","task","setObjectController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _canBeSerialized = _interopRequireDefault(require(\"./canBeSerialized\"));\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _escape = _interopRequireDefault(require(\"./escape\"));\n\nvar _EventuallyQueue = _interopRequireDefault(require(\"./EventuallyQueue\"));\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _parseDate = _interopRequireDefault(require(\"./parseDate\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nvar SingleInstanceStateController = _interopRequireWildcard(require(\"./SingleInstanceStateController\"));\n\nvar _unique = _interopRequireDefault(require(\"./unique\"));\n\nvar UniqueInstanceStateController = _interopRequireWildcard(require(\"./UniqueInstanceStateController\"));\n\nvar _unsavedChildren = _interopRequireDefault(require(\"./unsavedChildren\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst uuidv4 = require('./uuid');\n/*:: export type Pointer = {\n  __type: string,\n  className: string,\n  objectId: string,\n};*/\n\n/*:: type SaveParams = {\n  method: string,\n  path: string,\n  body: AttributeMap,\n};*/\n\n/*:: export type SaveOptions = FullOptions & {\n  cascadeSave?: boolean,\n  context?: AttributeMap,\n};*/\n// Mapping of class names to constructors, so we can populate objects from the\n// server with appropriate subclasses of ParseObject\n\n\nconst classMap = {}; // Global counter for generating unique Ids for non-single-instance objects\n\nlet objectCount = 0; // On web clients, objects are single-instance: any two objects with the same Id\n// will have the same attributes. However, this may be dangerous default\n// behavior in a server scenario\n\nlet singleInstance = !_CoreManager.default.get('IS_NODE');\n\nif (singleInstance) {\n  _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n} else {\n  _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n}\n\nfunction getServerUrlPath() {\n  let serverUrl = _CoreManager.default.get('SERVER_URL');\n\n  if (serverUrl[serverUrl.length - 1] !== '/') {\n    serverUrl += '/';\n  }\n\n  const url = serverUrl.replace(/https?:\\/\\//, '');\n  return url.substr(url.indexOf('/'));\n}\n/**\n * Creates a new model with defined attributes.\n *\n * <p>You won't normally call this method directly.  It is recommended that\n * you use a subclass of <code>Parse.Object</code> instead, created by calling\n * <code>extend</code>.</p>\n *\n * <p>However, if you don't want to use a subclass, or aren't sure which\n * subclass is appropriate, you can use this form:<pre>\n *     var object = new Parse.Object(\"ClassName\");\n * </pre>\n * That is basically equivalent to:<pre>\n *     var MyClass = Parse.Object.extend(\"ClassName\");\n *     var object = new MyClass();\n * </pre></p>\n *\n * @alias Parse.Object\n */\n\n\nclass ParseObject {\n  /**\n   * @param {string} className The class name for the object\n   * @param {object} attributes The initial set of data to store in the object.\n   * @param {object} options The options for this object instance.\n   */\n  constructor(className\n  /*: ?string | { className: string, [attr: string]: mixed }*/\n  , attributes\n  /*:: ?: { [attr: string]: mixed }*/\n  , options\n  /*:: ?: { ignoreValidation: boolean }*/\n  ) {\n    // Enable legacy initializers\n    if (typeof this.initialize === 'function') {\n      this.initialize.apply(this, arguments);\n    }\n\n    let toSet = null;\n    this._objCount = objectCount++;\n\n    if (typeof className === 'string') {\n      this.className = className;\n\n      if (attributes && typeof attributes === 'object') {\n        toSet = attributes;\n      }\n    } else if (className && typeof className === 'object') {\n      this.className = className.className;\n      toSet = {};\n\n      for (const attr in className) {\n        if (attr !== 'className') {\n          toSet[attr] = className[attr];\n        }\n      }\n\n      if (attributes && typeof attributes === 'object') {\n        options = attributes;\n      }\n    }\n\n    if (toSet && !this.set(toSet, options)) {\n      throw new Error(\"Can't create an invalid Parse Object\");\n    }\n  }\n  /**\n   * The ID of this object, unique within its class.\n   *\n   * @property {string} id\n   */\n\n  /*:: id: ?string;*/\n\n  /*:: _localId: ?string;*/\n\n  /*:: _objCount: number;*/\n\n  /*:: className: string;*/\n\n  /** Prototype getters / setters **/\n\n\n  get attributes()\n  /*: AttributeMap*/\n  {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    return Object.freeze(stateController.estimateAttributes(this._getStateIdentifier()));\n  }\n  /**\n   * The first time this object was saved on the server.\n   *\n   * @property {Date} createdAt\n   * @returns {Date}\n   */\n\n\n  get createdAt()\n  /*: ?Date*/\n  {\n    return this._getServerData().createdAt;\n  }\n  /**\n   * The last time this object was updated on the server.\n   *\n   * @property {Date} updatedAt\n   * @returns {Date}\n   */\n\n\n  get updatedAt()\n  /*: ?Date*/\n  {\n    return this._getServerData().updatedAt;\n  }\n  /** Private methods **/\n\n  /**\n   * Returns a local or server Id used uniquely identify this object\n   *\n   * @returns {string}\n   */\n\n\n  _getId()\n  /*: string*/\n  {\n    if (typeof this.id === 'string') {\n      return this.id;\n    }\n\n    if (typeof this._localId === 'string') {\n      return this._localId;\n    }\n\n    const localId = 'local' + uuidv4();\n    this._localId = localId;\n    return localId;\n  }\n  /**\n   * Returns a unique identifier used to pull data from the State Controller.\n   *\n   * @returns {Parse.Object|object}\n   */\n\n\n  _getStateIdentifier()\n  /*: ParseObject | { id: string, className: string }*/\n  {\n    if (singleInstance) {\n      let id = this.id;\n\n      if (!id) {\n        id = this._getId();\n      }\n\n      return {\n        id: id,\n        className: this.className\n      };\n    } else {\n      return this;\n    }\n  }\n\n  _getServerData()\n  /*: AttributeMap*/\n  {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    return stateController.getServerData(this._getStateIdentifier());\n  }\n\n  _clearServerData() {\n    const serverData = this._getServerData();\n\n    const unset = {};\n\n    for (const attr in serverData) {\n      unset[attr] = undefined;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.setServerData(this._getStateIdentifier(), unset);\n  }\n\n  _getPendingOps()\n  /*: Array<OpsMap>*/\n  {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    return stateController.getPendingOps(this._getStateIdentifier());\n  }\n  /**\n   * @param {Array<string>} [keysToClear] - if specified, only ops matching\n   * these fields will be cleared\n   */\n\n\n  _clearPendingOps(keysToClear\n  /*:: ?: Array<string>*/\n  ) {\n    const pending = this._getPendingOps();\n\n    const latest = pending[pending.length - 1];\n    const keys = keysToClear || Object.keys(latest);\n    keys.forEach(key => {\n      delete latest[key];\n    });\n  }\n\n  _getDirtyObjectAttributes()\n  /*: AttributeMap*/\n  {\n    const attributes = this.attributes;\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const objectCache = stateController.getObjectCache(this._getStateIdentifier());\n    const dirty = {};\n\n    for (const attr in attributes) {\n      const val = attributes[attr];\n\n      if (val && typeof val === 'object' && !(val instanceof ParseObject) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n        // Due to the way browsers construct maps, the key order will not change\n        // unless the object is changed\n        try {\n          const json = (0, _encode.default)(val, false, true);\n          const stringified = JSON.stringify(json);\n\n          if (objectCache[attr] !== stringified) {\n            dirty[attr] = val;\n          }\n        } catch (e) {\n          // Error occurred, possibly by a nested unsaved pointer in a mutable container\n          // No matter how it happened, it indicates a change in the attribute\n          dirty[attr] = val;\n        }\n      }\n    }\n\n    return dirty;\n  }\n\n  _toFullJSON(seen\n  /*:: ?: Array<any>*/\n  , offline\n  /*:: ?: boolean*/\n  )\n  /*: AttributeMap*/\n  {\n    const json\n    /*: { [key: string]: mixed }*/\n    = this.toJSON(seen, offline);\n    json.__type = 'Object';\n    json.className = this.className;\n    return json;\n  }\n\n  _getSaveJSON()\n  /*: AttributeMap*/\n  {\n    const pending = this._getPendingOps();\n\n    const dirtyObjects = this._getDirtyObjectAttributes();\n\n    const json = {};\n\n    for (var attr in dirtyObjects) {\n      let isDotNotation = false;\n\n      for (let i = 0; i < pending.length; i += 1) {\n        for (const field in pending[i]) {\n          // Dot notation operations are handled later\n          if (field.includes('.')) {\n            const fieldName = field.split('.')[0];\n\n            if (fieldName === attr) {\n              isDotNotation = true;\n              break;\n            }\n          }\n        }\n      }\n\n      if (!isDotNotation) {\n        json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();\n      }\n    }\n\n    for (attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON();\n    }\n\n    return json;\n  }\n\n  _getSaveParams()\n  /*: SaveParams*/\n  {\n    let method = this.id ? 'PUT' : 'POST';\n\n    const body = this._getSaveJSON();\n\n    let path = 'classes/' + this.className;\n\n    if (_CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID')) {\n      if (!this.createdAt) {\n        method = 'POST';\n        body.objectId = this.id;\n      } else {\n        method = 'PUT';\n        path += '/' + this.id;\n      }\n    } else if (this.id) {\n      path += '/' + this.id;\n    } else if (this.className === '_User') {\n      path = 'users';\n    }\n\n    return {\n      method,\n      body,\n      path\n    };\n  }\n\n  _finishFetch(serverData\n  /*: AttributeMap*/\n  ) {\n    if (!this.id && serverData.objectId) {\n      this.id = serverData.objectId;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.initializeState(this._getStateIdentifier());\n    const decoded = {};\n\n    for (const attr in serverData) {\n      if (attr === 'ACL') {\n        decoded[attr] = new _ParseACL.default(serverData[attr]);\n      } else if (attr !== 'objectId') {\n        decoded[attr] = (0, _decode.default)(serverData[attr]);\n\n        if (decoded[attr] instanceof _ParseRelation.default) {\n          decoded[attr]._ensureParentAndKey(this, attr);\n        }\n      }\n    }\n\n    if (decoded.createdAt && typeof decoded.createdAt === 'string') {\n      decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);\n    }\n\n    if (decoded.updatedAt && typeof decoded.updatedAt === 'string') {\n      decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);\n    }\n\n    if (!decoded.updatedAt && decoded.createdAt) {\n      decoded.updatedAt = decoded.createdAt;\n    }\n\n    stateController.commitServerChanges(this._getStateIdentifier(), decoded);\n  }\n\n  _setExisted(existed\n  /*: boolean*/\n  ) {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const state = stateController.getState(this._getStateIdentifier());\n\n    if (state) {\n      state.existed = existed;\n    }\n  }\n\n  _migrateId(serverId\n  /*: string*/\n  ) {\n    if (this._localId && serverId) {\n      if (singleInstance) {\n        const stateController = _CoreManager.default.getObjectStateController();\n\n        const oldState = stateController.removeState(this._getStateIdentifier());\n        this.id = serverId;\n        delete this._localId;\n\n        if (oldState) {\n          stateController.initializeState(this._getStateIdentifier(), oldState);\n        }\n      } else {\n        this.id = serverId;\n        delete this._localId;\n      }\n    }\n  }\n\n  _handleSaveResponse(response\n  /*: AttributeMap*/\n  , status\n  /*: number*/\n  ) {\n    const changes = {};\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const pending = stateController.popPendingState(this._getStateIdentifier());\n\n    for (var attr in pending) {\n      if (pending[attr] instanceof _ParseOp.RelationOp) {\n        changes[attr] = pending[attr].applyTo(undefined, this, attr);\n      } else if (!(attr in response)) {\n        // Only SetOps and UnsetOps should not come back with results\n        changes[attr] = pending[attr].applyTo(undefined);\n      }\n    }\n\n    for (attr in response) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && typeof response[attr] === 'string') {\n        changes[attr] = (0, _parseDate.default)(response[attr]);\n      } else if (attr === 'ACL') {\n        changes[attr] = new _ParseACL.default(response[attr]);\n      } else if (attr !== 'objectId') {\n        const val = (0, _decode.default)(response[attr]);\n\n        if (val && Object.getPrototypeOf(val) === Object.prototype) {\n          changes[attr] = _objectSpread(_objectSpread({}, this.attributes[attr]), val);\n        } else {\n          changes[attr] = val;\n        }\n\n        if (changes[attr] instanceof _ParseOp.UnsetOp) {\n          changes[attr] = undefined;\n        }\n      }\n    }\n\n    if (changes.createdAt && !changes.updatedAt) {\n      changes.updatedAt = changes.createdAt;\n    }\n\n    this._migrateId(response.objectId);\n\n    if (status !== 201) {\n      this._setExisted(true);\n    }\n\n    stateController.commitServerChanges(this._getStateIdentifier(), changes);\n  }\n\n  _handleSaveError() {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.mergeFirstPendingState(this._getStateIdentifier());\n  }\n\n  static _getClassMap() {\n    return classMap;\n  }\n  /** Public methods **/\n\n\n  initialize() {// NOOP\n  }\n  /**\n   * Returns a JSON version of the object suitable for saving to Parse.\n   *\n   * @param seen\n   * @param offline\n   * @returns {object}\n   */\n\n\n  toJSON(seen\n  /*: Array<any> | void*/\n  , offline\n  /*:: ?: boolean*/\n  )\n  /*: AttributeMap*/\n  {\n    const seenEntry = this.id ? this.className + ':' + this.id : this;\n    seen = seen || [seenEntry];\n    const json = {};\n    const attrs = this.attributes;\n\n    for (const attr in attrs) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && attrs[attr].toJSON) {\n        json[attr] = attrs[attr].toJSON();\n      } else {\n        json[attr] = (0, _encode.default)(attrs[attr], false, false, seen, offline);\n      }\n    }\n\n    const pending = this._getPendingOps();\n\n    for (const attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON(offline);\n    }\n\n    if (this.id) {\n      json.objectId = this.id;\n    }\n\n    return json;\n  }\n  /**\n   * Determines whether this ParseObject is equal to another ParseObject\n   *\n   * @param {object} other - An other object ot compare\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (this === other) {\n      return true;\n    }\n\n    return other instanceof ParseObject && this.className === other.className && this.id === other.id && typeof this.id !== 'undefined';\n  }\n  /**\n   * Returns true if this object has been modified since its last\n   * save/refresh.  If an attribute is specified, it returns true only if that\n   * particular attribute has been modified since the last save/refresh.\n   *\n   * @param {string} attr An attribute name (optional).\n   * @returns {boolean}\n   */\n\n\n  dirty(attr\n  /*:: ?: string*/\n  )\n  /*: boolean*/\n  {\n    if (!this.id) {\n      return true;\n    }\n\n    const pendingOps = this._getPendingOps();\n\n    const dirtyObjects = this._getDirtyObjectAttributes();\n\n    if (attr) {\n      if (dirtyObjects.hasOwnProperty(attr)) {\n        return true;\n      }\n\n      for (let i = 0; i < pendingOps.length; i++) {\n        if (pendingOps[i].hasOwnProperty(attr)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (Object.keys(pendingOps[0]).length !== 0) {\n      return true;\n    }\n\n    if (Object.keys(dirtyObjects).length !== 0) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Returns an array of keys that have been modified since last save/refresh\n   *\n   * @returns {string[]}\n   */\n\n\n  dirtyKeys()\n  /*: Array<string>*/\n  {\n    const pendingOps = this._getPendingOps();\n\n    const keys = {};\n\n    for (let i = 0; i < pendingOps.length; i++) {\n      for (const attr in pendingOps[i]) {\n        keys[attr] = true;\n      }\n    }\n\n    const dirtyObjects = this._getDirtyObjectAttributes();\n\n    for (const attr in dirtyObjects) {\n      keys[attr] = true;\n    }\n\n    return Object.keys(keys);\n  }\n  /**\n   * Returns true if the object has been fetched.\n   *\n   * @returns {boolean}\n   */\n\n\n  isDataAvailable()\n  /*: boolean*/\n  {\n    const serverData = this._getServerData();\n\n    return !!Object.keys(serverData).length;\n  }\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n\n\n  toPointer()\n  /*: Pointer*/\n  {\n    if (!this.id) {\n      throw new Error('Cannot create a pointer to an unsaved ParseObject');\n    }\n\n    return {\n      __type: 'Pointer',\n      className: this.className,\n      objectId: this.id\n    };\n  }\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n\n\n  toOfflinePointer()\n  /*: Pointer*/\n  {\n    if (!this._localId) {\n      throw new Error('Cannot create a offline pointer to a saved ParseObject');\n    }\n\n    return {\n      __type: 'Object',\n      className: this.className,\n      _localId: this._localId\n    };\n  }\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {*}\n   */\n\n\n  get(attr\n  /*: string*/\n  )\n  /*: mixed*/\n  {\n    return this.attributes[attr];\n  }\n  /**\n   * Gets a relation on the given class for the attribute.\n   *\n   * @param {string} attr The attribute to get the relation for.\n   * @returns {Parse.Relation}\n   */\n\n\n  relation(attr\n  /*: string*/\n  )\n  /*: ParseRelation*/\n  {\n    const value = this.get(attr);\n\n    if (value) {\n      if (!(value instanceof _ParseRelation.default)) {\n        throw new Error('Called relation() on non-relation field ' + attr);\n      }\n\n      value._ensureParentAndKey(this, attr);\n\n      return value;\n    }\n\n    return new _ParseRelation.default(this, attr);\n  }\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {string}\n   */\n\n\n  escape(attr\n  /*: string*/\n  )\n  /*: string*/\n  {\n    let val = this.attributes[attr];\n\n    if (val == null) {\n      return '';\n    }\n\n    if (typeof val !== 'string') {\n      if (typeof val.toString !== 'function') {\n        return '';\n      }\n\n      val = val.toString();\n    }\n\n    return (0, _escape.default)(val);\n  }\n  /**\n   * Returns <code>true</code> if the attribute contains a value that is not\n   * null or undefined.\n   *\n   * @param {string} attr The string name of the attribute.\n   * @returns {boolean}\n   */\n\n\n  has(attr\n  /*: string*/\n  )\n  /*: boolean*/\n  {\n    const attributes = this.attributes;\n\n    if (attributes.hasOwnProperty(attr)) {\n      return attributes[attr] != null;\n    }\n\n    return false;\n  }\n  /**\n   * Sets a hash of model attributes on the object.\n   *\n   * <p>You can call it with an object containing keys and values, with one\n   * key and value, or dot notation.  For example:<pre>\n   *   gameTurn.set({\n   *     player: player1,\n   *     diceRoll: 2\n   *   }, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"currentPlayer\", player2, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"finished\", true);</pre></p>\n   *\n   *   game.set(\"player.score\", 10);</pre></p>\n   *\n   * @param {(string|object)} key The key to set.\n   * @param {(string|object)} value The value to give it.\n   * @param {object} options A set of options for the set.\n   *     The only supported option is <code>error</code>.\n   * @returns {(ParseObject|boolean)} true if the set succeeded.\n   */\n\n\n  set(key\n  /*: mixed*/\n  , value\n  /*: mixed*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    let changes = {};\n    const newOps = {};\n\n    if (key && typeof key === 'object') {\n      changes = key;\n      options = value;\n    } else if (typeof key === 'string') {\n      changes[key] = value;\n    } else {\n      return this;\n    }\n\n    options = options || {};\n    let readonly = [];\n\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = readonly.concat(this.constructor.readOnlyAttributes());\n    }\n\n    for (const k in changes) {\n      if (k === 'createdAt' || k === 'updatedAt') {\n        // This property is read-only, but for legacy reasons we silently\n        // ignore it\n        continue;\n      }\n\n      if (readonly.indexOf(k) > -1) {\n        throw new Error('Cannot modify readonly attribute: ' + k);\n      }\n\n      if (options.unset) {\n        newOps[k] = new _ParseOp.UnsetOp();\n      } else if (changes[k] instanceof _ParseOp.Op) {\n        newOps[k] = changes[k];\n      } else if (changes[k] && typeof changes[k] === 'object' && typeof changes[k].__op === 'string') {\n        newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);\n      } else if (k === 'objectId' || k === 'id') {\n        if (typeof changes[k] === 'string') {\n          this.id = changes[k];\n        }\n      } else if (k === 'ACL' && typeof changes[k] === 'object' && !(changes[k] instanceof _ParseACL.default)) {\n        newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));\n      } else if (changes[k] instanceof _ParseRelation.default) {\n        const relation = new _ParseRelation.default(this, k);\n        relation.targetClassName = changes[k].targetClassName;\n        newOps[k] = new _ParseOp.SetOp(relation);\n      } else {\n        newOps[k] = new _ParseOp.SetOp(changes[k]);\n      }\n    }\n\n    const currentAttributes = this.attributes; // Calculate new values\n\n    const newValues = {};\n\n    for (const attr in newOps) {\n      if (newOps[attr] instanceof _ParseOp.RelationOp) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr], this, attr);\n      } else if (!(newOps[attr] instanceof _ParseOp.UnsetOp)) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr]);\n      }\n    } // Validate changes\n\n\n    if (!options.ignoreValidation) {\n      const validation = this.validate(newValues);\n\n      if (validation) {\n        if (typeof options.error === 'function') {\n          options.error(this, validation);\n        }\n\n        return false;\n      }\n    } // Consolidate Ops\n\n\n    const pendingOps = this._getPendingOps();\n\n    const last = pendingOps.length - 1;\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    for (const attr in newOps) {\n      const nextOp = newOps[attr].mergeWith(pendingOps[last][attr]);\n      stateController.setPendingOp(this._getStateIdentifier(), attr, nextOp);\n    }\n\n    return this;\n  }\n  /**\n   * Remove an attribute from the model. This is a noop if the attribute doesn't\n   * exist.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @param options\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  unset(attr\n  /*: string*/\n  , options\n  /*:: ?: { [opt: string]: mixed }*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    options = options || {};\n    options.unset = true;\n    return this.set(attr, null, options);\n  }\n  /**\n   * Atomically increments the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to increment by (optional).\n   * @returns {(ParseObject|boolean)}\n   */\n\n\n  increment(attr\n  /*: string*/\n  , amount\n  /*:: ?: number*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot increment by a non-numeric amount.');\n    }\n\n    return this.set(attr, new _ParseOp.IncrementOp(amount));\n  }\n  /**\n   * Atomically decrements the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to decrement by (optional).\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  decrement(attr\n  /*: string*/\n  , amount\n  /*:: ?: number*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot decrement by a non-numeric amount.');\n    }\n\n    return this.set(attr, new _ParseOp.IncrementOp(amount * -1));\n  }\n  /**\n   * Atomically add an object to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The item to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  add(attr\n  /*: string*/\n  , item\n  /*: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddOp([item]));\n  }\n  /**\n   * Atomically add the objects to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The items to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  addAll(attr\n  /*: string*/\n  , items\n  /*: Array<mixed>*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddOp(items));\n  }\n  /**\n   * Atomically add an object to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  addUnique(attr\n  /*: string*/\n  , item\n  /*: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddUniqueOp([item]));\n  }\n  /**\n   * Atomically add the objects to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The objects to add.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  addAllUnique(attr\n  /*: string*/\n  , items\n  /*: Array<mixed>*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.AddUniqueOp(items));\n  }\n  /**\n   * Atomically remove all instances of an object from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  remove(attr\n  /*: string*/\n  , item\n  /*: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.RemoveOp([item]));\n  }\n  /**\n   * Atomically remove all instances of the objects from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  removeAll(attr\n  /*: string*/\n  , items\n  /*: Array<mixed>*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set(attr, new _ParseOp.RemoveOp(items));\n  }\n  /**\n   * Returns an instance of a subclass of Parse.Op describing what kind of\n   * modification has been performed on this field since the last time it was\n   * saved. For example, after calling object.increment(\"x\"), calling\n   * object.op(\"x\") would return an instance of Parse.Op.Increment.\n   *\n   * @param attr {String} The key.\n   * @returns {Parse.Op} The operation, or undefined if none.\n   */\n\n\n  op(attr\n  /*: string*/\n  )\n  /*: ?Op*/\n  {\n    const pending = this._getPendingOps();\n\n    for (let i = pending.length; i--;) {\n      if (pending[i][attr]) {\n        return pending[i][attr];\n      }\n    }\n  }\n  /**\n   * Creates a new model with identical attributes to this one.\n   *\n   * @returns {Parse.Object}\n   */\n\n\n  clone()\n  /*: any*/\n  {\n    const clone = new this.constructor(this.className);\n    let attributes = this.attributes;\n\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      const readonly = this.constructor.readOnlyAttributes() || []; // Attributes are frozen, so we have to rebuild an object,\n      // rather than delete readonly keys\n\n      const copy = {};\n\n      for (const a in attributes) {\n        if (readonly.indexOf(a) < 0) {\n          copy[a] = attributes[a];\n        }\n      }\n\n      attributes = copy;\n    }\n\n    if (clone.set) {\n      clone.set(attributes);\n    }\n\n    return clone;\n  }\n  /**\n   * Creates a new instance of this object. Not to be confused with clone()\n   *\n   * @returns {Parse.Object}\n   */\n\n\n  newInstance()\n  /*: any*/\n  {\n    const clone = new this.constructor(this.className);\n    clone.id = this.id;\n\n    if (singleInstance) {\n      // Just return an object with the right id\n      return clone;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    if (stateController) {\n      stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());\n    }\n\n    return clone;\n  }\n  /**\n   * Returns true if this object has never been saved to Parse.\n   *\n   * @returns {boolean}\n   */\n\n\n  isNew()\n  /*: boolean*/\n  {\n    return !this.id;\n  }\n  /**\n   * Returns true if this object was created by the Parse server when the\n   * object might have already been there (e.g. in the case of a Facebook\n   * login)\n   *\n   * @returns {boolean}\n   */\n\n\n  existed()\n  /*: boolean*/\n  {\n    if (!this.id) {\n      return false;\n    }\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const state = stateController.getState(this._getStateIdentifier());\n\n    if (state) {\n      return state.existed;\n    }\n\n    return false;\n  }\n  /**\n   * Returns true if this object exists on the Server\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object exists.\n   */\n\n\n  async exists(options\n  /*:: ?: RequestOptions*/\n  )\n  /*: Promise<boolean>*/\n  {\n    if (!this.id) {\n      return false;\n    }\n\n    try {\n      const query = new _ParseQuery.default(this.className);\n      await query.get(this.id, options);\n      return true;\n    } catch (e) {\n      if (e.code === _ParseError.default.OBJECT_NOT_FOUND) {\n        return false;\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Checks if the model is currently in a valid state.\n   *\n   * @returns {boolean}\n   */\n\n\n  isValid()\n  /*: boolean*/\n  {\n    return !this.validate(this.attributes);\n  }\n  /**\n   * You should not call this function directly unless you subclass\n   * <code>Parse.Object</code>, in which case you can override this method\n   * to provide additional validation on <code>set</code> and\n   * <code>save</code>.  Your implementation should return\n   *\n   * @param {object} attrs The current data to validate.\n   * @returns {Parse.Error|boolean} False if the data is valid.  An error object otherwise.\n   * @see Parse.Object#set\n   */\n\n\n  validate(attrs\n  /*: AttributeMap*/\n  )\n  /*: ParseError | boolean*/\n  {\n    if (attrs.hasOwnProperty('ACL') && !(attrs.ACL instanceof _ParseACL.default)) {\n      return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'ACL must be a Parse ACL.');\n    }\n\n    for (const key in attrs) {\n      if (!/^[A-Za-z][0-9A-Za-z_.]*$/.test(key)) {\n        return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Returns the ACL for this object.\n   *\n   * @returns {Parse.ACL} An instance of Parse.ACL.\n   * @see Parse.Object#get\n   */\n\n\n  getACL()\n  /*: ?ParseACL*/\n  {\n    const acl = this.get('ACL');\n\n    if (acl instanceof _ParseACL.default) {\n      return acl;\n    }\n\n    return null;\n  }\n  /**\n   * Sets the ACL to be used for this object.\n   *\n   * @param {Parse.ACL} acl An instance of Parse.ACL.\n   * @param {object} options\n   * @returns {(ParseObject | boolean)} Whether the set passed validation.\n   * @see Parse.Object#set\n   */\n\n\n  setACL(acl\n  /*: ParseACL*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set('ACL', acl, options);\n  }\n  /**\n   * Clears any (or specific) changes to this object made since the last call to save()\n   *\n   * @param {string} [keys] - specify which fields to revert\n   */\n\n\n  revert(...keys)\n  /*: void*/\n  {\n    let keysToRevert;\n\n    if (keys.length) {\n      keysToRevert = [];\n\n      for (const key of keys) {\n        if (typeof key === 'string') {\n          keysToRevert.push(key);\n        } else {\n          throw new Error('Parse.Object#revert expects either no, or a list of string, arguments.');\n        }\n      }\n    }\n\n    this._clearPendingOps(keysToRevert);\n  }\n  /**\n   * Clears all attributes on a model\n   *\n   * @returns {(ParseObject | boolean)}\n   */\n\n\n  clear()\n  /*: ParseObject | boolean*/\n  {\n    const attributes = this.attributes;\n    const erasable = {};\n    let readonly = ['createdAt', 'updatedAt'];\n\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = readonly.concat(this.constructor.readOnlyAttributes());\n    }\n\n    for (const attr in attributes) {\n      if (readonly.indexOf(attr) < 0) {\n        erasable[attr] = true;\n      }\n    }\n\n    return this.set(erasable, {\n      unset: true\n    });\n  }\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n\n\n  fetch(options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    options = options || {};\n    const fetchOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      fetchOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      fetchOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      fetchOptions.context = options.context;\n    }\n\n    if (options.hasOwnProperty('include')) {\n      fetchOptions.include = [];\n\n      if (Array.isArray(options.include)) {\n        options.include.forEach(key => {\n          if (Array.isArray(key)) {\n            fetchOptions.include = fetchOptions.include.concat(key);\n          } else {\n            fetchOptions.include.push(key);\n          }\n        });\n      } else {\n        fetchOptions.include.push(options.include);\n      }\n    }\n\n    const controller = _CoreManager.default.getObjectController();\n\n    return controller.fetch(this, true, fetchOptions);\n  }\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n\n\n  fetchWithInclude(keys\n  /*: String | Array<string | Array<string>>*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    options = options || {};\n    options.include = keys;\n    return this.fetch(options);\n  }\n  /**\n   * Saves this object to the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection, and don't need to know when the save completes.\n   * If there is some problem with the object such that it can't be saved, it will be silently discarded.\n   *\n   * Objects saved with this method will be stored locally in an on-disk cache until they can be delivered to Parse.\n   * They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection is\n   * available. Objects saved this way will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n\n\n  async saveEventually(options\n  /*: SaveOptions*/\n  )\n  /*: Promise*/\n  {\n    try {\n      await this.save(null, options);\n    } catch (e) {\n      if (e.message === 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n        await _EventuallyQueue.default.save(this, options);\n\n        _EventuallyQueue.default.poll();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Set a hash of model attributes, and save the model to the server.\n   * updatedAt will be updated when the request returns.\n   * You can either call it as:<pre>\n   * object.save();</pre>\n   * or<pre>\n   * object.save(attrs);</pre>\n   * or<pre>\n   * object.save(null, options);</pre>\n   * or<pre>\n   * object.save(attrs, options);</pre>\n   * or<pre>\n   * object.save(key, value);</pre>\n   * or<pre>\n   * object.save(key, value, options);</pre>\n   *\n   * Example 1: <pre>\n   * gameTurn.save({\n   * player: \"Jake Cutter\",\n   * diceRoll: 2\n   * }).then(function(gameTurnAgain) {\n   * // The save was successful.\n   * }, function(error) {\n   * // The save failed.  Error is an instance of Parse.Error.\n   * });</pre>\n   *\n   * Example 2: <pre>\n   * gameTurn.save(\"player\", \"Jake Cutter\");</pre>\n   *\n   * @param {string | object | null} [arg1]\n   * Valid options are:<ul>\n   * <li>`Object` - Key/value pairs to update on the object.</li>\n   * <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>\n   * <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>\n   * </ul>\n   * @param {string | object} [arg2]\n   * <ul>\n   * <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>\n   * <li>`Object` Options - Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * </li>\n   * </ul>\n   * @param {object} [arg3]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n\n\n  save(arg1\n  /*: ?string | { [attr: string]: mixed }*/\n  , arg2\n  /*: SaveOptions | mixed*/\n  , arg3\n  /*:: ?: SaveOptions*/\n  )\n  /*: Promise*/\n  {\n    let attrs;\n    let options;\n\n    if (typeof arg1 === 'object' || typeof arg1 === 'undefined') {\n      attrs = arg1;\n\n      if (typeof arg2 === 'object') {\n        options = arg2;\n      }\n    } else {\n      attrs = {};\n      attrs[arg1] = arg2;\n      options = arg3;\n    }\n\n    if (attrs) {\n      const validation = this.validate(attrs);\n\n      if (validation) {\n        return Promise.reject(validation);\n      }\n\n      this.set(attrs, options);\n    }\n\n    options = options || {};\n    const saveOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = !!options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken') && typeof options.sessionToken === 'string') {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('installationId') && typeof options.installationId === 'string') {\n      saveOptions.installationId = options.installationId;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n\n    const controller = _CoreManager.default.getObjectController();\n\n    const unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;\n    return controller.save(unsaved, saveOptions).then(() => {\n      return controller.save(this, saveOptions);\n    });\n  }\n  /**\n   * Deletes this object from the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection,\n   * and don't need to know when the delete completes. If there is some problem with the object\n   * such that it can't be deleted, the request will be silently discarded.\n   *\n   * Delete instructions made with this method will be stored locally in an on-disk cache until they can be transmitted\n   * to Parse. They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection\n   * is available. Delete requests will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n\n\n  async destroyEventually(options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    try {\n      await this.destroy(options);\n    } catch (e) {\n      if (e.message === 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n        await _EventuallyQueue.default.destroy(this, options);\n\n        _EventuallyQueue.default.poll();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Destroy this model on the server if it was already persisted.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n\n\n  destroy(options\n  /*: RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    options = options || {};\n    const destroyOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n\n    if (!this.id) {\n      return Promise.resolve();\n    }\n\n    return _CoreManager.default.getObjectController().destroy(this, destroyOptions);\n  }\n  /**\n   * Asynchronously stores the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pin();\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n\n\n  pin()\n  /*: Promise<void>*/\n  {\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await object.unPin();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n\n\n  unPin()\n  /*: Promise<void>*/\n  {\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n  /**\n   * Asynchronously returns if the object is pinned\n   *\n   * <pre>\n   * const isPinned = await object.isPinned();\n   * </pre>\n   *\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.\n   */\n\n\n  async isPinned()\n  /*: Promise<boolean>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pin = await localDatastore.fromPinWithName(objectKey);\n    return pin.length > 0;\n  }\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pinWithName(name);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n\n\n  pinWithName(name\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    return ParseObject.pinAllWithName(name, [this]);\n  }\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore, recursively.\n   *\n   * <pre>\n   * await object.unPinWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n\n\n  unPinWithName(name\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    return ParseObject.unPinAllWithName(name, [this]);\n  }\n  /**\n   * Asynchronously loads data from the local datastore into this object.\n   *\n   * <pre>\n   * await object.fetchFromLocalDatastore();\n   * </pre>\n   *\n   * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>\n   * and then call <code>fetchFromLocalDatastore()</code> on it.\n   *\n   * @returns {Promise} A promise that is fulfilled when the fetch completes.\n   */\n\n\n  async fetchFromLocalDatastore()\n  /*: Promise<ParseObject>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      throw new Error('Parse.enableLocalDatastore() must be called first');\n    }\n\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pinned = await localDatastore._serializeObject(objectKey);\n\n    if (!pinned) {\n      throw new Error('Cannot fetch an unsaved ParseObject');\n    }\n\n    const result = ParseObject.fromJSON(pinned);\n\n    this._finishFetch(result.toJSON());\n\n    return this;\n  }\n  /** Static methods **/\n\n\n  static _clearAllState() {\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    stateController.clearAllState();\n  }\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAll(list\n  /*: Array<ParseObject>*/\n  , options\n  /*: RequestOptions*/\n  = {}) {\n    const queryOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n\n    return _CoreManager.default.getObjectController().fetch(list, true, queryOptions);\n  }\n  /**\n   * Fetches the given list of Parse.Object.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAllWithInclude(list\n  /*: Array<ParseObject>*/\n  , keys\n  /*: String | Array<string | Array<string>>*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAll(list, options);\n  }\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeededWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAllIfNeededWithInclude(list\n  /*: Array<ParseObject>*/\n  , keys\n  /*: String | Array<string | Array<string>>*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAllIfNeeded(list, options);\n  }\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...])\n   *    .then((list) => {\n   *      // Objects were fetched and updated.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static fetchAllIfNeeded(list\n  /*: Array<ParseObject>*/\n  , options) {\n    options = options || {};\n    const queryOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n\n    return _CoreManager.default.getObjectController().fetch(list, false, queryOptions);\n  }\n\n  static handleIncludeOptions(options) {\n    let include = [];\n\n    if (Array.isArray(options.include)) {\n      options.include.forEach(key => {\n        if (Array.isArray(key)) {\n          include = include.concat(key);\n        } else {\n          include.push(key);\n        }\n      });\n    } else {\n      include.push(options.include);\n    }\n\n    return include;\n  }\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   * <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n   * array of other Parse.Error objects. Each error object in this array\n   * has an \"object\" property that references the object that could not be\n   * deleted (for instance, because that object could not be found).</li>\n   * <li>A non-aggregate Parse.Error. This indicates a serious error that\n   * caused the delete operation to be aborted partway through (for\n   * instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   * Parse.Object.destroyAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were deleted.\n   * }, (error) => {\n   * // An error occurred while deleting one or more of the objects.\n   * // If this is an aggregate error, then we can inspect each error\n   * // object individually to determine the reason why a particular\n   * // object was not deleted.\n   * if (error.code === Parse.Error.AGGREGATE_ERROR) {\n   * for (var i = 0; i < error.errors.length; i++) {\n   * console.log(\"Couldn't delete \" + error.errors[i].object.id +\n   * \"due to \" + error.errors[i].message);\n   * }\n   * } else {\n   * console.log(\"Delete aborted because of \" + error.message);\n   * }\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled when the destroyAll\n   * completes.\n   */\n\n\n  static destroyAll(list\n  /*: Array<ParseObject>*/\n  , options = {}) {\n    const destroyOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      destroyOptions.batchSize = options.batchSize;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n\n    return _CoreManager.default.getObjectController().destroy(list, destroyOptions);\n  }\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   * Parse.Object.saveAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were saved.\n   * }, (error) => {\n   * // An error occurred while saving one of the objects.\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n\n\n  static saveAll(list\n  /*: Array<ParseObject>*/\n  , options\n  /*: RequestOptions*/\n  = {}) {\n    const saveOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('sessionToken')) {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      saveOptions.batchSize = options.batchSize;\n    }\n\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n\n    return _CoreManager.default.getObjectController().save(list, saveOptions);\n  }\n  /**\n   * Creates a reference to a subclass of Parse.Object with the given id. This\n   * does not exist on Parse.Object, only on subclasses.\n   *\n   * <p>A shortcut for: <pre>\n   *  var Foo = Parse.Object.extend(\"Foo\");\n   *  var pointerToFoo = new Foo();\n   *  pointerToFoo.id = \"myObjectId\";\n   * </pre>\n   *\n   * @param {string} id The ID of the object to create a reference to.\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference.\n   */\n\n\n  static createWithoutData(id\n  /*: string*/\n  ) {\n    const obj = new this();\n    obj.id = id;\n    return obj;\n  }\n  /**\n   * Creates a new instance of a Parse Object from a JSON representation.\n   *\n   * @param {object} json The JSON map of the Object's data\n   * @param {boolean} override In single instance mode, all old server data\n   *   is overwritten if this is set to true\n   * @param {boolean} dirty Whether the Parse.Object should set JSON keys to dirty\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference\n   */\n\n\n  static fromJSON(json\n  /*: any*/\n  , override\n  /*:: ?: boolean*/\n  , dirty\n  /*:: ?: boolean*/\n  ) {\n    if (!json.className) {\n      throw new Error('Cannot create an object without a className');\n    }\n\n    const constructor = classMap[json.className];\n    const o = constructor ? new constructor(json.className) : new ParseObject(json.className);\n    const otherAttributes = {};\n\n    for (const attr in json) {\n      if (attr !== 'className' && attr !== '__type') {\n        otherAttributes[attr] = json[attr];\n\n        if (dirty) {\n          o.set(attr, json[attr]);\n        }\n      }\n    }\n\n    if (override) {\n      // id needs to be set before clearServerData can work\n      if (otherAttributes.objectId) {\n        o.id = otherAttributes.objectId;\n      }\n\n      let preserved = null;\n\n      if (typeof o._preserveFieldsOnFetch === 'function') {\n        preserved = o._preserveFieldsOnFetch();\n      }\n\n      o._clearServerData();\n\n      if (preserved) {\n        o._finishFetch(preserved);\n      }\n    }\n\n    o._finishFetch(otherAttributes);\n\n    if (json.objectId) {\n      o._setExisted(true);\n    }\n\n    return o;\n  }\n  /**\n   * Registers a subclass of Parse.Object with a specific class name.\n   * When objects of that class are retrieved from a query, they will be\n   * instantiated with this subclass.\n   * This is only necessary when using ES6 subclassing.\n   *\n   * @param {string} className The class name of the subclass\n   * @param {Function} constructor The subclass\n   */\n\n\n  static registerSubclass(className\n  /*: string*/\n  , constructor\n  /*: any*/\n  ) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n\n    if (typeof constructor === 'undefined') {\n      throw new TypeError('You must supply a subclass constructor.');\n    }\n\n    if (typeof constructor !== 'function') {\n      throw new TypeError('You must register the subclass constructor. ' + 'Did you attempt to register an instance of the subclass?');\n    }\n\n    classMap[className] = constructor;\n\n    if (!constructor.className) {\n      constructor.className = className;\n    }\n  }\n  /**\n   * Unegisters a subclass of Parse.Object with a specific class name.\n   *\n   * @param {string} className The class name of the subclass\n   */\n\n\n  static unregisterSubclass(className\n  /*: string*/\n  ) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n\n    delete classMap[className];\n  }\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend(\"MyClass\", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: \"MyClass\",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {string} className The name of the Parse class backing this model.\n   * @param {object} protoProps Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {object} classProps Class properties to add the class returned from\n   *     this method.\n   * @returns {Parse.Object} A new subclass of Parse.Object.\n   */\n\n\n  static extend(className\n  /*: any*/\n  , protoProps\n  /*: any*/\n  , classProps\n  /*: any*/\n  ) {\n    if (typeof className !== 'string') {\n      if (className && typeof className.className === 'string') {\n        return ParseObject.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\"Parse.Object.extend's first argument should be the className.\");\n      }\n    }\n\n    let adjustedClassName = className;\n\n    if (adjustedClassName === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n      adjustedClassName = '_User';\n    }\n\n    let parentProto = ParseObject.prototype;\n\n    if (this.hasOwnProperty('__super__') && this.__super__) {\n      parentProto = this.prototype;\n    } else if (classMap[adjustedClassName]) {\n      parentProto = classMap[adjustedClassName].prototype;\n    }\n\n    const ParseObjectSubclass = function (attributes, options) {\n      this.className = adjustedClassName;\n      this._objCount = objectCount++; // Enable legacy initializers\n\n      if (typeof this.initialize === 'function') {\n        this.initialize.apply(this, arguments);\n      }\n\n      if (attributes && typeof attributes === 'object') {\n        if (!this.set(attributes || {}, options)) {\n          throw new Error(\"Can't create an invalid Parse Object\");\n        }\n      }\n    };\n\n    ParseObjectSubclass.className = adjustedClassName;\n    ParseObjectSubclass.__super__ = parentProto;\n    ParseObjectSubclass.prototype = Object.create(parentProto, {\n      constructor: {\n        value: ParseObjectSubclass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseObjectSubclass.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseObjectSubclass, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    ParseObjectSubclass.extend = function (name, protoProps, classProps) {\n      if (typeof name === 'string') {\n        return ParseObject.extend.call(ParseObjectSubclass, name, protoProps, classProps);\n      }\n\n      return ParseObject.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps);\n    };\n\n    ParseObjectSubclass.createWithoutData = ParseObject.createWithoutData;\n    classMap[adjustedClassName] = ParseObjectSubclass;\n    return ParseObjectSubclass;\n  }\n  /**\n   * Enable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * This is disabled by default in server environments, since it can lead to\n   * security issues.\n   *\n   * @static\n   */\n\n\n  static enableSingleInstance() {\n    singleInstance = true;\n\n    _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n  }\n  /**\n   * Disable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * When disabled, you can have two instances of the same object in memory\n   * without them sharing attributes.\n   *\n   * @static\n   */\n\n\n  static disableSingleInstance() {\n    singleInstance = false;\n\n    _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n  }\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAll([...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n\n\n  static pinAll(objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n\n\n  static pinAllWithName(name\n  /*: string*/\n  , objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore._handlePinAllWithName(name, objects);\n  }\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAll([...]);\n   * </pre>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAll(objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore, recursively.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAllWithName(name\n  /*: string*/\n  , objects\n  /*: Array<ParseObject>*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore._handleUnPinAllWithName(name, objects);\n  }\n  /**\n   * Asynchronously removes all objects in the local datastore using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjects();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAllObjects()\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n  /**\n   * Asynchronously removes all objects with the specified pin name.\n   * Deletes the pin name also.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjectsWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n\n\n  static unPinAllObjectsWithName(name\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (!localDatastore.isEnabled) {\n      return Promise.reject('Parse.enableLocalDatastore() must be called first');\n    }\n\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name);\n  }\n\n}\n\nconst DefaultController = {\n  fetch(target\n  /*: ParseObject | Array<ParseObject>*/\n  , forceFetch\n  /*: boolean*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<void> | ParseObject>*/\n  {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      const objs = [];\n      const ids = [];\n      let className = null;\n      const results = [];\n      let error = null;\n      target.forEach(el => {\n        if (error) {\n          return;\n        }\n\n        if (!className) {\n          className = el.className;\n        }\n\n        if (className !== el.className) {\n          error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, 'All objects should be of the same class');\n        }\n\n        if (!el.id) {\n          error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'All objects must have an ID');\n        }\n\n        if (forceFetch || !el.isDataAvailable()) {\n          ids.push(el.id);\n          objs.push(el);\n        }\n\n        results.push(el);\n      });\n\n      if (error) {\n        return Promise.reject(error);\n      }\n\n      const query = new _ParseQuery.default(className);\n      query.containedIn('objectId', ids);\n\n      if (options && options.include) {\n        query.include(options.include);\n      }\n\n      query._limit = ids.length;\n      return query.find(options).then(async objects => {\n        const idMap = {};\n        objects.forEach(o => {\n          idMap[o.id] = o;\n        });\n\n        for (let i = 0; i < objs.length; i++) {\n          const obj = objs[i];\n\n          if (!obj || !obj.id || !idMap[obj.id]) {\n            if (forceFetch) {\n              return Promise.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'All objects must exist on the server.'));\n            }\n          }\n        }\n\n        if (!singleInstance) {\n          // If single instance objects are disabled, we need to replace the\n          for (let i = 0; i < results.length; i++) {\n            const obj = results[i];\n\n            if (obj && obj.id && idMap[obj.id]) {\n              const id = obj.id;\n\n              obj._finishFetch(idMap[id].toJSON());\n\n              results[i] = idMap[id];\n            }\n          }\n        }\n\n        for (const object of results) {\n          await localDatastore._updateObjectIfPinned(object);\n        }\n\n        return Promise.resolve(results);\n      });\n    } else if (target instanceof ParseObject) {\n      if (!target.id) {\n        return Promise.reject(new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'Object does not have an ID'));\n      }\n\n      const RESTController = _CoreManager.default.getRESTController();\n\n      const params = {};\n\n      if (options && options.include) {\n        params.include = options.include.join();\n      }\n\n      return RESTController.request('GET', 'classes/' + target.className + '/' + target._getId(), params, options).then(async response => {\n        target._clearPendingOps();\n\n        target._clearServerData();\n\n        target._finishFetch(response);\n\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      });\n    }\n\n    return Promise.resolve();\n  },\n\n  async destroy(target\n  /*: ParseObject | Array<ParseObject>*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<Array<void> | ParseObject>*/\n  {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      const batches = [[]];\n      target.forEach(obj => {\n        if (!obj.id) {\n          return;\n        }\n\n        batches[batches.length - 1].push(obj);\n\n        if (batches[batches.length - 1].length >= batchSize) {\n          batches.push([]);\n        }\n      });\n\n      if (batches[batches.length - 1].length === 0) {\n        // If the last batch is empty, remove it\n        batches.pop();\n      }\n\n      let deleteCompleted = Promise.resolve();\n      const errors = [];\n      batches.forEach(batch => {\n        deleteCompleted = deleteCompleted.then(() => {\n          return RESTController.request('POST', 'batch', {\n            requests: batch.map(obj => {\n              return {\n                method: 'DELETE',\n                path: getServerUrlPath() + 'classes/' + obj.className + '/' + obj._getId(),\n                body: {}\n              };\n            })\n          }, options).then(results => {\n            for (let i = 0; i < results.length; i++) {\n              if (results[i] && results[i].hasOwnProperty('error')) {\n                const err = new _ParseError.default(results[i].error.code, results[i].error.error);\n                err.object = batch[i];\n                errors.push(err);\n              }\n            }\n          });\n        });\n      });\n      return deleteCompleted.then(async () => {\n        if (errors.length) {\n          const aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);\n          aggregate.errors = errors;\n          return Promise.reject(aggregate);\n        }\n\n        for (const object of target) {\n          await localDatastore._destroyObjectIfPinned(object);\n        }\n\n        return Promise.resolve(target);\n      });\n    } else if (target instanceof ParseObject) {\n      return RESTController.request('DELETE', 'classes/' + target.className + '/' + target._getId(), {}, options).then(async () => {\n        await localDatastore._destroyObjectIfPinned(target);\n        return Promise.resolve(target);\n      });\n    }\n\n    return Promise.resolve(target);\n  },\n\n  save(target\n  /*: ParseObject | Array<ParseObject | ParseFile>*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n\n    const mapIdForPin = {};\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const allowCustomObjectId = _CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID');\n\n    options = options || {};\n    options.returnStatus = options.returnStatus || true;\n\n    if (Array.isArray(target)) {\n      if (target.length < 1) {\n        return Promise.resolve([]);\n      }\n\n      let unsaved = target.concat();\n\n      for (let i = 0; i < target.length; i++) {\n        if (target[i] instanceof ParseObject) {\n          unsaved = unsaved.concat((0, _unsavedChildren.default)(target[i], true));\n        }\n      }\n\n      unsaved = (0, _unique.default)(unsaved);\n      const filesSaved\n      /*: Array<ParseFile>*/\n      = [];\n      let pending\n      /*: Array<ParseObject>*/\n      = [];\n      unsaved.forEach(el => {\n        if (el instanceof _ParseFile.default) {\n          filesSaved.push(el.save(options));\n        } else if (el instanceof ParseObject) {\n          if (allowCustomObjectId && !el.id) {\n            throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty, null or undefined');\n          }\n\n          pending.push(el);\n        }\n      });\n      return Promise.all(filesSaved).then(() => {\n        let objectError = null;\n        return (0, _promiseUtils.continueWhile)(() => {\n          return pending.length > 0;\n        }, () => {\n          const batch = [];\n          const nextPending = [];\n          pending.forEach(el => {\n            if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {\n              batch.push(el);\n            } else {\n              nextPending.push(el);\n            }\n          });\n          pending = nextPending;\n\n          if (batch.length < 1) {\n            return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));\n          } // Queue up tasks for each object in the batch.\n          // When every task is ready, the API request will execute\n\n\n          const batchReturned = new _promiseUtils.resolvingPromise();\n          const batchReady = [];\n          const batchTasks = [];\n          batch.forEach((obj, index) => {\n            const ready = new _promiseUtils.resolvingPromise();\n            batchReady.push(ready);\n            stateController.pushPendingState(obj._getStateIdentifier());\n            batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function () {\n              ready.resolve();\n              return batchReturned.then(responses => {\n                if (responses[index].hasOwnProperty('success')) {\n                  const objectId = responses[index].success.objectId;\n                  const status = responses[index]._status;\n                  delete responses[index]._status;\n                  mapIdForPin[objectId] = obj._localId;\n\n                  obj._handleSaveResponse(responses[index].success, status);\n                } else {\n                  if (!objectError && responses[index].hasOwnProperty('error')) {\n                    const serverError = responses[index].error;\n                    objectError = new _ParseError.default(serverError.code, serverError.error); // Cancel the rest of the save\n\n                    pending = [];\n                  }\n\n                  obj._handleSaveError();\n                }\n              });\n            }));\n          });\n          (0, _promiseUtils.when)(batchReady).then(() => {\n            // Kick off the batch request\n            return RESTController.request('POST', 'batch', {\n              requests: batch.map(obj => {\n                const params = obj._getSaveParams();\n\n                params.path = getServerUrlPath() + params.path;\n                return params;\n              })\n            }, options);\n          }).then(batchReturned.resolve, error => {\n            batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));\n          });\n          return (0, _promiseUtils.when)(batchTasks);\n        }).then(async () => {\n          if (objectError) {\n            return Promise.reject(objectError);\n          }\n\n          for (const object of target) {\n            await localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);\n            await localDatastore._updateObjectIfPinned(object);\n          }\n\n          return Promise.resolve(target);\n        });\n      });\n    } else if (target instanceof ParseObject) {\n      if (allowCustomObjectId && !target.id) {\n        throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty, null or undefined');\n      } // generate _localId in case if cascadeSave=false\n\n\n      target._getId();\n\n      const localId = target._localId; // copying target lets Flow guarantee the pointer isn't modified elsewhere\n\n      const targetCopy = target;\n\n      const task = function () {\n        const params = targetCopy._getSaveParams();\n\n        return RESTController.request(params.method, params.path, params.body, options).then(response => {\n          const status = response._status;\n          delete response._status;\n\n          targetCopy._handleSaveResponse(response, status);\n        }, error => {\n          targetCopy._handleSaveError();\n\n          return Promise.reject(error);\n        });\n      };\n\n      stateController.pushPendingState(target._getStateIdentifier());\n      return stateController.enqueueTask(target._getStateIdentifier(), task).then(async () => {\n        await localDatastore._updateLocalIdForObject(localId, target);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      }, error => {\n        return Promise.reject(error);\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n};\n\n_CoreManager.default.setObjectController(DefaultController);\n\nvar _default = ParseObject;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}