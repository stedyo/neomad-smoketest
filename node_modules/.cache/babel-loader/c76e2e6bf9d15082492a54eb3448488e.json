{"ast":null,"code":"\"use strict\";\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * https://github.com/francimedia/parse-js-local-storage\n *\n * @flow\n */\n\n\nconst QUEUE_KEY = 'Parse/Eventually/Queue';\nlet queueCache = [];\nlet dirtyCache = true;\nlet polling = undefined;\n/**\n * Provides utility functions to queue objects that will be\n * saved to the server at a later date.\n *\n * @class Parse.EventuallyQueue\n * @static\n */\n\nconst EventuallyQueue = {\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function save\n   * @name Parse.EventuallyQueue.save\n   * @param {ParseObject} object Parse.Object to be saved eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#save Parse.Object.save} options.\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#saveEventually\n   */\n  save(object\n  /*: ParseObject*/\n  , serverOptions\n  /*: SaveOptions*/\n  = {})\n  /*: Promise*/\n  {\n    return this.enqueue('save', object, serverOptions);\n  },\n\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function destroy\n   * @name Parse.EventuallyQueue.destroy\n   * @param {ParseObject} object Parse.Object to be destroyed eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#destroy Parse.Object.destroy} options\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#destroyEventually\n   */\n  destroy(object\n  /*: ParseObject*/\n  , serverOptions\n  /*: RequestOptions*/\n  = {})\n  /*: Promise*/\n  {\n    return this.enqueue('destroy', object, serverOptions);\n  },\n\n  /**\n   * Generate unique identifier to avoid duplicates and maintain previous state.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @returns {string}\n   * @static\n   * @ignore\n   */\n  generateQueueId(action\n  /*: string*/\n  , object\n  /*: ParseObject*/\n  )\n  /*: string*/\n  {\n    object._getId();\n\n    const {\n      className,\n      id,\n      _localId\n    } = object;\n\n    const uniqueId = object.get('hash') || _localId;\n\n    return [action, className, id, uniqueId].join('_');\n  },\n\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @param {object} [serverOptions]\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @ignore\n   */\n  async enqueue(action\n  /*: string*/\n  , object\n  /*: ParseObject*/\n  , serverOptions\n  /*: SaveOptions | RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    const queueData = await this.getQueue();\n    const queueId = this.generateQueueId(action, object);\n    let index = this.queueItemExists(queueData, queueId);\n\n    if (index > -1) {\n      // Add cached values to new object if they don't exist\n      for (const prop in queueData[index].object) {\n        if (typeof object.get(prop) === 'undefined') {\n          object.set(prop, queueData[index].object[prop]);\n        }\n      }\n    } else {\n      index = queueData.length;\n    }\n\n    queueData[index] = {\n      queueId,\n      action,\n      object: object.toJSON(),\n      serverOptions,\n      id: object.id,\n      className: object.className,\n      hash: object.get('hash'),\n      createdAt: new Date()\n    };\n    return this.setQueue(queueData);\n  },\n\n  store(data) {\n    return _Storage.default.setItemAsync(QUEUE_KEY, JSON.stringify(data));\n  },\n\n  load() {\n    return _Storage.default.getItemAsync(QUEUE_KEY);\n  },\n\n  /**\n   * Sets the in-memory queue from local storage and returns.\n   *\n   * @function getQueue\n   * @name Parse.EventuallyQueue.getQueue\n   * @returns {Promise<Array>}\n   * @static\n   */\n  async getQueue()\n  /*: Promise<Array>*/\n  {\n    if (dirtyCache) {\n      queueCache = JSON.parse((await this.load()) || '[]');\n      dirtyCache = false;\n    }\n\n    return queueCache;\n  },\n\n  /**\n   * Saves the queue to local storage\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  setQueue(queue\n  /*: Queue*/\n  )\n  /*: Promise<void>*/\n  {\n    queueCache = queue;\n    return this.store(queueCache);\n  },\n\n  /**\n   * Removes Parse.Object data from queue.\n   *\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  async remove(queueId\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    const queueData = await this.getQueue();\n    const index = this.queueItemExists(queueData, queueId);\n\n    if (index > -1) {\n      queueData.splice(index, 1);\n      await this.setQueue(queueData);\n    }\n  },\n\n  /**\n   * Removes all objects from queue.\n   *\n   * @function clear\n   * @name Parse.EventuallyQueue.clear\n   * @returns {Promise} A promise that is fulfilled when queue is cleared.\n   * @static\n   */\n  clear()\n  /*: Promise*/\n  {\n    queueCache = [];\n    return this.store([]);\n  },\n\n  /**\n   * Return the index of a queueId in the queue. Returns -1 if not found.\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {number}\n   * @static\n   * @ignore\n   */\n  queueItemExists(queue\n  /*: Queue*/\n  , queueId\n  /*: string*/\n  )\n  /*: number*/\n  {\n    return queue.findIndex(data => data.queueId === queueId);\n  },\n\n  /**\n   * Return the number of objects in the queue.\n   *\n   * @function length\n   * @name Parse.EventuallyQueue.length\n   * @returns {number}\n   * @static\n   */\n  async length()\n  /*: number*/\n  {\n    const queueData = await this.getQueue();\n    return queueData.length;\n  },\n\n  /**\n   * Sends the queue to the server.\n   *\n   * @function sendQueue\n   * @name Parse.EventuallyQueue.sendQueue\n   * @returns {Promise<boolean>} Returns true if queue was sent successfully.\n   * @static\n   */\n  async sendQueue()\n  /*: Promise<boolean>*/\n  {\n    const queue = await this.getQueue();\n    const queueData = [...queue];\n\n    if (queueData.length === 0) {\n      return false;\n    }\n\n    for (let i = 0; i < queueData.length; i += 1) {\n      const queueObject = queueData[i];\n      const {\n        id,\n        hash,\n        className\n      } = queueObject;\n\n      const ObjectType = _ParseObject.default.extend(className);\n\n      if (id) {\n        await this.process.byId(ObjectType, queueObject);\n      } else if (hash) {\n        await this.process.byHash(ObjectType, queueObject);\n      } else {\n        await this.process.create(ObjectType, queueObject);\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {ParseObject} object Parse.Object to be processed\n   * @param {QueueObject} queueObject Parse.Object data from the queue\n   * @returns {Promise} A promise that is fulfilled when operation is performed.\n   * @static\n   * @ignore\n   */\n  async sendQueueCallback(object\n  /*: ParseObject*/\n  , queueObject\n  /*: QueueObject*/\n  )\n  /*: Promise<void>*/\n  {\n    if (!object) {\n      return this.remove(queueObject.queueId);\n    }\n\n    switch (queueObject.action) {\n      case 'save':\n        // Queued update was overwritten by other request. Do not save\n        if (typeof object.updatedAt !== 'undefined' && object.updatedAt > new Date(queueObject.object.createdAt)) {\n          return this.remove(queueObject.queueId);\n        }\n\n        try {\n          await object.save(queueObject.object, queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.message !== 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n            await this.remove(queueObject.queueId);\n          }\n        }\n\n        break;\n\n      case 'destroy':\n        try {\n          await object.destroy(queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.message !== 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n            await this.remove(queueObject.queueId);\n          }\n        }\n\n        break;\n    }\n  },\n\n  /**\n   * Start polling server for network connection.\n   * Will send queue if connection is established.\n   *\n   * @function poll\n   * @name Parse.EventuallyQueue.poll\n   * @param [ms] Milliseconds to ping the server. Default 2000ms\n   * @static\n   */\n  poll(ms\n  /*: number*/\n  = 2000) {\n    if (polling) {\n      return;\n    }\n\n    polling = setInterval(() => {\n      const RESTController = _CoreManager.default.getRESTController();\n\n      RESTController.request('GET', 'health').then(({\n        status\n      }) => {\n        if (status === 'ok') {\n          this.stopPoll();\n          return this.sendQueue();\n        }\n      }).catch(e => e);\n    }, ms);\n  },\n\n  /**\n   * Turns off polling.\n   *\n   * @function stopPoll\n   * @name Parse.EventuallyQueue.stopPoll\n   * @static\n   */\n  stopPoll() {\n    clearInterval(polling);\n    polling = undefined;\n  },\n\n  /**\n   * Return true if pinging the server.\n   *\n   * @function isPolling\n   * @name Parse.EventuallyQueue.isPolling\n   * @returns {boolean}\n   * @static\n   */\n  isPolling()\n  /*: boolean*/\n  {\n    return !!polling;\n  },\n\n  _setPolling(flag\n  /*: boolean*/\n  ) {\n    polling = flag;\n  },\n\n  process: {\n    create(ObjectType, queueObject) {\n      const object = new ObjectType();\n      return EventuallyQueue.sendQueueCallback(object, queueObject);\n    },\n\n    async byId(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('objectId', queueObject.id);\n      const results = await query.find({\n        sessionToken\n      });\n      return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n    },\n\n    async byHash(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('hash', queueObject.hash);\n      const results = await query.find({\n        sessionToken\n      });\n\n      if (results.length > 0) {\n        return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n      }\n\n      return EventuallyQueue.process.create(ObjectType, queueObject);\n    }\n\n  }\n};\nmodule.exports = EventuallyQueue;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/EventuallyQueue.js"],"names":["_CoreManager","_interopRequireDefault","require","_ParseObject","_ParseQuery","_Storage","obj","__esModule","default","QUEUE_KEY","queueCache","dirtyCache","polling","undefined","EventuallyQueue","save","object","serverOptions","enqueue","destroy","generateQueueId","action","_getId","className","id","_localId","uniqueId","get","join","queueData","getQueue","queueId","index","queueItemExists","prop","set","length","toJSON","hash","createdAt","Date","setQueue","store","data","setItemAsync","JSON","stringify","load","getItemAsync","parse","queue","remove","splice","clear","findIndex","sendQueue","i","queueObject","ObjectType","extend","process","byId","byHash","create","sendQueueCallback","updatedAt","e","message","poll","ms","setInterval","RESTController","getRESTController","request","then","status","stopPoll","catch","clearInterval","isPolling","_setPolling","flag","sessionToken","query","equalTo","results","find","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * https://github.com/francimedia/parse-js-local-storage\n *\n * @flow\n */\n\n\nconst QUEUE_KEY = 'Parse/Eventually/Queue';\nlet queueCache = [];\nlet dirtyCache = true;\nlet polling = undefined;\n/**\n * Provides utility functions to queue objects that will be\n * saved to the server at a later date.\n *\n * @class Parse.EventuallyQueue\n * @static\n */\n\nconst EventuallyQueue = {\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function save\n   * @name Parse.EventuallyQueue.save\n   * @param {ParseObject} object Parse.Object to be saved eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#save Parse.Object.save} options.\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#saveEventually\n   */\n  save(object\n  /*: ParseObject*/\n  , serverOptions\n  /*: SaveOptions*/\n  = {})\n  /*: Promise*/\n  {\n    return this.enqueue('save', object, serverOptions);\n  },\n\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function destroy\n   * @name Parse.EventuallyQueue.destroy\n   * @param {ParseObject} object Parse.Object to be destroyed eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#destroy Parse.Object.destroy} options\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#destroyEventually\n   */\n  destroy(object\n  /*: ParseObject*/\n  , serverOptions\n  /*: RequestOptions*/\n  = {})\n  /*: Promise*/\n  {\n    return this.enqueue('destroy', object, serverOptions);\n  },\n\n  /**\n   * Generate unique identifier to avoid duplicates and maintain previous state.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @returns {string}\n   * @static\n   * @ignore\n   */\n  generateQueueId(action\n  /*: string*/\n  , object\n  /*: ParseObject*/\n  )\n  /*: string*/\n  {\n    object._getId();\n\n    const {\n      className,\n      id,\n      _localId\n    } = object;\n\n    const uniqueId = object.get('hash') || _localId;\n\n    return [action, className, id, uniqueId].join('_');\n  },\n\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @param {object} [serverOptions]\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @ignore\n   */\n  async enqueue(action\n  /*: string*/\n  , object\n  /*: ParseObject*/\n  , serverOptions\n  /*: SaveOptions | RequestOptions*/\n  )\n  /*: Promise*/\n  {\n    const queueData = await this.getQueue();\n    const queueId = this.generateQueueId(action, object);\n    let index = this.queueItemExists(queueData, queueId);\n\n    if (index > -1) {\n      // Add cached values to new object if they don't exist\n      for (const prop in queueData[index].object) {\n        if (typeof object.get(prop) === 'undefined') {\n          object.set(prop, queueData[index].object[prop]);\n        }\n      }\n    } else {\n      index = queueData.length;\n    }\n\n    queueData[index] = {\n      queueId,\n      action,\n      object: object.toJSON(),\n      serverOptions,\n      id: object.id,\n      className: object.className,\n      hash: object.get('hash'),\n      createdAt: new Date()\n    };\n    return this.setQueue(queueData);\n  },\n\n  store(data) {\n    return _Storage.default.setItemAsync(QUEUE_KEY, JSON.stringify(data));\n  },\n\n  load() {\n    return _Storage.default.getItemAsync(QUEUE_KEY);\n  },\n\n  /**\n   * Sets the in-memory queue from local storage and returns.\n   *\n   * @function getQueue\n   * @name Parse.EventuallyQueue.getQueue\n   * @returns {Promise<Array>}\n   * @static\n   */\n  async getQueue()\n  /*: Promise<Array>*/\n  {\n    if (dirtyCache) {\n      queueCache = JSON.parse((await this.load()) || '[]');\n      dirtyCache = false;\n    }\n\n    return queueCache;\n  },\n\n  /**\n   * Saves the queue to local storage\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  setQueue(queue\n  /*: Queue*/\n  )\n  /*: Promise<void>*/\n  {\n    queueCache = queue;\n    return this.store(queueCache);\n  },\n\n  /**\n   * Removes Parse.Object data from queue.\n   *\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  async remove(queueId\n  /*: string*/\n  )\n  /*: Promise<void>*/\n  {\n    const queueData = await this.getQueue();\n    const index = this.queueItemExists(queueData, queueId);\n\n    if (index > -1) {\n      queueData.splice(index, 1);\n      await this.setQueue(queueData);\n    }\n  },\n\n  /**\n   * Removes all objects from queue.\n   *\n   * @function clear\n   * @name Parse.EventuallyQueue.clear\n   * @returns {Promise} A promise that is fulfilled when queue is cleared.\n   * @static\n   */\n  clear()\n  /*: Promise*/\n  {\n    queueCache = [];\n    return this.store([]);\n  },\n\n  /**\n   * Return the index of a queueId in the queue. Returns -1 if not found.\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {number}\n   * @static\n   * @ignore\n   */\n  queueItemExists(queue\n  /*: Queue*/\n  , queueId\n  /*: string*/\n  )\n  /*: number*/\n  {\n    return queue.findIndex(data => data.queueId === queueId);\n  },\n\n  /**\n   * Return the number of objects in the queue.\n   *\n   * @function length\n   * @name Parse.EventuallyQueue.length\n   * @returns {number}\n   * @static\n   */\n  async length()\n  /*: number*/\n  {\n    const queueData = await this.getQueue();\n    return queueData.length;\n  },\n\n  /**\n   * Sends the queue to the server.\n   *\n   * @function sendQueue\n   * @name Parse.EventuallyQueue.sendQueue\n   * @returns {Promise<boolean>} Returns true if queue was sent successfully.\n   * @static\n   */\n  async sendQueue()\n  /*: Promise<boolean>*/\n  {\n    const queue = await this.getQueue();\n    const queueData = [...queue];\n\n    if (queueData.length === 0) {\n      return false;\n    }\n\n    for (let i = 0; i < queueData.length; i += 1) {\n      const queueObject = queueData[i];\n      const {\n        id,\n        hash,\n        className\n      } = queueObject;\n\n      const ObjectType = _ParseObject.default.extend(className);\n\n      if (id) {\n        await this.process.byId(ObjectType, queueObject);\n      } else if (hash) {\n        await this.process.byHash(ObjectType, queueObject);\n      } else {\n        await this.process.create(ObjectType, queueObject);\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {ParseObject} object Parse.Object to be processed\n   * @param {QueueObject} queueObject Parse.Object data from the queue\n   * @returns {Promise} A promise that is fulfilled when operation is performed.\n   * @static\n   * @ignore\n   */\n  async sendQueueCallback(object\n  /*: ParseObject*/\n  , queueObject\n  /*: QueueObject*/\n  )\n  /*: Promise<void>*/\n  {\n    if (!object) {\n      return this.remove(queueObject.queueId);\n    }\n\n    switch (queueObject.action) {\n      case 'save':\n        // Queued update was overwritten by other request. Do not save\n        if (typeof object.updatedAt !== 'undefined' && object.updatedAt > new Date(queueObject.object.createdAt)) {\n          return this.remove(queueObject.queueId);\n        }\n\n        try {\n          await object.save(queueObject.object, queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.message !== 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n            await this.remove(queueObject.queueId);\n          }\n        }\n\n        break;\n\n      case 'destroy':\n        try {\n          await object.destroy(queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.message !== 'XMLHttpRequest failed: \"Unable to connect to the Parse API\"') {\n            await this.remove(queueObject.queueId);\n          }\n        }\n\n        break;\n    }\n  },\n\n  /**\n   * Start polling server for network connection.\n   * Will send queue if connection is established.\n   *\n   * @function poll\n   * @name Parse.EventuallyQueue.poll\n   * @param [ms] Milliseconds to ping the server. Default 2000ms\n   * @static\n   */\n  poll(ms\n  /*: number*/\n  = 2000) {\n    if (polling) {\n      return;\n    }\n\n    polling = setInterval(() => {\n      const RESTController = _CoreManager.default.getRESTController();\n\n      RESTController.request('GET', 'health').then(({\n        status\n      }) => {\n        if (status === 'ok') {\n          this.stopPoll();\n          return this.sendQueue();\n        }\n      }).catch(e => e);\n    }, ms);\n  },\n\n  /**\n   * Turns off polling.\n   *\n   * @function stopPoll\n   * @name Parse.EventuallyQueue.stopPoll\n   * @static\n   */\n  stopPoll() {\n    clearInterval(polling);\n    polling = undefined;\n  },\n\n  /**\n   * Return true if pinging the server.\n   *\n   * @function isPolling\n   * @name Parse.EventuallyQueue.isPolling\n   * @returns {boolean}\n   * @static\n   */\n  isPolling()\n  /*: boolean*/\n  {\n    return !!polling;\n  },\n\n  _setPolling(flag\n  /*: boolean*/\n  ) {\n    polling = flag;\n  },\n\n  process: {\n    create(ObjectType, queueObject) {\n      const object = new ObjectType();\n      return EventuallyQueue.sendQueueCallback(object, queueObject);\n    },\n\n    async byId(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('objectId', queueObject.id);\n      const results = await query.find({\n        sessionToken\n      });\n      return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n    },\n\n    async byHash(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('hash', queueObject.hash);\n      const results = await query.find({\n        sessionToken\n      });\n\n      if (results.length > 0) {\n        return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n      }\n\n      return EventuallyQueue.process.create(ObjectType, queueObject);\n    }\n\n  }\n};\nmodule.exports = EventuallyQueue;"]},"metadata":{},"sourceType":"script"}