{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Polygon with any of the following forms:<br>\n *   <pre>\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\n *   </pre>\n *\n * <p>Represents a coordinates that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Example:<pre>\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"area\", polygon);\n *   object.save();</pre></p>\n *\n * @alias Parse.Polygon\n */\n\n\nclass ParsePolygon {\n  /*:: _coordinates: Array<Array<number>>;*/\n\n  /**\n   * @param {(number[][] | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\n   */\n  constructor(coordinates\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n  /**\n   * Coordinates value for this Polygon.\n   * Throws an exception if not valid type.\n   *\n   * @property {(number[][] | Parse.GeoPoint[])} coordinates list of coordinates\n   * @returns {number[][]}\n   */\n\n\n  get coordinates()\n  /*: Array<Array<number>>*/\n  {\n    return this._coordinates;\n  }\n\n  set coordinates(coords\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    this._coordinates = ParsePolygon._validate(coords);\n  }\n  /**\n   * Returns a JSON representation of the Polygon, suitable for Parse.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: { __type: string, coordinates: Array<Array<number>> }*/\n  {\n    ParsePolygon._validate(this._coordinates);\n\n    return {\n      __type: 'Polygon',\n      coordinates: this._coordinates\n    };\n  }\n  /**\n   * Checks if two polygons are equal\n   *\n   * @param {(Parse.Polygon | object)} other\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n      return false;\n    }\n\n    let isEqual = true;\n\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\n        isEqual = false;\n        break;\n      }\n    }\n\n    return isEqual;\n  }\n  /**\n   *\n   * @param {Parse.GeoPoint} point\n   * @returns {boolean} Returns if the point is contained in the polygon\n   */\n\n\n  containsPoint(point\n  /*: ParseGeoPoint*/\n  )\n  /*: boolean*/\n  {\n    let minX = this._coordinates[0][0];\n    let maxX = this._coordinates[0][0];\n    let minY = this._coordinates[0][1];\n    let maxY = this._coordinates[0][1];\n\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      const p = this._coordinates[i];\n      minX = Math.min(p[0], minX);\n      maxX = Math.max(p[0], maxX);\n      minY = Math.min(p[1], minY);\n      maxY = Math.max(p[1], maxY);\n    }\n\n    const outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n\n    if (outside) {\n      return false;\n    }\n\n    let inside = false;\n\n    for (let i = 0, j = this._coordinates.length - 1; i < this._coordinates.length; j = i++) {\n      const startX = this._coordinates[i][0];\n      const startY = this._coordinates[i][1];\n      const endX = this._coordinates[j][0];\n      const endY = this._coordinates[j][1];\n      const intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n\n    return inside;\n  }\n  /**\n   * Validates that the list of coordinates can form a valid polygon\n   *\n   * @param {Array} coords the list of coordinates to validate as a polygon\n   * @throws {TypeError}\n   * @returns {number[][]} Array of coordinates if validated.\n   */\n\n\n  static _validate(coords\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  )\n  /*: Array<Array<number>>*/\n  {\n    if (!Array.isArray(coords)) {\n      throw new TypeError('Coordinates must be an Array');\n    }\n\n    if (coords.length < 3) {\n      throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n    }\n\n    const points = [];\n\n    for (let i = 0; i < coords.length; i += 1) {\n      const coord = coords[i];\n      let geoPoint;\n\n      if (coord instanceof _ParseGeoPoint.default) {\n        geoPoint = coord;\n      } else if (Array.isArray(coord) && coord.length === 2) {\n        geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n      } else {\n        throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n      }\n\n      points.push([geoPoint.latitude, geoPoint.longitude]);\n    }\n\n    return points;\n  }\n\n}\n\nvar _default = ParsePolygon;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParsePolygon.js"],"names":["Object","defineProperty","exports","value","default","_ParseGeoPoint","_interopRequireDefault","require","obj","__esModule","ParsePolygon","constructor","coordinates","_coordinates","_validate","coords","toJSON","__type","equals","other","length","isEqual","i","containsPoint","point","minX","maxX","minY","maxY","p","Math","min","max","outside","latitude","longitude","inside","j","startX","startY","endX","endY","intersect","Array","isArray","TypeError","points","coord","geoPoint","push","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Polygon with any of the following forms:<br>\n *   <pre>\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\n *   </pre>\n *\n * <p>Represents a coordinates that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Example:<pre>\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"area\", polygon);\n *   object.save();</pre></p>\n *\n * @alias Parse.Polygon\n */\n\n\nclass ParsePolygon {\n  /*:: _coordinates: Array<Array<number>>;*/\n\n  /**\n   * @param {(number[][] | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\n   */\n  constructor(coordinates\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n  /**\n   * Coordinates value for this Polygon.\n   * Throws an exception if not valid type.\n   *\n   * @property {(number[][] | Parse.GeoPoint[])} coordinates list of coordinates\n   * @returns {number[][]}\n   */\n\n\n  get coordinates()\n  /*: Array<Array<number>>*/\n  {\n    return this._coordinates;\n  }\n\n  set coordinates(coords\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  ) {\n    this._coordinates = ParsePolygon._validate(coords);\n  }\n  /**\n   * Returns a JSON representation of the Polygon, suitable for Parse.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: { __type: string, coordinates: Array<Array<number>> }*/\n  {\n    ParsePolygon._validate(this._coordinates);\n\n    return {\n      __type: 'Polygon',\n      coordinates: this._coordinates\n    };\n  }\n  /**\n   * Checks if two polygons are equal\n   *\n   * @param {(Parse.Polygon | object)} other\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n      return false;\n    }\n\n    let isEqual = true;\n\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\n        isEqual = false;\n        break;\n      }\n    }\n\n    return isEqual;\n  }\n  /**\n   *\n   * @param {Parse.GeoPoint} point\n   * @returns {boolean} Returns if the point is contained in the polygon\n   */\n\n\n  containsPoint(point\n  /*: ParseGeoPoint*/\n  )\n  /*: boolean*/\n  {\n    let minX = this._coordinates[0][0];\n    let maxX = this._coordinates[0][0];\n    let minY = this._coordinates[0][1];\n    let maxY = this._coordinates[0][1];\n\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      const p = this._coordinates[i];\n      minX = Math.min(p[0], minX);\n      maxX = Math.max(p[0], maxX);\n      minY = Math.min(p[1], minY);\n      maxY = Math.max(p[1], maxY);\n    }\n\n    const outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n\n    if (outside) {\n      return false;\n    }\n\n    let inside = false;\n\n    for (let i = 0, j = this._coordinates.length - 1; i < this._coordinates.length; j = i++) {\n      const startX = this._coordinates[i][0];\n      const startY = this._coordinates[i][1];\n      const endX = this._coordinates[j][0];\n      const endY = this._coordinates[j][1];\n      const intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n\n    return inside;\n  }\n  /**\n   * Validates that the list of coordinates can form a valid polygon\n   *\n   * @param {Array} coords the list of coordinates to validate as a polygon\n   * @throws {TypeError}\n   * @returns {number[][]} Array of coordinates if validated.\n   */\n\n\n  static _validate(coords\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\n  )\n  /*: Array<Array<number>>*/\n  {\n    if (!Array.isArray(coords)) {\n      throw new TypeError('Coordinates must be an Array');\n    }\n\n    if (coords.length < 3) {\n      throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n    }\n\n    const points = [];\n\n    for (let i = 0; i < coords.length; i += 1) {\n      const coord = coords[i];\n      let geoPoint;\n\n      if (coord instanceof _ParseGeoPoint.default) {\n        geoPoint = coord;\n      } else if (Array.isArray(coord) && coord.length === 2) {\n        geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n      } else {\n        throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n      }\n\n      points.push([geoPoint.latitude, geoPoint.longitude]);\n    }\n\n    return points;\n  }\n\n}\n\nvar _default = ParsePolygon;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}