{"ast":null,"code":"\"use strict\";\n\nconst equalObjects = require('./equals').default;\n\nconst decode = require('./decode').default;\n\nconst ParseError = require('./ParseError').default;\n\nconst ParsePolygon = require('./ParsePolygon').default;\n\nconst ParseGeoPoint = require('./ParseGeoPoint').default;\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n *\n * @param haystack\n * @param needle\n * @private\n * @returns {boolean}\n */\n\n\nfunction contains(haystack, needle) {\n  if (needle && needle.__type && (needle.__type === 'Pointer' || needle.__type === 'Object')) {\n    for (const i in haystack) {\n      const ptr = haystack[i];\n\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return haystack.indexOf(needle) > -1;\n}\n\nfunction transformObject(object) {\n  if (object._toFullJSON) {\n    return object._toFullJSON();\n  }\n\n  return object;\n}\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n *\n * @param className\n * @param object\n * @param objects\n * @param query\n * @private\n * @returns {boolean}\n */\n\n\nfunction matchesQuery(className, object, objects, query) {\n  if (object.className !== className) {\n    return false;\n  }\n\n  let obj = object;\n  let q = query;\n\n  if (object.toJSON) {\n    obj = object.toJSON();\n  }\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  obj.className = className;\n\n  for (const field in q) {\n    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return eqlFn(obj, compareTo);\n}\n/**\n * @typedef RelativeTimeToDateResult\n * @property {string} status The conversion status, `error` if conversion failed or\n * `success` if conversion succeeded.\n * @property {string} info The error message if conversion failed, or the relative\n * time indication (`past`, `present`, `future`) if conversion succeeded.\n * @property {Date|undefined} result The converted date, or `undefined` if conversion\n * failed.\n */\n\n/**\n * Converts human readable relative date string, for example, 'in 10 days' to a date\n * relative to now.\n *\n * @param {string} text The text to convert.\n * @param {Date} [now=new Date()] The date from which add or subtract. Default is now.\n * @returns {RelativeTimeToDateResult}\n */\n\n\nfunction relativeTimeToDate(text, now = new Date()) {\n  text = text.toLowerCase();\n  let parts = text.split(' '); // Filter out whitespace\n\n  parts = parts.filter(part => part !== '');\n  const future = parts[0] === 'in';\n  const past = parts[parts.length - 1] === 'ago';\n\n  if (!future && !past && text !== 'now') {\n    return {\n      status: 'error',\n      info: \"Time should either start with 'in' or end with 'ago'\"\n    };\n  }\n\n  if (future && past) {\n    return {\n      status: 'error',\n      info: \"Time cannot have both 'in' and 'ago'\"\n    };\n  } // strip the 'ago' or 'in'\n\n\n  if (future) {\n    parts = parts.slice(1);\n  } else {\n    // past\n    parts = parts.slice(0, parts.length - 1);\n  }\n\n  if (parts.length % 2 !== 0 && text !== 'now') {\n    return {\n      status: 'error',\n      info: 'Invalid time string. Dangling unit or number.'\n    };\n  }\n\n  const pairs = [];\n\n  while (parts.length) {\n    pairs.push([parts.shift(), parts.shift()]);\n  }\n\n  let seconds = 0;\n\n  for (const [num, interval] of pairs) {\n    const val = Number(num);\n\n    if (!Number.isInteger(val)) {\n      return {\n        status: 'error',\n        info: `'${num}' is not an integer.`\n      };\n    }\n\n    switch (interval) {\n      case 'yr':\n      case 'yrs':\n      case 'year':\n      case 'years':\n        seconds += val * 31536000; // 365 * 24 * 60 * 60\n\n        break;\n\n      case 'wk':\n      case 'wks':\n      case 'week':\n      case 'weeks':\n        seconds += val * 604800; // 7 * 24 * 60 * 60\n\n        break;\n\n      case 'd':\n      case 'day':\n      case 'days':\n        seconds += val * 86400; // 24 * 60 * 60\n\n        break;\n\n      case 'hr':\n      case 'hrs':\n      case 'hour':\n      case 'hours':\n        seconds += val * 3600; // 60 * 60\n\n        break;\n\n      case 'min':\n      case 'mins':\n      case 'minute':\n      case 'minutes':\n        seconds += val * 60;\n        break;\n\n      case 'sec':\n      case 'secs':\n      case 'second':\n      case 'seconds':\n        seconds += val;\n        break;\n\n      default:\n        return {\n          status: 'error',\n          info: `Invalid interval: '${interval}'`\n        };\n    }\n  }\n\n  const milliseconds = seconds * 1000;\n\n  if (future) {\n    return {\n      status: 'success',\n      info: 'future',\n      result: new Date(now.valueOf() + milliseconds)\n    };\n  } else if (past) {\n    return {\n      status: 'success',\n      info: 'past',\n      result: new Date(now.valueOf() - milliseconds)\n    };\n  } else {\n    return {\n      status: 'success',\n      info: 'present',\n      result: new Date(now.valueOf())\n    };\n  }\n}\n/**\n * Determines whether an object matches a single key's constraints\n *\n * @param className\n * @param object\n * @param objects\n * @param key\n * @param constraints\n * @private\n * @returns {boolean}\n */\n\n\nfunction matchesKeyConstraints(className, object, objects, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n\n  if (key.indexOf('.') >= 0) {\n    // Key references a subobject\n    const keyComponents = key.split('.');\n    const subObjectKey = keyComponents[0];\n    const keyRemainder = keyComponents.slice(1).join('.');\n    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);\n  }\n\n  let i;\n\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n    throw new ParseError(ParseError.INVALID_KEY_NAME, `Invalid Key: ${key}`);\n  } // Equality (or Array contains) cases\n\n\n  if (typeof constraints !== 'object') {\n    if (Array.isArray(object[key])) {\n      return object[key].indexOf(constraints) > -1;\n    }\n\n    return object[key] === constraints;\n  }\n\n  let compareTo;\n\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n\n    return equalObjectsGeneric(decode(object[key]), decode(constraints), equalObjects);\n  } // More complex cases\n\n\n  for (const condition in constraints) {\n    compareTo = constraints[condition];\n\n    if (compareTo.__type) {\n      compareTo = decode(compareTo);\n    } // is it a $relativeTime? convert to date\n\n\n    if (compareTo['$relativeTime']) {\n      const parserResult = relativeTimeToDate(compareTo['$relativeTime']);\n\n      if (parserResult.status !== 'success') {\n        throw new ParseError(ParseError.INVALID_JSON, `bad $relativeTime (${key}) value. ${parserResult.info}`);\n      }\n\n      compareTo = parserResult.result;\n    } // Compare Date Object or Date String\n\n\n    if (toString.call(compareTo) === '[object Date]' || typeof compareTo === 'string' && new Date(compareTo) !== 'Invalid Date' && !isNaN(new Date(compareTo))) {\n      object[key] = new Date(object[key].iso ? object[key].iso : object[key]);\n    }\n\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$ne':\n        if (equalObjects(object[key], compareTo)) {\n          return false;\n        }\n\n        break;\n\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          if (object[key].indexOf(compareTo[i]) < 0) {\n            return false;\n          }\n        }\n\n        break;\n\n      case '$exists':\n        {\n          const propertyExists = typeof object[key] !== 'undefined';\n          const existenceIsRequired = constraints['$exists'];\n\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$regex':\n        {\n          if (typeof compareTo === 'object') {\n            return compareTo.test(object[key]);\n          } // JS doesn't support perl-style escaping\n\n\n          let expString = '';\n          let escapeEnd = -2;\n          let escapeStart = compareTo.indexOf('\\\\Q');\n\n          while (escapeStart > -1) {\n            // Add the unescaped portion\n            expString += compareTo.substring(escapeEnd + 2, escapeStart);\n            escapeEnd = compareTo.indexOf('\\\\E', escapeStart);\n\n            if (escapeEnd > -1) {\n              expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n            }\n\n            escapeStart = compareTo.indexOf('\\\\Q', escapeEnd);\n          }\n\n          expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n          let modifiers = constraints.$options || '';\n          modifiers = modifiers.replace('x', '').replace('s', ''); // Parse Server / Mongo support x and s modifiers but JS RegExp doesn't\n\n          const exp = new RegExp(expString, modifiers);\n\n          if (!exp.test(object[key])) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$nearSphere':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          const distance = compareTo.radiansTo(object[key]);\n          const max = constraints.$maxDistance || Infinity;\n          return distance <= max;\n        }\n\n      case '$within':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          const southWest = compareTo.$box[0];\n          const northEast = compareTo.$box[1];\n\n          if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n            // Invalid box, crosses the date line\n            return false;\n          }\n\n          return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n        }\n\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n\n      case '$select':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return equalObjects(object[key], subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$dontSelect':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return !equalObjects(object[key], subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$inQuery':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n      case '$notInQuery':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n      case '$containedBy':\n        {\n          for (const value of object[key]) {\n            if (!contains(compareTo, value)) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n      case '$geoWithin':\n        {\n          const points = compareTo.$polygon.map(geoPoint => [geoPoint.latitude, geoPoint.longitude]);\n          const polygon = new ParsePolygon(points);\n          return polygon.containsPoint(object[key]);\n        }\n\n      case '$geoIntersects':\n        {\n          const polygon = new ParsePolygon(object[key].coordinates);\n          const point = new ParseGeoPoint(compareTo.$point);\n          return polygon.containsPoint(point);\n        }\n\n      default:\n        return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateQuery(query\n/*: any*/\n) {\n  let q = query;\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  const specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n  Object.keys(q).forEach(key => {\n    if (q && q[key] && q[key].$regex) {\n      if (typeof q[key].$options === 'string') {\n        if (!q[key].$options.match(/^[imxs]+$/)) {\n          throw new ParseError(ParseError.INVALID_QUERY, `Bad $options value for query: ${q[key].$options}`);\n        }\n      }\n    }\n\n    if (specialQuerykeys.indexOf(key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new ParseError(ParseError.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n}\n\nconst OfflineQuery = {\n  matchesQuery: matchesQuery,\n  validateQuery: validateQuery\n};\nmodule.exports = OfflineQuery;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/OfflineQuery.js"],"names":["equalObjects","require","default","decode","ParseError","ParsePolygon","ParseGeoPoint","contains","haystack","needle","__type","i","ptr","objectId","className","indexOf","transformObject","object","_toFullJSON","matchesQuery","objects","query","obj","q","toJSON","where","field","matchesKeyConstraints","equalObjectsGeneric","compareTo","eqlFn","Array","isArray","length","relativeTimeToDate","text","now","Date","toLowerCase","parts","split","filter","part","future","past","status","info","slice","pairs","push","shift","seconds","num","interval","val","Number","isInteger","milliseconds","result","valueOf","key","constraints","keyComponents","subObjectKey","keyRemainder","join","test","INVALID_KEY_NAME","condition","parserResult","INVALID_JSON","toString","call","isNaN","iso","propertyExists","existenceIsRequired","expString","escapeEnd","escapeStart","substring","replace","Math","max","modifiers","$options","exp","RegExp","distance","radiansTo","$maxDistance","Infinity","southWest","$box","northEast","latitude","longitude","subQueryObjects","index","arr","subObject","value","points","$polygon","map","geoPoint","polygon","containsPoint","coordinates","point","$point","validateQuery","specialQuerykeys","Object","keys","forEach","$regex","match","INVALID_QUERY","OfflineQuery","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst equalObjects = require('./equals').default;\n\nconst decode = require('./decode').default;\n\nconst ParseError = require('./ParseError').default;\n\nconst ParsePolygon = require('./ParsePolygon').default;\n\nconst ParseGeoPoint = require('./ParseGeoPoint').default;\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n *\n * @param haystack\n * @param needle\n * @private\n * @returns {boolean}\n */\n\n\nfunction contains(haystack, needle) {\n  if (needle && needle.__type && (needle.__type === 'Pointer' || needle.__type === 'Object')) {\n    for (const i in haystack) {\n      const ptr = haystack[i];\n\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return haystack.indexOf(needle) > -1;\n}\n\nfunction transformObject(object) {\n  if (object._toFullJSON) {\n    return object._toFullJSON();\n  }\n\n  return object;\n}\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n *\n * @param className\n * @param object\n * @param objects\n * @param query\n * @private\n * @returns {boolean}\n */\n\n\nfunction matchesQuery(className, object, objects, query) {\n  if (object.className !== className) {\n    return false;\n  }\n\n  let obj = object;\n  let q = query;\n\n  if (object.toJSON) {\n    obj = object.toJSON();\n  }\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  obj.className = className;\n\n  for (const field in q) {\n    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return eqlFn(obj, compareTo);\n}\n/**\n * @typedef RelativeTimeToDateResult\n * @property {string} status The conversion status, `error` if conversion failed or\n * `success` if conversion succeeded.\n * @property {string} info The error message if conversion failed, or the relative\n * time indication (`past`, `present`, `future`) if conversion succeeded.\n * @property {Date|undefined} result The converted date, or `undefined` if conversion\n * failed.\n */\n\n/**\n * Converts human readable relative date string, for example, 'in 10 days' to a date\n * relative to now.\n *\n * @param {string} text The text to convert.\n * @param {Date} [now=new Date()] The date from which add or subtract. Default is now.\n * @returns {RelativeTimeToDateResult}\n */\n\n\nfunction relativeTimeToDate(text, now = new Date()) {\n  text = text.toLowerCase();\n  let parts = text.split(' '); // Filter out whitespace\n\n  parts = parts.filter(part => part !== '');\n  const future = parts[0] === 'in';\n  const past = parts[parts.length - 1] === 'ago';\n\n  if (!future && !past && text !== 'now') {\n    return {\n      status: 'error',\n      info: \"Time should either start with 'in' or end with 'ago'\"\n    };\n  }\n\n  if (future && past) {\n    return {\n      status: 'error',\n      info: \"Time cannot have both 'in' and 'ago'\"\n    };\n  } // strip the 'ago' or 'in'\n\n\n  if (future) {\n    parts = parts.slice(1);\n  } else {\n    // past\n    parts = parts.slice(0, parts.length - 1);\n  }\n\n  if (parts.length % 2 !== 0 && text !== 'now') {\n    return {\n      status: 'error',\n      info: 'Invalid time string. Dangling unit or number.'\n    };\n  }\n\n  const pairs = [];\n\n  while (parts.length) {\n    pairs.push([parts.shift(), parts.shift()]);\n  }\n\n  let seconds = 0;\n\n  for (const [num, interval] of pairs) {\n    const val = Number(num);\n\n    if (!Number.isInteger(val)) {\n      return {\n        status: 'error',\n        info: `'${num}' is not an integer.`\n      };\n    }\n\n    switch (interval) {\n      case 'yr':\n      case 'yrs':\n      case 'year':\n      case 'years':\n        seconds += val * 31536000; // 365 * 24 * 60 * 60\n\n        break;\n\n      case 'wk':\n      case 'wks':\n      case 'week':\n      case 'weeks':\n        seconds += val * 604800; // 7 * 24 * 60 * 60\n\n        break;\n\n      case 'd':\n      case 'day':\n      case 'days':\n        seconds += val * 86400; // 24 * 60 * 60\n\n        break;\n\n      case 'hr':\n      case 'hrs':\n      case 'hour':\n      case 'hours':\n        seconds += val * 3600; // 60 * 60\n\n        break;\n\n      case 'min':\n      case 'mins':\n      case 'minute':\n      case 'minutes':\n        seconds += val * 60;\n        break;\n\n      case 'sec':\n      case 'secs':\n      case 'second':\n      case 'seconds':\n        seconds += val;\n        break;\n\n      default:\n        return {\n          status: 'error',\n          info: `Invalid interval: '${interval}'`\n        };\n    }\n  }\n\n  const milliseconds = seconds * 1000;\n\n  if (future) {\n    return {\n      status: 'success',\n      info: 'future',\n      result: new Date(now.valueOf() + milliseconds)\n    };\n  } else if (past) {\n    return {\n      status: 'success',\n      info: 'past',\n      result: new Date(now.valueOf() - milliseconds)\n    };\n  } else {\n    return {\n      status: 'success',\n      info: 'present',\n      result: new Date(now.valueOf())\n    };\n  }\n}\n/**\n * Determines whether an object matches a single key's constraints\n *\n * @param className\n * @param object\n * @param objects\n * @param key\n * @param constraints\n * @private\n * @returns {boolean}\n */\n\n\nfunction matchesKeyConstraints(className, object, objects, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n\n  if (key.indexOf('.') >= 0) {\n    // Key references a subobject\n    const keyComponents = key.split('.');\n    const subObjectKey = keyComponents[0];\n    const keyRemainder = keyComponents.slice(1).join('.');\n    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);\n  }\n\n  let i;\n\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n    throw new ParseError(ParseError.INVALID_KEY_NAME, `Invalid Key: ${key}`);\n  } // Equality (or Array contains) cases\n\n\n  if (typeof constraints !== 'object') {\n    if (Array.isArray(object[key])) {\n      return object[key].indexOf(constraints) > -1;\n    }\n\n    return object[key] === constraints;\n  }\n\n  let compareTo;\n\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n\n    return equalObjectsGeneric(decode(object[key]), decode(constraints), equalObjects);\n  } // More complex cases\n\n\n  for (const condition in constraints) {\n    compareTo = constraints[condition];\n\n    if (compareTo.__type) {\n      compareTo = decode(compareTo);\n    } // is it a $relativeTime? convert to date\n\n\n    if (compareTo['$relativeTime']) {\n      const parserResult = relativeTimeToDate(compareTo['$relativeTime']);\n\n      if (parserResult.status !== 'success') {\n        throw new ParseError(ParseError.INVALID_JSON, `bad $relativeTime (${key}) value. ${parserResult.info}`);\n      }\n\n      compareTo = parserResult.result;\n    } // Compare Date Object or Date String\n\n\n    if (toString.call(compareTo) === '[object Date]' || typeof compareTo === 'string' && new Date(compareTo) !== 'Invalid Date' && !isNaN(new Date(compareTo))) {\n      object[key] = new Date(object[key].iso ? object[key].iso : object[key]);\n    }\n\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$ne':\n        if (equalObjects(object[key], compareTo)) {\n          return false;\n        }\n\n        break;\n\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          if (object[key].indexOf(compareTo[i]) < 0) {\n            return false;\n          }\n        }\n\n        break;\n\n      case '$exists':\n        {\n          const propertyExists = typeof object[key] !== 'undefined';\n          const existenceIsRequired = constraints['$exists'];\n\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$regex':\n        {\n          if (typeof compareTo === 'object') {\n            return compareTo.test(object[key]);\n          } // JS doesn't support perl-style escaping\n\n\n          let expString = '';\n          let escapeEnd = -2;\n          let escapeStart = compareTo.indexOf('\\\\Q');\n\n          while (escapeStart > -1) {\n            // Add the unescaped portion\n            expString += compareTo.substring(escapeEnd + 2, escapeStart);\n            escapeEnd = compareTo.indexOf('\\\\E', escapeStart);\n\n            if (escapeEnd > -1) {\n              expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n            }\n\n            escapeStart = compareTo.indexOf('\\\\Q', escapeEnd);\n          }\n\n          expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n          let modifiers = constraints.$options || '';\n          modifiers = modifiers.replace('x', '').replace('s', ''); // Parse Server / Mongo support x and s modifiers but JS RegExp doesn't\n\n          const exp = new RegExp(expString, modifiers);\n\n          if (!exp.test(object[key])) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$nearSphere':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          const distance = compareTo.radiansTo(object[key]);\n          const max = constraints.$maxDistance || Infinity;\n          return distance <= max;\n        }\n\n      case '$within':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          const southWest = compareTo.$box[0];\n          const northEast = compareTo.$box[1];\n\n          if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n            // Invalid box, crosses the date line\n            return false;\n          }\n\n          return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n        }\n\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n\n      case '$select':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return equalObjects(object[key], subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$dontSelect':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return !equalObjects(object[key], subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$inQuery':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n      case '$notInQuery':\n        {\n          const subQueryObjects = objects.filter((obj, index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n      case '$containedBy':\n        {\n          for (const value of object[key]) {\n            if (!contains(compareTo, value)) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n      case '$geoWithin':\n        {\n          const points = compareTo.$polygon.map(geoPoint => [geoPoint.latitude, geoPoint.longitude]);\n          const polygon = new ParsePolygon(points);\n          return polygon.containsPoint(object[key]);\n        }\n\n      case '$geoIntersects':\n        {\n          const polygon = new ParsePolygon(object[key].coordinates);\n          const point = new ParseGeoPoint(compareTo.$point);\n          return polygon.containsPoint(point);\n        }\n\n      default:\n        return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateQuery(query\n/*: any*/\n) {\n  let q = query;\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  const specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n  Object.keys(q).forEach(key => {\n    if (q && q[key] && q[key].$regex) {\n      if (typeof q[key].$options === 'string') {\n        if (!q[key].$options.match(/^[imxs]+$/)) {\n          throw new ParseError(ParseError.INVALID_QUERY, `Bad $options value for query: ${q[key].$options}`);\n        }\n      }\n    }\n\n    if (specialQuerykeys.indexOf(key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new ParseError(ParseError.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n}\n\nconst OfflineQuery = {\n  matchesQuery: matchesQuery,\n  validateQuery: validateQuery\n};\nmodule.exports = OfflineQuery;"]},"metadata":{},"sourceType":"script"}