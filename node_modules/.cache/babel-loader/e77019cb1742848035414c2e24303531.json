{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Relation for the given parent object and key. This\n * constructor should rarely be used directly, but rather created by\n * Parse.Object.relation.\n *\n * <p>\n * A class that is used to access all of the children of a many-to-many\n * relationship.  Each instance of Parse.Relation is associated with a\n * particular parent object and key.\n * </p>\n *\n * @alias Parse.Relation\n */\n\n\nclass ParseRelation {\n  /*:: parent: ?ParseObject;*/\n\n  /*:: key: ?string;*/\n\n  /*:: targetClassName: ?string;*/\n\n  /**\n   * @param {Parse.Object} parent The parent of this relation.\n   * @param {string} key The key for this relation on the parent.\n   */\n  constructor(parent\n  /*: ?ParseObject*/\n  , key\n  /*: ?string*/\n  ) {\n    this.parent = parent;\n    this.key = key;\n    this.targetClassName = null;\n  }\n  /*\n   * Makes sure that this relation has the right parent and key.\n   */\n\n\n  _ensureParentAndKey(parent\n  /*: ParseObject*/\n  , key\n  /*: string*/\n  ) {\n    this.key = this.key || key;\n\n    if (this.key !== key) {\n      throw new Error('Internal Error. Relation retrieved from two different keys.');\n    }\n\n    if (this.parent) {\n      if (this.parent.className !== parent.className) {\n        throw new Error('Internal Error. Relation retrieved from two different Objects.');\n      }\n\n      if (this.parent.id) {\n        if (this.parent.id !== parent.id) {\n          throw new Error('Internal Error. Relation retrieved from two different Objects.');\n        }\n      } else if (parent.id) {\n        this.parent = parent;\n      }\n    } else {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Adds a Parse.Object or an array of Parse.Objects to the relation.\n   *\n   * @param {(Parse.Object|Array)} objects The item or items to add.\n   * @returns {Parse.Object} The parent of the relation.\n   */\n\n\n  add(objects\n  /*: ParseObject | Array<ParseObject | string>*/\n  )\n  /*: ParseObject*/\n  {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n\n    const change = new _ParseOp.RelationOp(objects, []);\n    const parent = this.parent;\n\n    if (!parent) {\n      throw new Error('Cannot add to a Relation without a parent');\n    }\n\n    if (objects.length === 0) {\n      return parent;\n    }\n\n    parent.set(this.key, change);\n    this.targetClassName = change._targetClassName;\n    return parent;\n  }\n  /**\n   * Removes a Parse.Object or an array of Parse.Objects from this relation.\n   *\n   * @param {(Parse.Object|Array)} objects The item or items to remove.\n   */\n\n\n  remove(objects\n  /*: ParseObject | Array<ParseObject | string>*/\n  ) {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n\n    const change = new _ParseOp.RelationOp([], objects);\n\n    if (!this.parent) {\n      throw new Error('Cannot remove from a Relation without a parent');\n    }\n\n    if (objects.length === 0) {\n      return;\n    }\n\n    this.parent.set(this.key, change);\n    this.targetClassName = change._targetClassName;\n  }\n  /**\n   * Returns a JSON version of the object suitable for saving to disk.\n   *\n   * @returns {object} JSON representation of Relation\n   */\n\n\n  toJSON()\n  /*: { __type: 'Relation', className: ?string }*/\n  {\n    return {\n      __type: 'Relation',\n      className: this.targetClassName\n    };\n  }\n  /**\n   * Returns a Parse.Query that is limited to objects in this\n   * relation.\n   *\n   * @returns {Parse.Query} Relation Query\n   */\n\n\n  query()\n  /*: ParseQuery*/\n  {\n    let query;\n    const parent = this.parent;\n\n    if (!parent) {\n      throw new Error('Cannot construct a query for a Relation without a parent');\n    }\n\n    if (!this.targetClassName) {\n      query = new _ParseQuery.default(parent.className);\n      query._extraOptions.redirectClassNameForKey = this.key;\n    } else {\n      query = new _ParseQuery.default(this.targetClassName);\n    }\n\n    query._addCondition('$relatedTo', 'object', {\n      __type: 'Pointer',\n      className: parent.className,\n      objectId: parent.id\n    });\n\n    query._addCondition('$relatedTo', 'key', this.key);\n\n    return query;\n  }\n\n}\n\nvar _default = ParseRelation;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseRelation.js"],"names":["Object","defineProperty","exports","value","default","_ParseOp","require","_ParseObject","_interopRequireDefault","_ParseQuery","obj","__esModule","ParseRelation","constructor","parent","key","targetClassName","_ensureParentAndKey","Error","className","id","add","objects","Array","isArray","change","RelationOp","length","set","_targetClassName","remove","toJSON","__type","query","_extraOptions","redirectClassNameForKey","_addCondition","objectId","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseOp = require(\"./ParseOp\");\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new Relation for the given parent object and key. This\n * constructor should rarely be used directly, but rather created by\n * Parse.Object.relation.\n *\n * <p>\n * A class that is used to access all of the children of a many-to-many\n * relationship.  Each instance of Parse.Relation is associated with a\n * particular parent object and key.\n * </p>\n *\n * @alias Parse.Relation\n */\n\n\nclass ParseRelation {\n  /*:: parent: ?ParseObject;*/\n\n  /*:: key: ?string;*/\n\n  /*:: targetClassName: ?string;*/\n\n  /**\n   * @param {Parse.Object} parent The parent of this relation.\n   * @param {string} key The key for this relation on the parent.\n   */\n  constructor(parent\n  /*: ?ParseObject*/\n  , key\n  /*: ?string*/\n  ) {\n    this.parent = parent;\n    this.key = key;\n    this.targetClassName = null;\n  }\n  /*\n   * Makes sure that this relation has the right parent and key.\n   */\n\n\n  _ensureParentAndKey(parent\n  /*: ParseObject*/\n  , key\n  /*: string*/\n  ) {\n    this.key = this.key || key;\n\n    if (this.key !== key) {\n      throw new Error('Internal Error. Relation retrieved from two different keys.');\n    }\n\n    if (this.parent) {\n      if (this.parent.className !== parent.className) {\n        throw new Error('Internal Error. Relation retrieved from two different Objects.');\n      }\n\n      if (this.parent.id) {\n        if (this.parent.id !== parent.id) {\n          throw new Error('Internal Error. Relation retrieved from two different Objects.');\n        }\n      } else if (parent.id) {\n        this.parent = parent;\n      }\n    } else {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Adds a Parse.Object or an array of Parse.Objects to the relation.\n   *\n   * @param {(Parse.Object|Array)} objects The item or items to add.\n   * @returns {Parse.Object} The parent of the relation.\n   */\n\n\n  add(objects\n  /*: ParseObject | Array<ParseObject | string>*/\n  )\n  /*: ParseObject*/\n  {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n\n    const change = new _ParseOp.RelationOp(objects, []);\n    const parent = this.parent;\n\n    if (!parent) {\n      throw new Error('Cannot add to a Relation without a parent');\n    }\n\n    if (objects.length === 0) {\n      return parent;\n    }\n\n    parent.set(this.key, change);\n    this.targetClassName = change._targetClassName;\n    return parent;\n  }\n  /**\n   * Removes a Parse.Object or an array of Parse.Objects from this relation.\n   *\n   * @param {(Parse.Object|Array)} objects The item or items to remove.\n   */\n\n\n  remove(objects\n  /*: ParseObject | Array<ParseObject | string>*/\n  ) {\n    if (!Array.isArray(objects)) {\n      objects = [objects];\n    }\n\n    const change = new _ParseOp.RelationOp([], objects);\n\n    if (!this.parent) {\n      throw new Error('Cannot remove from a Relation without a parent');\n    }\n\n    if (objects.length === 0) {\n      return;\n    }\n\n    this.parent.set(this.key, change);\n    this.targetClassName = change._targetClassName;\n  }\n  /**\n   * Returns a JSON version of the object suitable for saving to disk.\n   *\n   * @returns {object} JSON representation of Relation\n   */\n\n\n  toJSON()\n  /*: { __type: 'Relation', className: ?string }*/\n  {\n    return {\n      __type: 'Relation',\n      className: this.targetClassName\n    };\n  }\n  /**\n   * Returns a Parse.Query that is limited to objects in this\n   * relation.\n   *\n   * @returns {Parse.Query} Relation Query\n   */\n\n\n  query()\n  /*: ParseQuery*/\n  {\n    let query;\n    const parent = this.parent;\n\n    if (!parent) {\n      throw new Error('Cannot construct a query for a Relation without a parent');\n    }\n\n    if (!this.targetClassName) {\n      query = new _ParseQuery.default(parent.className);\n      query._extraOptions.redirectClassNameForKey = this.key;\n    } else {\n      query = new _ParseQuery.default(this.targetClassName);\n    }\n\n    query._addCondition('$relatedTo', 'object', {\n      __type: 'Pointer',\n      className: parent.className,\n      objectId: parent.id\n    });\n\n    query._addCondition('$relatedTo', 'key', this.key);\n\n    return query;\n  }\n\n}\n\nvar _default = ParseRelation;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}