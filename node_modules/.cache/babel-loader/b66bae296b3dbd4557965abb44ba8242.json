{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _EventEmitter = _interopRequireDefault(require(\"./EventEmitter\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _LiveQuerySubscription = _interopRequireDefault(require(\"./LiveQuerySubscription\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n/* global WebSocket */\n// The LiveQuery client inner state\n\n\nconst CLIENT_STATE = {\n  INITIALIZED: 'initialized',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  CLOSED: 'closed',\n  RECONNECTING: 'reconnecting',\n  DISCONNECTED: 'disconnected'\n}; // The event type the LiveQuery client should sent to server\n\nconst OP_TYPES = {\n  CONNECT: 'connect',\n  SUBSCRIBE: 'subscribe',\n  UNSUBSCRIBE: 'unsubscribe',\n  ERROR: 'error'\n}; // The event we get back from LiveQuery server\n\nconst OP_EVENTS = {\n  CONNECTED: 'connected',\n  SUBSCRIBED: 'subscribed',\n  UNSUBSCRIBED: 'unsubscribed',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete'\n}; // The event the LiveQuery client should emit\n\nconst CLIENT_EMMITER_TYPES = {\n  CLOSE: 'close',\n  ERROR: 'error',\n  OPEN: 'open'\n}; // The event the LiveQuery subscription should emit\n\nconst SUBSCRIPTION_EMMITER_TYPES = {\n  OPEN: 'open',\n  CLOSE: 'close',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete'\n};\n\nconst generateInterval = k => {\n  return Math.random() * Math.min(30, Math.pow(2, k) - 1) * 1000;\n};\n/**\n * Creates a new LiveQueryClient.\n * Extends events.EventEmitter\n * <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\">cloud functions</a>.\n *\n * A wrapper of a standard WebSocket client. We add several useful methods to\n * help you connect/disconnect to LiveQueryServer, subscribe/unsubscribe a ParseQuery easily.\n *\n * javascriptKey and masterKey are used for verifying the LiveQueryClient when it tries\n * to connect to the LiveQuery server\n *\n * We expose three events to help you monitor the status of the LiveQueryClient.\n *\n * <pre>\n * let Parse = require('parse/node');\n * let LiveQueryClient = Parse.LiveQueryClient;\n * let client = new LiveQueryClient({\n *   applicationId: '',\n *   serverURL: '',\n *   javascriptKey: '',\n *   masterKey: ''\n *  });\n * </pre>\n *\n * Open - When we establish the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('open', () => {\n *\n * });</pre>\n *\n * Close - When we lose the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('close', () => {\n *\n * });</pre>\n *\n * Error - When some network error or LiveQuery server error happens, you'll get this event.\n * <pre>\n * client.on('error', (error) => {\n *\n * });</pre>\n *\n * @alias Parse.LiveQueryClient\n */\n\n\nclass LiveQueryClient extends _EventEmitter.default {\n  /*:: attempts: number;*/\n\n  /*:: id: number;*/\n\n  /*:: requestId: number;*/\n\n  /*:: applicationId: string;*/\n\n  /*:: serverURL: string;*/\n\n  /*:: javascriptKey: ?string;*/\n\n  /*:: masterKey: ?string;*/\n\n  /*:: sessionToken: ?string;*/\n\n  /*:: installationId: ?string;*/\n\n  /*:: additionalProperties: boolean;*/\n\n  /*:: connectPromise: Promise;*/\n\n  /*:: subscriptions: Map;*/\n\n  /*:: socket: any;*/\n\n  /*:: state: string;*/\n\n  /**\n   * @param {object} options\n   * @param {string} options.applicationId - applicationId of your Parse app\n   * @param {string} options.serverURL - <b>the URL of your LiveQuery server</b>\n   * @param {string} options.javascriptKey (optional)\n   * @param {string} options.masterKey (optional) Your Parse Master Key. (Node.js only!)\n   * @param {string} options.sessionToken (optional)\n   * @param {string} options.installationId (optional)\n   */\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId\n  }) {\n    super();\n\n    if (!serverURL || serverURL.indexOf('ws') !== 0) {\n      throw new Error('You need to set a proper Parse LiveQuery server url before using LiveQueryClient');\n    }\n\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new Map();\n    this.state = CLIENT_STATE.INITIALIZED; // adding listener so process does not crash\n    // best practice is for developer to register their own listener\n\n    this.on('error', () => {});\n  }\n\n  shouldOpen()\n  /*: any*/\n  {\n    return this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED;\n  }\n  /**\n   * Subscribes to a ParseQuery\n   *\n   * If you provide the sessionToken, when the LiveQuery server gets ParseObject's\n   * updates from parse server, it'll try to check whether the sessionToken fulfills\n   * the ParseObject's ACL. The LiveQuery server will only send updates to clients whose\n   * sessionToken is fit for the ParseObject's ACL. You can check the LiveQuery protocol\n   * <a href=\"https://github.com/parse-community/parse-server/wiki/Parse-LiveQuery-Protocol-Specification\">here</a> for more details. The subscription you get is the same subscription you get\n   * from our Standard API.\n   *\n   * @param {object} query - the ParseQuery you want to subscribe to\n   * @param {string} sessionToken (optional)\n   * @returns {LiveQuerySubscription} subscription\n   */\n\n\n  subscribe(query\n  /*: Object*/\n  , sessionToken\n  /*: ?string*/\n  )\n  /*: LiveQuerySubscription*/\n  {\n    if (!query) {\n      return;\n    }\n\n    const className = query.className;\n    const queryJSON = query.toJSON();\n    const where = queryJSON.where;\n    const fields = queryJSON.keys ? queryJSON.keys.split(',') : undefined;\n    const subscribeRequest = {\n      op: OP_TYPES.SUBSCRIBE,\n      requestId: this.requestId,\n      query: {\n        className,\n        where,\n        fields\n      }\n    };\n\n    if (sessionToken) {\n      subscribeRequest.sessionToken = sessionToken;\n    }\n\n    const subscription = new _LiveQuerySubscription.default(this.requestId, query, sessionToken);\n    this.subscriptions.set(this.requestId, subscription);\n    this.requestId += 1;\n    this.connectPromise.then(() => {\n      this.socket.send(JSON.stringify(subscribeRequest));\n    });\n    return subscription;\n  }\n  /**\n   * After calling unsubscribe you'll stop receiving events from the subscription object.\n   *\n   * @param {object} subscription - subscription you would like to unsubscribe from.\n   */\n\n\n  unsubscribe(subscription\n  /*: Object*/\n  ) {\n    if (!subscription) {\n      return;\n    }\n\n    this.subscriptions.delete(subscription.id);\n    const unsubscribeRequest = {\n      op: OP_TYPES.UNSUBSCRIBE,\n      requestId: subscription.id\n    };\n    this.connectPromise.then(() => {\n      this.socket.send(JSON.stringify(unsubscribeRequest));\n    });\n  }\n  /**\n   * After open is called, the LiveQueryClient will try to send a connect request\n   * to the LiveQuery server.\n   *\n   */\n\n\n  open() {\n    const WebSocketImplementation = _CoreManager.default.getWebSocketController();\n\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n\n    this.socket = new WebSocketImplementation(this.serverURL); // Bind WebSocket callbacks\n\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n\n    this.socket.onclose = () => {\n      this._handleWebSocketClose();\n    };\n\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n\n  resubscribe() {\n    this.subscriptions.forEach((subscription, requestId) => {\n      const query = subscription.query;\n      const queryJSON = query.toJSON();\n      const where = queryJSON.where;\n      const fields = queryJSON.keys ? queryJSON.keys.split(',') : undefined;\n      const className = query.className;\n      const sessionToken = subscription.sessionToken;\n      const subscribeRequest = {\n        op: OP_TYPES.SUBSCRIBE,\n        requestId,\n        query: {\n          className,\n          where,\n          fields\n        }\n      };\n\n      if (sessionToken) {\n        subscribeRequest.sessionToken = sessionToken;\n      }\n\n      this.connectPromise.then(() => {\n        this.socket.send(JSON.stringify(subscribeRequest));\n      });\n    });\n  }\n  /**\n   * This method will close the WebSocket connection to this LiveQueryClient,\n   * cancel the auto reconnect and unsubscribe all subscriptions based on it.\n   *\n   */\n\n\n  close() {\n    if (this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n\n    this.state = CLIENT_STATE.DISCONNECTED;\n    this.socket.close(); // Notify each subscription about the close\n\n    for (const subscription of this.subscriptions.values()) {\n      subscription.subscribed = false;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n\n    this._handleReset();\n\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n  } // ensure we start with valid state if connect is called again after close\n\n\n  _handleReset() {\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new Map();\n  }\n\n  _handleWebSocketOpen() {\n    this.attempts = 1;\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken\n    };\n\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n\n    this.socket.send(JSON.stringify(connectRequest));\n  }\n\n  _handleWebSocketMessage(event\n  /*: any*/\n  ) {\n    let data = event.data;\n\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n\n    let subscription = null;\n\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId);\n    }\n\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId\n    };\n\n    switch (data.op) {\n      case OP_EVENTS.CONNECTED:\n        if (this.state === CLIENT_STATE.RECONNECTING) {\n          this.resubscribe();\n        }\n\n        this.emit(CLIENT_EMMITER_TYPES.OPEN);\n        this.id = data.clientId;\n        this.connectPromise.resolve();\n        this.state = CLIENT_STATE.CONNECTED;\n        break;\n\n      case OP_EVENTS.SUBSCRIBED:\n        if (subscription) {\n          subscription.subscribed = true;\n          subscription.subscribePromise.resolve();\n          setTimeout(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.OPEN, response), 200);\n        }\n\n        break;\n\n      case OP_EVENTS.ERROR:\n        if (data.requestId) {\n          if (subscription) {\n            subscription.subscribePromise.resolve();\n            setTimeout(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, data.error), 200);\n          }\n        } else {\n          this.emit(CLIENT_EMMITER_TYPES.ERROR, data.error);\n        }\n\n        if (data.error === 'Additional properties not allowed') {\n          this.additionalProperties = false;\n        }\n\n        if (data.reconnect) {\n          this._handleReconnect();\n        }\n\n        break;\n\n      case OP_EVENTS.UNSUBSCRIBED:\n        // We have already deleted subscription in unsubscribe(), do nothing here\n        break;\n\n      default:\n        {\n          // create, update, enter, leave, delete cases\n          if (!subscription) {\n            break;\n          }\n\n          let override = false;\n\n          if (data.original) {\n            override = true;\n            delete data.original.__type; // Check for removed fields\n\n            for (const field in data.original) {\n              if (!(field in data.object)) {\n                data.object[field] = undefined;\n              }\n            }\n\n            data.original = _ParseObject.default.fromJSON(data.original, false);\n          }\n\n          delete data.object.__type;\n\n          const parseObject = _ParseObject.default.fromJSON(data.object, override);\n\n          if (data.original) {\n            subscription.emit(data.op, parseObject, data.original, response);\n          } else {\n            subscription.emit(data.op, parseObject, response);\n          }\n\n          const localDatastore = _CoreManager.default.getLocalDatastore();\n\n          if (override && localDatastore.isEnabled) {\n            localDatastore._updateObjectIfPinned(parseObject).then(() => {});\n          }\n        }\n    }\n  }\n\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE); // Notify each subscription about the close\n\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error\n  /*: any*/\n  ) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    // if closed or currently reconnecting we stop attempting to reconnect\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts); // handle case when both close/error occur at frequent rates we ensure we do not reconnect unnecessarily.\n    // we're unable to distinguish different between close/error when we're unable to reconnect therefore\n    // we try to reconnect in both cases\n    // server side ws and browser WebSocket behave differently in when close/error get triggered\n\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n\n    this.reconnectHandle = setTimeout((() => {\n      this.attempts++;\n      this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n      this.open();\n    }).bind(this), time);\n  }\n\n}\n\n_CoreManager.default.setWebSocketController(require('ws'));\n\nvar _default = LiveQueryClient;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/LiveQueryClient.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_EventEmitter","_ParseObject","_LiveQuerySubscription","_promiseUtils","obj","__esModule","CLIENT_STATE","INITIALIZED","CONNECTING","CONNECTED","CLOSED","RECONNECTING","DISCONNECTED","OP_TYPES","CONNECT","SUBSCRIBE","UNSUBSCRIBE","ERROR","OP_EVENTS","SUBSCRIBED","UNSUBSCRIBED","CREATE","UPDATE","ENTER","LEAVE","DELETE","CLIENT_EMMITER_TYPES","CLOSE","OPEN","SUBSCRIPTION_EMMITER_TYPES","generateInterval","k","Math","random","min","pow","LiveQueryClient","constructor","applicationId","serverURL","javascriptKey","masterKey","sessionToken","installationId","indexOf","Error","reconnectHandle","attempts","id","requestId","undefined","additionalProperties","connectPromise","resolvingPromise","subscriptions","Map","state","on","shouldOpen","subscribe","query","className","queryJSON","toJSON","where","fields","keys","split","subscribeRequest","op","subscription","set","then","socket","send","JSON","stringify","unsubscribe","delete","unsubscribeRequest","open","WebSocketImplementation","getWebSocketController","emit","onopen","_handleWebSocketOpen","onmessage","event","_handleWebSocketMessage","onclose","_handleWebSocketClose","onerror","error","_handleWebSocketError","resubscribe","forEach","close","values","subscribed","_handleReset","connectRequest","data","parse","get","response","clientId","resolve","subscribePromise","setTimeout","reconnect","_handleReconnect","override","original","__type","field","object","fromJSON","parseObject","localDatastore","getLocalDatastore","isEnabled","_updateObjectIfPinned","time","clearTimeout","bind","setWebSocketController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _EventEmitter = _interopRequireDefault(require(\"./EventEmitter\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _LiveQuerySubscription = _interopRequireDefault(require(\"./LiveQuerySubscription\"));\n\nvar _promiseUtils = require(\"./promiseUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n/* global WebSocket */\n// The LiveQuery client inner state\n\n\nconst CLIENT_STATE = {\n  INITIALIZED: 'initialized',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  CLOSED: 'closed',\n  RECONNECTING: 'reconnecting',\n  DISCONNECTED: 'disconnected'\n}; // The event type the LiveQuery client should sent to server\n\nconst OP_TYPES = {\n  CONNECT: 'connect',\n  SUBSCRIBE: 'subscribe',\n  UNSUBSCRIBE: 'unsubscribe',\n  ERROR: 'error'\n}; // The event we get back from LiveQuery server\n\nconst OP_EVENTS = {\n  CONNECTED: 'connected',\n  SUBSCRIBED: 'subscribed',\n  UNSUBSCRIBED: 'unsubscribed',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete'\n}; // The event the LiveQuery client should emit\n\nconst CLIENT_EMMITER_TYPES = {\n  CLOSE: 'close',\n  ERROR: 'error',\n  OPEN: 'open'\n}; // The event the LiveQuery subscription should emit\n\nconst SUBSCRIPTION_EMMITER_TYPES = {\n  OPEN: 'open',\n  CLOSE: 'close',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete'\n};\n\nconst generateInterval = k => {\n  return Math.random() * Math.min(30, Math.pow(2, k) - 1) * 1000;\n};\n/**\n * Creates a new LiveQueryClient.\n * Extends events.EventEmitter\n * <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\">cloud functions</a>.\n *\n * A wrapper of a standard WebSocket client. We add several useful methods to\n * help you connect/disconnect to LiveQueryServer, subscribe/unsubscribe a ParseQuery easily.\n *\n * javascriptKey and masterKey are used for verifying the LiveQueryClient when it tries\n * to connect to the LiveQuery server\n *\n * We expose three events to help you monitor the status of the LiveQueryClient.\n *\n * <pre>\n * let Parse = require('parse/node');\n * let LiveQueryClient = Parse.LiveQueryClient;\n * let client = new LiveQueryClient({\n *   applicationId: '',\n *   serverURL: '',\n *   javascriptKey: '',\n *   masterKey: ''\n *  });\n * </pre>\n *\n * Open - When we establish the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('open', () => {\n *\n * });</pre>\n *\n * Close - When we lose the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('close', () => {\n *\n * });</pre>\n *\n * Error - When some network error or LiveQuery server error happens, you'll get this event.\n * <pre>\n * client.on('error', (error) => {\n *\n * });</pre>\n *\n * @alias Parse.LiveQueryClient\n */\n\n\nclass LiveQueryClient extends _EventEmitter.default {\n  /*:: attempts: number;*/\n\n  /*:: id: number;*/\n\n  /*:: requestId: number;*/\n\n  /*:: applicationId: string;*/\n\n  /*:: serverURL: string;*/\n\n  /*:: javascriptKey: ?string;*/\n\n  /*:: masterKey: ?string;*/\n\n  /*:: sessionToken: ?string;*/\n\n  /*:: installationId: ?string;*/\n\n  /*:: additionalProperties: boolean;*/\n\n  /*:: connectPromise: Promise;*/\n\n  /*:: subscriptions: Map;*/\n\n  /*:: socket: any;*/\n\n  /*:: state: string;*/\n\n  /**\n   * @param {object} options\n   * @param {string} options.applicationId - applicationId of your Parse app\n   * @param {string} options.serverURL - <b>the URL of your LiveQuery server</b>\n   * @param {string} options.javascriptKey (optional)\n   * @param {string} options.masterKey (optional) Your Parse Master Key. (Node.js only!)\n   * @param {string} options.sessionToken (optional)\n   * @param {string} options.installationId (optional)\n   */\n  constructor({\n    applicationId,\n    serverURL,\n    javascriptKey,\n    masterKey,\n    sessionToken,\n    installationId\n  }) {\n    super();\n\n    if (!serverURL || serverURL.indexOf('ws') !== 0) {\n      throw new Error('You need to set a proper Parse LiveQuery server url before using LiveQueryClient');\n    }\n\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new Map();\n    this.state = CLIENT_STATE.INITIALIZED; // adding listener so process does not crash\n    // best practice is for developer to register their own listener\n\n    this.on('error', () => {});\n  }\n\n  shouldOpen()\n  /*: any*/\n  {\n    return this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED;\n  }\n  /**\n   * Subscribes to a ParseQuery\n   *\n   * If you provide the sessionToken, when the LiveQuery server gets ParseObject's\n   * updates from parse server, it'll try to check whether the sessionToken fulfills\n   * the ParseObject's ACL. The LiveQuery server will only send updates to clients whose\n   * sessionToken is fit for the ParseObject's ACL. You can check the LiveQuery protocol\n   * <a href=\"https://github.com/parse-community/parse-server/wiki/Parse-LiveQuery-Protocol-Specification\">here</a> for more details. The subscription you get is the same subscription you get\n   * from our Standard API.\n   *\n   * @param {object} query - the ParseQuery you want to subscribe to\n   * @param {string} sessionToken (optional)\n   * @returns {LiveQuerySubscription} subscription\n   */\n\n\n  subscribe(query\n  /*: Object*/\n  , sessionToken\n  /*: ?string*/\n  )\n  /*: LiveQuerySubscription*/\n  {\n    if (!query) {\n      return;\n    }\n\n    const className = query.className;\n    const queryJSON = query.toJSON();\n    const where = queryJSON.where;\n    const fields = queryJSON.keys ? queryJSON.keys.split(',') : undefined;\n    const subscribeRequest = {\n      op: OP_TYPES.SUBSCRIBE,\n      requestId: this.requestId,\n      query: {\n        className,\n        where,\n        fields\n      }\n    };\n\n    if (sessionToken) {\n      subscribeRequest.sessionToken = sessionToken;\n    }\n\n    const subscription = new _LiveQuerySubscription.default(this.requestId, query, sessionToken);\n    this.subscriptions.set(this.requestId, subscription);\n    this.requestId += 1;\n    this.connectPromise.then(() => {\n      this.socket.send(JSON.stringify(subscribeRequest));\n    });\n    return subscription;\n  }\n  /**\n   * After calling unsubscribe you'll stop receiving events from the subscription object.\n   *\n   * @param {object} subscription - subscription you would like to unsubscribe from.\n   */\n\n\n  unsubscribe(subscription\n  /*: Object*/\n  ) {\n    if (!subscription) {\n      return;\n    }\n\n    this.subscriptions.delete(subscription.id);\n    const unsubscribeRequest = {\n      op: OP_TYPES.UNSUBSCRIBE,\n      requestId: subscription.id\n    };\n    this.connectPromise.then(() => {\n      this.socket.send(JSON.stringify(unsubscribeRequest));\n    });\n  }\n  /**\n   * After open is called, the LiveQueryClient will try to send a connect request\n   * to the LiveQuery server.\n   *\n   */\n\n\n  open() {\n    const WebSocketImplementation = _CoreManager.default.getWebSocketController();\n\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n\n    this.socket = new WebSocketImplementation(this.serverURL); // Bind WebSocket callbacks\n\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n\n    this.socket.onclose = () => {\n      this._handleWebSocketClose();\n    };\n\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n\n  resubscribe() {\n    this.subscriptions.forEach((subscription, requestId) => {\n      const query = subscription.query;\n      const queryJSON = query.toJSON();\n      const where = queryJSON.where;\n      const fields = queryJSON.keys ? queryJSON.keys.split(',') : undefined;\n      const className = query.className;\n      const sessionToken = subscription.sessionToken;\n      const subscribeRequest = {\n        op: OP_TYPES.SUBSCRIBE,\n        requestId,\n        query: {\n          className,\n          where,\n          fields\n        }\n      };\n\n      if (sessionToken) {\n        subscribeRequest.sessionToken = sessionToken;\n      }\n\n      this.connectPromise.then(() => {\n        this.socket.send(JSON.stringify(subscribeRequest));\n      });\n    });\n  }\n  /**\n   * This method will close the WebSocket connection to this LiveQueryClient,\n   * cancel the auto reconnect and unsubscribe all subscriptions based on it.\n   *\n   */\n\n\n  close() {\n    if (this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n\n    this.state = CLIENT_STATE.DISCONNECTED;\n    this.socket.close(); // Notify each subscription about the close\n\n    for (const subscription of this.subscriptions.values()) {\n      subscription.subscribed = false;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n\n    this._handleReset();\n\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n  } // ensure we start with valid state if connect is called again after close\n\n\n  _handleReset() {\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new Map();\n  }\n\n  _handleWebSocketOpen() {\n    this.attempts = 1;\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken\n    };\n\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n\n    this.socket.send(JSON.stringify(connectRequest));\n  }\n\n  _handleWebSocketMessage(event\n  /*: any*/\n  ) {\n    let data = event.data;\n\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n\n    let subscription = null;\n\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId);\n    }\n\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId\n    };\n\n    switch (data.op) {\n      case OP_EVENTS.CONNECTED:\n        if (this.state === CLIENT_STATE.RECONNECTING) {\n          this.resubscribe();\n        }\n\n        this.emit(CLIENT_EMMITER_TYPES.OPEN);\n        this.id = data.clientId;\n        this.connectPromise.resolve();\n        this.state = CLIENT_STATE.CONNECTED;\n        break;\n\n      case OP_EVENTS.SUBSCRIBED:\n        if (subscription) {\n          subscription.subscribed = true;\n          subscription.subscribePromise.resolve();\n          setTimeout(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.OPEN, response), 200);\n        }\n\n        break;\n\n      case OP_EVENTS.ERROR:\n        if (data.requestId) {\n          if (subscription) {\n            subscription.subscribePromise.resolve();\n            setTimeout(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, data.error), 200);\n          }\n        } else {\n          this.emit(CLIENT_EMMITER_TYPES.ERROR, data.error);\n        }\n\n        if (data.error === 'Additional properties not allowed') {\n          this.additionalProperties = false;\n        }\n\n        if (data.reconnect) {\n          this._handleReconnect();\n        }\n\n        break;\n\n      case OP_EVENTS.UNSUBSCRIBED:\n        // We have already deleted subscription in unsubscribe(), do nothing here\n        break;\n\n      default:\n        {\n          // create, update, enter, leave, delete cases\n          if (!subscription) {\n            break;\n          }\n\n          let override = false;\n\n          if (data.original) {\n            override = true;\n            delete data.original.__type; // Check for removed fields\n\n            for (const field in data.original) {\n              if (!(field in data.object)) {\n                data.object[field] = undefined;\n              }\n            }\n\n            data.original = _ParseObject.default.fromJSON(data.original, false);\n          }\n\n          delete data.object.__type;\n\n          const parseObject = _ParseObject.default.fromJSON(data.object, override);\n\n          if (data.original) {\n            subscription.emit(data.op, parseObject, data.original, response);\n          } else {\n            subscription.emit(data.op, parseObject, response);\n          }\n\n          const localDatastore = _CoreManager.default.getLocalDatastore();\n\n          if (override && localDatastore.isEnabled) {\n            localDatastore._updateObjectIfPinned(parseObject).then(() => {});\n          }\n        }\n    }\n  }\n\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE); // Notify each subscription about the close\n\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n\n    this._handleReconnect();\n  }\n\n  _handleWebSocketError(error\n  /*: any*/\n  ) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n\n    for (const subscription of this.subscriptions.values()) {\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n\n    this._handleReconnect();\n  }\n\n  _handleReconnect() {\n    // if closed or currently reconnecting we stop attempting to reconnect\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts); // handle case when both close/error occur at frequent rates we ensure we do not reconnect unnecessarily.\n    // we're unable to distinguish different between close/error when we're unable to reconnect therefore\n    // we try to reconnect in both cases\n    // server side ws and browser WebSocket behave differently in when close/error get triggered\n\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n\n    this.reconnectHandle = setTimeout((() => {\n      this.attempts++;\n      this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n      this.open();\n    }).bind(this), time);\n  }\n\n}\n\n_CoreManager.default.setWebSocketController(require('ws'));\n\nvar _default = LiveQueryClient;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}