{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = unsavedChildren;\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Return an array of unsaved children, which are either Parse Objects or Files.\n * If it encounters any dirty Objects without Ids, it will throw an exception.\n *\n * @param {Parse.Object} obj\n * @param {boolean} allowDeepUnsaved\n * @returns {Array}\n */\n\n\nfunction unsavedChildren(obj\n/*: ParseObject*/\n, allowDeepUnsaved\n/*:: ?: boolean*/\n)\n/*: Array<ParseFile | ParseObject>*/\n{\n  const encountered = {\n    objects: {},\n    files: []\n  };\n\n  const identifier = obj.className + ':' + obj._getId();\n\n  encountered.objects[identifier] = obj.dirty() ? obj : true;\n  const attributes = obj.attributes;\n\n  for (const attr in attributes) {\n    if (typeof attributes[attr] === 'object') {\n      traverse(attributes[attr], encountered, false, !!allowDeepUnsaved);\n    }\n  }\n\n  const unsaved = [];\n\n  for (const id in encountered.objects) {\n    if (id !== identifier && encountered.objects[id] !== true) {\n      unsaved.push(encountered.objects[id]);\n    }\n  }\n\n  return unsaved.concat(encountered.files);\n}\n\nfunction traverse(obj\n/*: ParseObject*/\n, encountered\n/*: EncounterMap*/\n, shouldThrow\n/*: boolean*/\n, allowDeepUnsaved\n/*: boolean*/\n) {\n  if (obj instanceof _ParseObject.default) {\n    if (!obj.id && shouldThrow) {\n      throw new Error('Cannot create a pointer to an unsaved Object.');\n    }\n\n    const identifier = obj.className + ':' + obj._getId();\n\n    if (!encountered.objects[identifier]) {\n      encountered.objects[identifier] = obj.dirty() ? obj : true;\n      const attributes = obj.attributes;\n\n      for (const attr in attributes) {\n        if (typeof attributes[attr] === 'object') {\n          traverse(attributes[attr], encountered, !allowDeepUnsaved, allowDeepUnsaved);\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (obj instanceof _ParseFile.default) {\n    if (!obj.url() && encountered.files.indexOf(obj) < 0) {\n      encountered.files.push(obj);\n    }\n\n    return;\n  }\n\n  if (obj instanceof _ParseRelation.default) {\n    return;\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(el => {\n      if (typeof el === 'object') {\n        traverse(el, encountered, shouldThrow, allowDeepUnsaved);\n      }\n    });\n  }\n\n  for (const k in obj) {\n    if (typeof obj[k] === 'object') {\n      traverse(obj[k], encountered, shouldThrow, allowDeepUnsaved);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/unsavedChildren.js"],"names":["Object","defineProperty","exports","value","default","unsavedChildren","_ParseFile","_interopRequireDefault","require","_ParseObject","_ParseRelation","obj","__esModule","allowDeepUnsaved","encountered","objects","files","identifier","className","_getId","dirty","attributes","attr","traverse","unsaved","id","push","concat","shouldThrow","Error","url","indexOf","Array","isArray","forEach","el","k"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = unsavedChildren;\n\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Return an array of unsaved children, which are either Parse Objects or Files.\n * If it encounters any dirty Objects without Ids, it will throw an exception.\n *\n * @param {Parse.Object} obj\n * @param {boolean} allowDeepUnsaved\n * @returns {Array}\n */\n\n\nfunction unsavedChildren(obj\n/*: ParseObject*/\n, allowDeepUnsaved\n/*:: ?: boolean*/\n)\n/*: Array<ParseFile | ParseObject>*/\n{\n  const encountered = {\n    objects: {},\n    files: []\n  };\n\n  const identifier = obj.className + ':' + obj._getId();\n\n  encountered.objects[identifier] = obj.dirty() ? obj : true;\n  const attributes = obj.attributes;\n\n  for (const attr in attributes) {\n    if (typeof attributes[attr] === 'object') {\n      traverse(attributes[attr], encountered, false, !!allowDeepUnsaved);\n    }\n  }\n\n  const unsaved = [];\n\n  for (const id in encountered.objects) {\n    if (id !== identifier && encountered.objects[id] !== true) {\n      unsaved.push(encountered.objects[id]);\n    }\n  }\n\n  return unsaved.concat(encountered.files);\n}\n\nfunction traverse(obj\n/*: ParseObject*/\n, encountered\n/*: EncounterMap*/\n, shouldThrow\n/*: boolean*/\n, allowDeepUnsaved\n/*: boolean*/\n) {\n  if (obj instanceof _ParseObject.default) {\n    if (!obj.id && shouldThrow) {\n      throw new Error('Cannot create a pointer to an unsaved Object.');\n    }\n\n    const identifier = obj.className + ':' + obj._getId();\n\n    if (!encountered.objects[identifier]) {\n      encountered.objects[identifier] = obj.dirty() ? obj : true;\n      const attributes = obj.attributes;\n\n      for (const attr in attributes) {\n        if (typeof attributes[attr] === 'object') {\n          traverse(attributes[attr], encountered, !allowDeepUnsaved, allowDeepUnsaved);\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (obj instanceof _ParseFile.default) {\n    if (!obj.url() && encountered.files.indexOf(obj) < 0) {\n      encountered.files.push(obj);\n    }\n\n    return;\n  }\n\n  if (obj instanceof _ParseRelation.default) {\n    return;\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(el => {\n      if (typeof el === 'object') {\n        traverse(el, encountered, shouldThrow, allowDeepUnsaved);\n      }\n    });\n  }\n\n  for (const k in obj) {\n    if (typeof obj[k] === 'object') {\n      traverse(obj[k], encountered, shouldThrow, allowDeepUnsaved);\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}