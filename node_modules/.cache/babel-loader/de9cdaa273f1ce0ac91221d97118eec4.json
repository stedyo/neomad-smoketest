{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.continueWhile = continueWhile;\nexports.resolvingPromise = resolvingPromise;\nexports.when = when; // Create Deferred Promise\n\nfunction resolvingPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n}\n\nfunction when(promises) {\n  let objects;\n  const arrayArgument = Array.isArray(promises);\n\n  if (arrayArgument) {\n    objects = promises;\n  } else {\n    objects = arguments;\n  }\n\n  let total = objects.length;\n  let hadError = false;\n  const results = [];\n  const returnValue = arrayArgument ? [results] : results;\n  const errors = [];\n  results.length = objects.length;\n  errors.length = objects.length;\n\n  if (total === 0) {\n    return Promise.resolve(returnValue);\n  }\n\n  const promise = new resolvingPromise();\n\n  const resolveOne = function () {\n    total--;\n\n    if (total <= 0) {\n      if (hadError) {\n        promise.reject(errors);\n      } else {\n        promise.resolve(returnValue);\n      }\n    }\n  };\n\n  const chain = function (object, index) {\n    if (object && typeof object.then === 'function') {\n      object.then(function (result) {\n        results[index] = result;\n        resolveOne();\n      }, function (error) {\n        errors[index] = error;\n        hadError = true;\n        resolveOne();\n      });\n    } else {\n      results[index] = object;\n      resolveOne();\n    }\n  };\n\n  for (let i = 0; i < objects.length; i++) {\n    chain(objects[i], i);\n  }\n\n  return promise;\n}\n\nfunction continueWhile(test, emitter) {\n  if (test()) {\n    return emitter().then(() => {\n      return continueWhile(test, emitter);\n    });\n  }\n\n  return Promise.resolve();\n}","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/promiseUtils.js"],"names":["Object","defineProperty","exports","value","continueWhile","resolvingPromise","when","res","rej","promise","Promise","resolve","reject","promises","objects","arrayArgument","Array","isArray","arguments","total","length","hadError","results","returnValue","errors","resolveOne","chain","object","index","then","result","error","i","test","emitter"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.continueWhile = continueWhile;\nexports.resolvingPromise = resolvingPromise;\nexports.when = when; // Create Deferred Promise\n\nfunction resolvingPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n}\n\nfunction when(promises) {\n  let objects;\n  const arrayArgument = Array.isArray(promises);\n\n  if (arrayArgument) {\n    objects = promises;\n  } else {\n    objects = arguments;\n  }\n\n  let total = objects.length;\n  let hadError = false;\n  const results = [];\n  const returnValue = arrayArgument ? [results] : results;\n  const errors = [];\n  results.length = objects.length;\n  errors.length = objects.length;\n\n  if (total === 0) {\n    return Promise.resolve(returnValue);\n  }\n\n  const promise = new resolvingPromise();\n\n  const resolveOne = function () {\n    total--;\n\n    if (total <= 0) {\n      if (hadError) {\n        promise.reject(errors);\n      } else {\n        promise.resolve(returnValue);\n      }\n    }\n  };\n\n  const chain = function (object, index) {\n    if (object && typeof object.then === 'function') {\n      object.then(function (result) {\n        results[index] = result;\n        resolveOne();\n      }, function (error) {\n        errors[index] = error;\n        hadError = true;\n        resolveOne();\n      });\n    } else {\n      results[index] = object;\n      resolveOne();\n    }\n  };\n\n  for (let i = 0; i < objects.length; i++) {\n    chain(objects[i], i);\n  }\n\n  return promise;\n}\n\nfunction continueWhile(test, emitter) {\n  if (test()) {\n    return emitter().then(() => {\n      return continueWhile(test, emitter);\n    });\n  }\n\n  return Promise.resolve();\n}"]},"metadata":{},"sourceType":"script"}