{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst PUBLIC_KEY = '*';\nconst VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new Map();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nconst VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new Map();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nclass ParseCLP {\n  /*:: permissionsMap: PermissionsMap;*/\n\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  constructor(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    for (const [operation, group] of VALID_PERMISSIONS.entries()) {\n      this.permissionsMap[operation] = Object.assign({}, group);\n      const action = operation.charAt(0).toUpperCase() + operation.slice(1);\n\n      this[`get${action}RequiresAuthentication`] = function () {\n        return this._getAccess(operation, 'requiresAuthentication');\n      };\n\n      this[`set${action}RequiresAuthentication`] = function (allowed) {\n        this._setAccess(operation, 'requiresAuthentication', allowed);\n      };\n\n      this[`get${action}PointerFields`] = function () {\n        return this._getAccess(operation, 'pointerFields', false);\n      };\n\n      this[`set${action}PointerFields`] = function (pointerFields) {\n        this._setArrayAccess(operation, 'pointerFields', pointerFields);\n      };\n\n      this[`get${action}Access`] = function (entity) {\n        return this._getAccess(operation, entity);\n      };\n\n      this[`set${action}Access`] = function (entity, allowed) {\n        this._setAccess(operation, entity, allowed);\n      };\n\n      this[`getPublic${action}Access`] = function () {\n        return this[`get${action}Access`](PUBLIC_KEY);\n      };\n\n      this[`setPublic${action}Access`] = function (allowed) {\n        this[`set${action}Access`](PUBLIC_KEY, allowed);\n      };\n\n      this[`getRole${action}Access`] = function (role) {\n        return this[`get${action}Access`](this._getRoleName(role));\n      };\n\n      this[`setRole${action}Access`] = function (role, allowed) {\n        this[`set${action}Access`](this._getRoleName(role), allowed);\n      };\n    } // Initialize permissions Map with default extended permissions\n\n\n    for (const [operation, group] of VALID_PERMISSIONS_EXTENDED.entries()) {\n      this.permissionsMap[operation] = Object.assign({}, group);\n    }\n\n    if (userId && typeof userId === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (const permission in userId) {\n          const users = userId[permission];\n          const isValidPermission = !!VALID_PERMISSIONS.get(permission);\n          const isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(permission);\n          const isValidGroupPermission = ['readUserFields', 'writeUserFields'].includes(permission);\n\n          if (typeof permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if (users.every(pointer => typeof pointer === 'string')) {\n              this.permissionsMap[permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (const user in users) {\n            const allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: PermissionsMap*/\n  {\n    return _objectSpread({}, this.permissionsMap);\n  }\n  /**\n   * Returns whether this CLP is equal to another object\n   *\n   * @param other The other object to compare to\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: ParseCLP*/\n  )\n  /*: boolean*/\n  {\n    if (!(other instanceof ParseCLP)) {\n      return false;\n    }\n\n    const permissions = Object.keys(this.permissionsMap);\n    const otherPermissions = Object.keys(other.permissionsMap);\n\n    if (permissions.length !== otherPermissions.length) {\n      return false;\n    }\n\n    for (const permission in this.permissionsMap) {\n      if (!other.permissionsMap[permission]) {\n        return false;\n      }\n\n      const users = Object.keys(this.permissionsMap[permission]);\n      const otherUsers = Object.keys(other.permissionsMap[permission]);\n\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n\n      for (const user in this.permissionsMap[permission]) {\n        if (!other.permissionsMap[permission][user]) {\n          return false;\n        }\n\n        if (this.permissionsMap[permission][user] !== other.permissionsMap[permission][user]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  _getRoleName(role\n  /*: ParseRole | string*/\n  )\n  /*: string*/\n  {\n    let name = role;\n\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      name = role.getName();\n    }\n\n    if (typeof name !== 'string') {\n      throw new TypeError('role must be a Parse.Role or a String');\n    }\n\n    return `role:${name}`;\n  }\n\n  _parseEntity(entity\n  /*: Entity*/\n  ) {\n    let userId = entity;\n\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n\n      if (!userId) {\n        throw new Error('Cannot get access for a Parse.User without an id.');\n      }\n    } else if (userId instanceof _ParseRole.default) {\n      userId = this._getRoleName(userId);\n    }\n\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n\n    return userId;\n  }\n\n  _setAccess(permission\n  /*: string*/\n  , userId\n  /*: Entity*/\n  , allowed\n  /*: boolean*/\n  ) {\n    userId = this._parseEntity(userId);\n\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n\n    const permissions = this.permissionsMap[permission][userId];\n\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        this.permissionsMap[permission][userId] = {};\n      }\n    }\n\n    if (allowed) {\n      this.permissionsMap[permission][userId] = true;\n    } else {\n      delete this.permissionsMap[permission][userId];\n    }\n  }\n\n  _getAccess(permission\n  /*: string*/\n  , userId\n  /*: Entity*/\n  , returnBoolean = true)\n  /*: boolean | string[]*/\n  {\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n\n    if (returnBoolean) {\n      if (!permissions) {\n        return false;\n      }\n\n      return !!this.permissionsMap[permission][userId];\n    }\n\n    return permissions;\n  }\n\n  _setArrayAccess(permission\n  /*: string*/\n  , userId\n  /*: Entity*/\n  , fields\n  /*: string*/\n  ) {\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n\n    if (!permissions) {\n      this.permissionsMap[permission][userId] = [];\n    }\n\n    if (!fields || Array.isArray(fields) && fields.length === 0) {\n      delete this.permissionsMap[permission][userId];\n    } else if (Array.isArray(fields) && fields.every(field => typeof field === 'string')) {\n      this.permissionsMap[permission][userId] = fields;\n    } else {\n      throw new TypeError('fields must be an array of strings or undefined.');\n    }\n  }\n\n  _setGroupPointerPermission(operation\n  /*: string*/\n  , pointerFields\n  /*: string[]*/\n  ) {\n    const fields = this.permissionsMap[operation];\n\n    if (!fields) {\n      this.permissionsMap[operation] = [];\n    }\n\n    if (!pointerFields || Array.isArray(pointerFields) && pointerFields.length === 0) {\n      delete this.permissionsMap[operation];\n    } else if (Array.isArray(pointerFields) && pointerFields.every(field => typeof field === 'string')) {\n      this.permissionsMap[operation] = pointerFields;\n    } else {\n      throw new TypeError(`${operation}.pointerFields must be an array of strings or undefined.`);\n    }\n  }\n\n  _getGroupPointerPermissions(operation\n  /*: string*/\n  )\n  /*: string[]*/\n  {\n    return this.permissionsMap[operation];\n  }\n  /**\n   * Sets user pointer fields to allow permission for get/count/find operations.\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n\n\n  setReadUserFields(pointerFields\n  /*: string[]*/\n  ) {\n    this._setGroupPointerPermission('readUserFields', pointerFields);\n  }\n  /**\n   * @returns {string[]} User pointer fields\n   */\n\n\n  getReadUserFields()\n  /*: string[]*/\n  {\n    return this._getGroupPointerPermissions('readUserFields');\n  }\n  /**\n   * Sets user pointer fields to allow permission for create/delete/update/addField operations\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n\n\n  setWriteUserFields(pointerFields\n  /*: string[]*/\n  ) {\n    this._setGroupPointerPermission('writeUserFields', pointerFields);\n  }\n  /**\n   * @returns {string[]} User pointer fields\n   */\n\n\n  getWriteUserFields()\n  /*: string[]*/\n  {\n    return this._getGroupPointerPermissions('writeUserFields');\n  }\n  /**\n   * Sets whether the given user is allowed to retrieve fields from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {string[]} fields fields to be protected\n   */\n\n\n  setProtectedFields(userId\n  /*: Entity*/\n  , fields\n  /*: string[]*/\n  ) {\n    this._setArrayAccess('protectedFields', userId, fields);\n  }\n  /**\n   * Returns array of fields are accessable to this user.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {string[]}\n   */\n\n\n  getProtectedFields(userId\n  /*: Entity*/\n  )\n  /*: string[]*/\n  {\n    return this._getAccess('protectedFields', userId, false);\n  }\n  /**\n   * Sets whether the given user is allowed to read from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed whether that user should have read access.\n   */\n\n\n  setReadAccess(userId\n  /*: Entity*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('find', userId, allowed);\n\n    this._setAccess('get', userId, allowed);\n\n    this._setAccess('count', userId, allowed);\n  }\n  /**\n   * Get whether the given user id is *explicitly* allowed to read from this class.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getReadAccess(userId\n  /*: Entity*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n  }\n  /**\n   * Sets whether the given user id is allowed to write to this class.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n\n\n  setWriteAccess(userId\n  /*: Entity*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('create', userId, allowed);\n\n    this._setAccess('update', userId, allowed);\n\n    this._setAccess('delete', userId, allowed);\n\n    this._setAccess('addField', userId, allowed);\n  }\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write to this class.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getWriteAccess(userId\n  /*: Entity*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n  }\n  /**\n   * Sets whether the public is allowed to read from this class.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicReadAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to read from this class.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicReadAccess()\n  /*: boolean*/\n  {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n  /**\n   * Sets whether the public is allowed to write to this class.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicWriteAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to write to this class.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicWriteAccess()\n  /*: boolean*/\n  {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n  /**\n   * Sets whether the public is allowed to protect fields in this class.\n   *\n   * @param {string[]} fields\n   */\n\n\n  setPublicProtectedFields(fields\n  /*: string[]*/\n  ) {\n    this.setProtectedFields(PUBLIC_KEY, fields);\n  }\n  /**\n   * Gets whether the public is allowed to read fields from this class.\n   *\n   * @returns {string[]}\n   */\n\n\n  getPublicProtectedFields()\n  /*: string[]*/\n  {\n    return this.getProtectedFields(PUBLIC_KEY);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read from this class. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleReadAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this.getReadAccess(this._getRoleName(role));\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write to this user. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleWriteAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this.getWriteAccess(this._getRoleName(role));\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read from this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleReadAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this.setReadAccess(this._getRoleName(role), allowed);\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write to this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleWriteAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this.setWriteAccess(this._getRoleName(role), allowed);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to count to this user. Even if this returns false, the role may\n   * still be able to count it if a parent role has count access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {string[]}\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleProtectedFields(role\n  /*: ParseRole | string*/\n  )\n  /*: string[]*/\n  {\n    return this.getProtectedFields(this._getRoleName(role));\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to set access field in this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {string[]} fields Fields to be protected by Role.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleProtectedFields(role\n  /*: ParseRole | string*/\n  , fields\n  /*: string[]*/\n  ) {\n    this.setProtectedFields(this._getRoleName(role), fields);\n  }\n\n}\n\nvar _default = ParseCLP;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseCLP.js"],"names":["Object","defineProperty","exports","value","default","_ParseRole","_interopRequireDefault","require","_ParseUser","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","PUBLIC_KEY","VALID_PERMISSIONS","Map","set","VALID_PERMISSIONS_EXTENDED","ParseCLP","constructor","userId","permissionsMap","operation","group","entries","assign","action","charAt","toUpperCase","slice","_getAccess","allowed","_setAccess","pointerFields","_setArrayAccess","entity","role","_getRoleName","setReadAccess","setWriteAccess","setRoleReadAccess","setRoleWriteAccess","permission","users","isValidPermission","get","isValidPermissionExtended","isValidGroupPermission","includes","TypeError","every","pointer","user","toJSON","equals","other","permissions","otherPermissions","otherUsers","name","getName","_parseEntity","id","Error","returnBoolean","fields","Array","isArray","field","_setGroupPointerPermission","_getGroupPointerPermissions","setReadUserFields","getReadUserFields","setWriteUserFields","getWriteUserFields","setProtectedFields","getProtectedFields","getReadAccess","getWriteAccess","setPublicReadAccess","getPublicReadAccess","setPublicWriteAccess","getPublicWriteAccess","setPublicProtectedFields","getPublicProtectedFields","getRoleReadAccess","getRoleWriteAccess","getRoleProtectedFields","setRoleProtectedFields","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\n\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst PUBLIC_KEY = '*';\nconst VALID_PERMISSIONS\n/*: Map<string, UsersMap>*/\n= new Map();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nconst VALID_PERMISSIONS_EXTENDED\n/*: Map<string, UsersMap>*/\n= new Map();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\n\nclass ParseCLP {\n  /*:: permissionsMap: PermissionsMap;*/\n\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  constructor(userId\n  /*: ParseUser | ParseRole | PermissionsMap*/\n  ) {\n    this.permissionsMap = {}; // Initialize permissions Map with default permissions\n\n    for (const [operation, group] of VALID_PERMISSIONS.entries()) {\n      this.permissionsMap[operation] = Object.assign({}, group);\n      const action = operation.charAt(0).toUpperCase() + operation.slice(1);\n\n      this[`get${action}RequiresAuthentication`] = function () {\n        return this._getAccess(operation, 'requiresAuthentication');\n      };\n\n      this[`set${action}RequiresAuthentication`] = function (allowed) {\n        this._setAccess(operation, 'requiresAuthentication', allowed);\n      };\n\n      this[`get${action}PointerFields`] = function () {\n        return this._getAccess(operation, 'pointerFields', false);\n      };\n\n      this[`set${action}PointerFields`] = function (pointerFields) {\n        this._setArrayAccess(operation, 'pointerFields', pointerFields);\n      };\n\n      this[`get${action}Access`] = function (entity) {\n        return this._getAccess(operation, entity);\n      };\n\n      this[`set${action}Access`] = function (entity, allowed) {\n        this._setAccess(operation, entity, allowed);\n      };\n\n      this[`getPublic${action}Access`] = function () {\n        return this[`get${action}Access`](PUBLIC_KEY);\n      };\n\n      this[`setPublic${action}Access`] = function (allowed) {\n        this[`set${action}Access`](PUBLIC_KEY, allowed);\n      };\n\n      this[`getRole${action}Access`] = function (role) {\n        return this[`get${action}Access`](this._getRoleName(role));\n      };\n\n      this[`setRole${action}Access`] = function (role, allowed) {\n        this[`set${action}Access`](this._getRoleName(role), allowed);\n      };\n    } // Initialize permissions Map with default extended permissions\n\n\n    for (const [operation, group] of VALID_PERMISSIONS_EXTENDED.entries()) {\n      this.permissionsMap[operation] = Object.assign({}, group);\n    }\n\n    if (userId && typeof userId === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (const permission in userId) {\n          const users = userId[permission];\n          const isValidPermission = !!VALID_PERMISSIONS.get(permission);\n          const isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(permission);\n          const isValidGroupPermission = ['readUserFields', 'writeUserFields'].includes(permission);\n\n          if (typeof permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n\n          if (isValidGroupPermission) {\n            if (users.every(pointer => typeof pointer === 'string')) {\n              this.permissionsMap[permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n\n          for (const user in users) {\n            const allowed = users[user];\n\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n\n            this.permissionsMap[permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: PermissionsMap*/\n  {\n    return _objectSpread({}, this.permissionsMap);\n  }\n  /**\n   * Returns whether this CLP is equal to another object\n   *\n   * @param other The other object to compare to\n   * @returns {boolean}\n   */\n\n\n  equals(other\n  /*: ParseCLP*/\n  )\n  /*: boolean*/\n  {\n    if (!(other instanceof ParseCLP)) {\n      return false;\n    }\n\n    const permissions = Object.keys(this.permissionsMap);\n    const otherPermissions = Object.keys(other.permissionsMap);\n\n    if (permissions.length !== otherPermissions.length) {\n      return false;\n    }\n\n    for (const permission in this.permissionsMap) {\n      if (!other.permissionsMap[permission]) {\n        return false;\n      }\n\n      const users = Object.keys(this.permissionsMap[permission]);\n      const otherUsers = Object.keys(other.permissionsMap[permission]);\n\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n\n      for (const user in this.permissionsMap[permission]) {\n        if (!other.permissionsMap[permission][user]) {\n          return false;\n        }\n\n        if (this.permissionsMap[permission][user] !== other.permissionsMap[permission][user]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  _getRoleName(role\n  /*: ParseRole | string*/\n  )\n  /*: string*/\n  {\n    let name = role;\n\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      name = role.getName();\n    }\n\n    if (typeof name !== 'string') {\n      throw new TypeError('role must be a Parse.Role or a String');\n    }\n\n    return `role:${name}`;\n  }\n\n  _parseEntity(entity\n  /*: Entity*/\n  ) {\n    let userId = entity;\n\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n\n      if (!userId) {\n        throw new Error('Cannot get access for a Parse.User without an id.');\n      }\n    } else if (userId instanceof _ParseRole.default) {\n      userId = this._getRoleName(userId);\n    }\n\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n\n    return userId;\n  }\n\n  _setAccess(permission\n  /*: string*/\n  , userId\n  /*: Entity*/\n  , allowed\n  /*: boolean*/\n  ) {\n    userId = this._parseEntity(userId);\n\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n\n    const permissions = this.permissionsMap[permission][userId];\n\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        this.permissionsMap[permission][userId] = {};\n      }\n    }\n\n    if (allowed) {\n      this.permissionsMap[permission][userId] = true;\n    } else {\n      delete this.permissionsMap[permission][userId];\n    }\n  }\n\n  _getAccess(permission\n  /*: string*/\n  , userId\n  /*: Entity*/\n  , returnBoolean = true)\n  /*: boolean | string[]*/\n  {\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n\n    if (returnBoolean) {\n      if (!permissions) {\n        return false;\n      }\n\n      return !!this.permissionsMap[permission][userId];\n    }\n\n    return permissions;\n  }\n\n  _setArrayAccess(permission\n  /*: string*/\n  , userId\n  /*: Entity*/\n  , fields\n  /*: string*/\n  ) {\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n\n    if (!permissions) {\n      this.permissionsMap[permission][userId] = [];\n    }\n\n    if (!fields || Array.isArray(fields) && fields.length === 0) {\n      delete this.permissionsMap[permission][userId];\n    } else if (Array.isArray(fields) && fields.every(field => typeof field === 'string')) {\n      this.permissionsMap[permission][userId] = fields;\n    } else {\n      throw new TypeError('fields must be an array of strings or undefined.');\n    }\n  }\n\n  _setGroupPointerPermission(operation\n  /*: string*/\n  , pointerFields\n  /*: string[]*/\n  ) {\n    const fields = this.permissionsMap[operation];\n\n    if (!fields) {\n      this.permissionsMap[operation] = [];\n    }\n\n    if (!pointerFields || Array.isArray(pointerFields) && pointerFields.length === 0) {\n      delete this.permissionsMap[operation];\n    } else if (Array.isArray(pointerFields) && pointerFields.every(field => typeof field === 'string')) {\n      this.permissionsMap[operation] = pointerFields;\n    } else {\n      throw new TypeError(`${operation}.pointerFields must be an array of strings or undefined.`);\n    }\n  }\n\n  _getGroupPointerPermissions(operation\n  /*: string*/\n  )\n  /*: string[]*/\n  {\n    return this.permissionsMap[operation];\n  }\n  /**\n   * Sets user pointer fields to allow permission for get/count/find operations.\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n\n\n  setReadUserFields(pointerFields\n  /*: string[]*/\n  ) {\n    this._setGroupPointerPermission('readUserFields', pointerFields);\n  }\n  /**\n   * @returns {string[]} User pointer fields\n   */\n\n\n  getReadUserFields()\n  /*: string[]*/\n  {\n    return this._getGroupPointerPermissions('readUserFields');\n  }\n  /**\n   * Sets user pointer fields to allow permission for create/delete/update/addField operations\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n\n\n  setWriteUserFields(pointerFields\n  /*: string[]*/\n  ) {\n    this._setGroupPointerPermission('writeUserFields', pointerFields);\n  }\n  /**\n   * @returns {string[]} User pointer fields\n   */\n\n\n  getWriteUserFields()\n  /*: string[]*/\n  {\n    return this._getGroupPointerPermissions('writeUserFields');\n  }\n  /**\n   * Sets whether the given user is allowed to retrieve fields from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {string[]} fields fields to be protected\n   */\n\n\n  setProtectedFields(userId\n  /*: Entity*/\n  , fields\n  /*: string[]*/\n  ) {\n    this._setArrayAccess('protectedFields', userId, fields);\n  }\n  /**\n   * Returns array of fields are accessable to this user.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {string[]}\n   */\n\n\n  getProtectedFields(userId\n  /*: Entity*/\n  )\n  /*: string[]*/\n  {\n    return this._getAccess('protectedFields', userId, false);\n  }\n  /**\n   * Sets whether the given user is allowed to read from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed whether that user should have read access.\n   */\n\n\n  setReadAccess(userId\n  /*: Entity*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('find', userId, allowed);\n\n    this._setAccess('get', userId, allowed);\n\n    this._setAccess('count', userId, allowed);\n  }\n  /**\n   * Get whether the given user id is *explicitly* allowed to read from this class.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getReadAccess(userId\n  /*: Entity*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n  }\n  /**\n   * Sets whether the given user id is allowed to write to this class.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n\n\n  setWriteAccess(userId\n  /*: Entity*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this._setAccess('create', userId, allowed);\n\n    this._setAccess('update', userId, allowed);\n\n    this._setAccess('delete', userId, allowed);\n\n    this._setAccess('addField', userId, allowed);\n  }\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write to this class.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n\n\n  getWriteAccess(userId\n  /*: Entity*/\n  )\n  /*: boolean*/\n  {\n    return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n  }\n  /**\n   * Sets whether the public is allowed to read from this class.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicReadAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to read from this class.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicReadAccess()\n  /*: boolean*/\n  {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n  /**\n   * Sets whether the public is allowed to write to this class.\n   *\n   * @param {boolean} allowed\n   */\n\n\n  setPublicWriteAccess(allowed\n  /*: boolean*/\n  ) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n  /**\n   * Gets whether the public is allowed to write to this class.\n   *\n   * @returns {boolean}\n   */\n\n\n  getPublicWriteAccess()\n  /*: boolean*/\n  {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n  /**\n   * Sets whether the public is allowed to protect fields in this class.\n   *\n   * @param {string[]} fields\n   */\n\n\n  setPublicProtectedFields(fields\n  /*: string[]*/\n  ) {\n    this.setProtectedFields(PUBLIC_KEY, fields);\n  }\n  /**\n   * Gets whether the public is allowed to read fields from this class.\n   *\n   * @returns {string[]}\n   */\n\n\n  getPublicProtectedFields()\n  /*: string[]*/\n  {\n    return this.getProtectedFields(PUBLIC_KEY);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read from this class. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleReadAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this.getReadAccess(this._getRoleName(role));\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write to this user. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleWriteAccess(role\n  /*: ParseRole | string*/\n  )\n  /*: boolean*/\n  {\n    return this.getWriteAccess(this._getRoleName(role));\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read from this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleReadAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this.setReadAccess(this._getRoleName(role), allowed);\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write to this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleWriteAccess(role\n  /*: ParseRole | string*/\n  , allowed\n  /*: boolean*/\n  ) {\n    this.setWriteAccess(this._getRoleName(role), allowed);\n  }\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to count to this user. Even if this returns false, the role may\n   * still be able to count it if a parent role has count access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {string[]}\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  getRoleProtectedFields(role\n  /*: ParseRole | string*/\n  )\n  /*: string[]*/\n  {\n    return this.getProtectedFields(this._getRoleName(role));\n  }\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to set access field in this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {string[]} fields Fields to be protected by Role.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n\n\n  setRoleProtectedFields(role\n  /*: ParseRole | string*/\n  , fields\n  /*: string[]*/\n  ) {\n    this.setProtectedFields(this._getRoleName(role), fields);\n  }\n\n}\n\nvar _default = ParseCLP;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}