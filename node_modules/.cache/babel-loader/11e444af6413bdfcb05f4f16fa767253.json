{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new GeoPoint with any of the following forms:<br>\n *   <pre>\n *   new GeoPoint(otherGeoPoint)\n *   new GeoPoint(30, 30)\n *   new GeoPoint([30, 30])\n *   new GeoPoint({latitude: 30, longitude: 30})\n *   new GeoPoint()  // defaults to (0, 0)\n *   </pre>\n * <p>Represents a latitude / longitude point that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Only one key in a class may contain a GeoPoint.</p>\n *\n * <p>Example:<pre>\n *   var point = new Parse.GeoPoint(30.0, -20.0);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"location\", point);\n *   object.save();</pre></p>\n *\n * @alias Parse.GeoPoint\n */\n\n/* global navigator */\n\nclass ParseGeoPoint {\n  /*:: _latitude: number;*/\n\n  /*:: _longitude: number;*/\n\n  /**\n   * @param {(number[] | object | number)} arg1 Either a list of coordinate pairs, an object with `latitude`, `longitude`, or the latitude or the point.\n   * @param {number} arg2 The longitude of the GeoPoint\n   */\n  constructor(arg1\n  /*: Array<number> | { latitude: number, longitude: number } | number*/\n  , arg2\n  /*:: ?: number*/\n  ) {\n    if (Array.isArray(arg1)) {\n      ParseGeoPoint._validate(arg1[0], arg1[1]);\n\n      this._latitude = arg1[0];\n      this._longitude = arg1[1];\n    } else if (typeof arg1 === 'object') {\n      ParseGeoPoint._validate(arg1.latitude, arg1.longitude);\n\n      this._latitude = arg1.latitude;\n      this._longitude = arg1.longitude;\n    } else if (arg1 !== undefined && arg2 !== undefined) {\n      ParseGeoPoint._validate(arg1, arg2);\n\n      this._latitude = arg1;\n      this._longitude = arg2;\n    } else {\n      this._latitude = 0;\n      this._longitude = 0;\n    }\n  }\n  /**\n   * North-south portion of the coordinate, in range [-90, 90].\n   * Throws an exception if set out of range in a modern browser.\n   *\n   * @property {number} latitude\n   * @returns {number}\n   */\n\n\n  get latitude()\n  /*: number*/\n  {\n    return this._latitude;\n  }\n\n  set latitude(val\n  /*: number*/\n  ) {\n    ParseGeoPoint._validate(val, this.longitude);\n\n    this._latitude = val;\n  }\n  /**\n   * East-west portion of the coordinate, in range [-180, 180].\n   * Throws if set out of range in a modern browser.\n   *\n   * @property {number} longitude\n   * @returns {number}\n   */\n\n\n  get longitude()\n  /*: number*/\n  {\n    return this._longitude;\n  }\n\n  set longitude(val\n  /*: number*/\n  ) {\n    ParseGeoPoint._validate(this.latitude, val);\n\n    this._longitude = val;\n  }\n  /**\n   * Returns a JSON representation of the GeoPoint, suitable for Parse.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: { __type: string, latitude: number, longitude: number }*/\n  {\n    ParseGeoPoint._validate(this._latitude, this._longitude);\n\n    return {\n      __type: 'GeoPoint',\n      latitude: this._latitude,\n      longitude: this._longitude\n    };\n  }\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    return other instanceof ParseGeoPoint && this.latitude === other.latitude && this.longitude === other.longitude;\n  }\n  /**\n   * Returns the distance from this GeoPoint to another in radians.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n\n\n  radiansTo(point\n  /*: ParseGeoPoint*/\n  )\n  /*: number*/\n  {\n    const d2r = Math.PI / 180.0;\n    const lat1rad = this.latitude * d2r;\n    const long1rad = this.longitude * d2r;\n    const lat2rad = point.latitude * d2r;\n    const long2rad = point.longitude * d2r;\n    const sinDeltaLatDiv2 = Math.sin((lat1rad - lat2rad) / 2);\n    const sinDeltaLongDiv2 = Math.sin((long1rad - long2rad) / 2); // Square of half the straight line chord distance between both points.\n\n    let a = sinDeltaLatDiv2 * sinDeltaLatDiv2 + Math.cos(lat1rad) * Math.cos(lat2rad) * sinDeltaLongDiv2 * sinDeltaLongDiv2;\n    a = Math.min(1.0, a);\n    return 2 * Math.asin(Math.sqrt(a));\n  }\n  /**\n   * Returns the distance from this GeoPoint to another in kilometers.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n\n\n  kilometersTo(point\n  /*: ParseGeoPoint*/\n  )\n  /*: number*/\n  {\n    return this.radiansTo(point) * 6371.0;\n  }\n  /**\n   * Returns the distance from this GeoPoint to another in miles.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n\n\n  milesTo(point\n  /*: ParseGeoPoint*/\n  )\n  /*: number*/\n  {\n    return this.radiansTo(point) * 3958.8;\n  }\n  /*\n   * Throws an exception if the given lat-long is out of bounds.\n   */\n\n\n  static _validate(latitude\n  /*: number*/\n  , longitude\n  /*: number*/\n  ) {\n    if (isNaN(latitude) || isNaN(longitude) || typeof latitude !== 'number' || typeof longitude !== 'number') {\n      throw new TypeError('GeoPoint latitude and longitude must be valid numbers');\n    }\n\n    if (latitude < -90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' < -90.0.');\n    }\n\n    if (latitude > 90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' > 90.0.');\n    }\n\n    if (longitude < -180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' < -180.0.');\n    }\n\n    if (longitude > 180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' > 180.0.');\n    }\n  }\n  /**\n   * Creates a GeoPoint with the user's current location, if available.\n   *\n   * @static\n   * @returns {Parse.GeoPoint} User's current location\n   */\n\n\n  static current() {\n    return navigator.geolocation.getCurrentPosition(location => {\n      return new ParseGeoPoint(location.coords.latitude, location.coords.longitude);\n    });\n  }\n\n}\n\nvar _default = ParseGeoPoint;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseGeoPoint.js"],"names":["Object","defineProperty","exports","value","default","ParseGeoPoint","constructor","arg1","arg2","Array","isArray","_validate","_latitude","_longitude","latitude","longitude","undefined","val","toJSON","__type","equals","other","radiansTo","point","d2r","Math","PI","lat1rad","long1rad","lat2rad","long2rad","sinDeltaLatDiv2","sin","sinDeltaLongDiv2","a","cos","min","asin","sqrt","kilometersTo","milesTo","isNaN","TypeError","current","navigator","geolocation","getCurrentPosition","location","coords","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Creates a new GeoPoint with any of the following forms:<br>\n *   <pre>\n *   new GeoPoint(otherGeoPoint)\n *   new GeoPoint(30, 30)\n *   new GeoPoint([30, 30])\n *   new GeoPoint({latitude: 30, longitude: 30})\n *   new GeoPoint()  // defaults to (0, 0)\n *   </pre>\n * <p>Represents a latitude / longitude point that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Only one key in a class may contain a GeoPoint.</p>\n *\n * <p>Example:<pre>\n *   var point = new Parse.GeoPoint(30.0, -20.0);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"location\", point);\n *   object.save();</pre></p>\n *\n * @alias Parse.GeoPoint\n */\n\n/* global navigator */\n\nclass ParseGeoPoint {\n  /*:: _latitude: number;*/\n\n  /*:: _longitude: number;*/\n\n  /**\n   * @param {(number[] | object | number)} arg1 Either a list of coordinate pairs, an object with `latitude`, `longitude`, or the latitude or the point.\n   * @param {number} arg2 The longitude of the GeoPoint\n   */\n  constructor(arg1\n  /*: Array<number> | { latitude: number, longitude: number } | number*/\n  , arg2\n  /*:: ?: number*/\n  ) {\n    if (Array.isArray(arg1)) {\n      ParseGeoPoint._validate(arg1[0], arg1[1]);\n\n      this._latitude = arg1[0];\n      this._longitude = arg1[1];\n    } else if (typeof arg1 === 'object') {\n      ParseGeoPoint._validate(arg1.latitude, arg1.longitude);\n\n      this._latitude = arg1.latitude;\n      this._longitude = arg1.longitude;\n    } else if (arg1 !== undefined && arg2 !== undefined) {\n      ParseGeoPoint._validate(arg1, arg2);\n\n      this._latitude = arg1;\n      this._longitude = arg2;\n    } else {\n      this._latitude = 0;\n      this._longitude = 0;\n    }\n  }\n  /**\n   * North-south portion of the coordinate, in range [-90, 90].\n   * Throws an exception if set out of range in a modern browser.\n   *\n   * @property {number} latitude\n   * @returns {number}\n   */\n\n\n  get latitude()\n  /*: number*/\n  {\n    return this._latitude;\n  }\n\n  set latitude(val\n  /*: number*/\n  ) {\n    ParseGeoPoint._validate(val, this.longitude);\n\n    this._latitude = val;\n  }\n  /**\n   * East-west portion of the coordinate, in range [-180, 180].\n   * Throws if set out of range in a modern browser.\n   *\n   * @property {number} longitude\n   * @returns {number}\n   */\n\n\n  get longitude()\n  /*: number*/\n  {\n    return this._longitude;\n  }\n\n  set longitude(val\n  /*: number*/\n  ) {\n    ParseGeoPoint._validate(this.latitude, val);\n\n    this._longitude = val;\n  }\n  /**\n   * Returns a JSON representation of the GeoPoint, suitable for Parse.\n   *\n   * @returns {object}\n   */\n\n\n  toJSON()\n  /*: { __type: string, latitude: number, longitude: number }*/\n  {\n    ParseGeoPoint._validate(this._latitude, this._longitude);\n\n    return {\n      __type: 'GeoPoint',\n      latitude: this._latitude,\n      longitude: this._longitude\n    };\n  }\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    return other instanceof ParseGeoPoint && this.latitude === other.latitude && this.longitude === other.longitude;\n  }\n  /**\n   * Returns the distance from this GeoPoint to another in radians.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n\n\n  radiansTo(point\n  /*: ParseGeoPoint*/\n  )\n  /*: number*/\n  {\n    const d2r = Math.PI / 180.0;\n    const lat1rad = this.latitude * d2r;\n    const long1rad = this.longitude * d2r;\n    const lat2rad = point.latitude * d2r;\n    const long2rad = point.longitude * d2r;\n    const sinDeltaLatDiv2 = Math.sin((lat1rad - lat2rad) / 2);\n    const sinDeltaLongDiv2 = Math.sin((long1rad - long2rad) / 2); // Square of half the straight line chord distance between both points.\n\n    let a = sinDeltaLatDiv2 * sinDeltaLatDiv2 + Math.cos(lat1rad) * Math.cos(lat2rad) * sinDeltaLongDiv2 * sinDeltaLongDiv2;\n    a = Math.min(1.0, a);\n    return 2 * Math.asin(Math.sqrt(a));\n  }\n  /**\n   * Returns the distance from this GeoPoint to another in kilometers.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n\n\n  kilometersTo(point\n  /*: ParseGeoPoint*/\n  )\n  /*: number*/\n  {\n    return this.radiansTo(point) * 6371.0;\n  }\n  /**\n   * Returns the distance from this GeoPoint to another in miles.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n\n\n  milesTo(point\n  /*: ParseGeoPoint*/\n  )\n  /*: number*/\n  {\n    return this.radiansTo(point) * 3958.8;\n  }\n  /*\n   * Throws an exception if the given lat-long is out of bounds.\n   */\n\n\n  static _validate(latitude\n  /*: number*/\n  , longitude\n  /*: number*/\n  ) {\n    if (isNaN(latitude) || isNaN(longitude) || typeof latitude !== 'number' || typeof longitude !== 'number') {\n      throw new TypeError('GeoPoint latitude and longitude must be valid numbers');\n    }\n\n    if (latitude < -90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' < -90.0.');\n    }\n\n    if (latitude > 90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' > 90.0.');\n    }\n\n    if (longitude < -180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' < -180.0.');\n    }\n\n    if (longitude > 180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' > 180.0.');\n    }\n  }\n  /**\n   * Creates a GeoPoint with the user's current location, if available.\n   *\n   * @static\n   * @returns {Parse.GeoPoint} User's current location\n   */\n\n\n  static current() {\n    return navigator.geolocation.getCurrentPosition(location => {\n      return new ParseGeoPoint(location.coords.latitude, location.coords.longitude);\n    });\n  }\n\n}\n\nvar _default = ParseGeoPoint;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}