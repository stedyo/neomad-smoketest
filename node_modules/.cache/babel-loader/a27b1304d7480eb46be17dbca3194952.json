{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Represents a Role on the Parse server. Roles represent groupings of\n * Users for the purposes of granting permissions (e.g. specifying an ACL\n * for an Object). Roles are specified by their sets of child users and\n * child roles, all of which are granted any permissions that the parent\n * role has.\n *\n * <p>Roles must have a name (which cannot be changed after creation of the\n * role), and must specify an ACL.</p>\n *\n * @alias Parse.Role\n * @augments Parse.Object\n */\n\n\nclass ParseRole extends _ParseObject.default {\n  /**\n   * @param {string} name The name of the Role to create.\n   * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\n   * A Parse.Role is a local representation of a role persisted to the Parse\n   * cloud.\n   */\n  constructor(name\n  /*: string*/\n  , acl\n  /*: ParseACL*/\n  ) {\n    super('_Role');\n\n    if (typeof name === 'string' && acl instanceof _ParseACL.default) {\n      this.setName(name);\n      this.setACL(acl);\n    }\n  }\n  /**\n   * Gets the name of the role.  You can alternatively call role.get(\"name\")\n   *\n   * @returns {string} the name of the role.\n   */\n\n\n  getName()\n  /*: ?string*/\n  {\n    const name = this.get('name');\n\n    if (name == null || typeof name === 'string') {\n      return name;\n    }\n\n    return '';\n  }\n  /**\n   * Sets the name for a role. This value must be set before the role has\n   * been saved to the server, and cannot be set once the role has been\n   * saved.\n   *\n   * <p>\n   *   A role's name can only contain alphanumeric characters, _, -, and\n   *   spaces.\n   * </p>\n   *\n   * <p>This is equivalent to calling role.set(\"name\", name)</p>\n   *\n   * @param {string} name The name of the role.\n   * @param {object} options Standard options object with success and error\n   *     callbacks.\n   * @returns {(ParseObject|boolean)} true if the set succeeded.\n   */\n\n\n  setName(name\n  /*: string*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set('name', name, options);\n  }\n  /**\n   * Gets the Parse.Relation for the Parse.Users that are direct\n   * children of this role. These users are granted any privileges that this\n   * role has been granted (e.g. read or write access through ACLs). You can\n   * add or remove users from the role through this relation.\n   *\n   * <p>This is equivalent to calling role.relation(\"users\")</p>\n   *\n   * @returns {Parse.Relation} the relation for the users belonging to this\n   *     role.\n   */\n\n\n  getUsers()\n  /*: ParseRelation*/\n  {\n    return this.relation('users');\n  }\n  /**\n   * Gets the Parse.Relation for the Parse.Roles that are direct\n   * children of this role. These roles' users are granted any privileges that\n   * this role has been granted (e.g. read or write access through ACLs). You\n   * can add or remove child roles from this role through this relation.\n   *\n   * <p>This is equivalent to calling role.relation(\"roles\")</p>\n   *\n   * @returns {Parse.Relation} the relation for the roles belonging to this\n   *     role.\n   */\n\n\n  getRoles()\n  /*: ParseRelation*/\n  {\n    return this.relation('roles');\n  }\n\n  validate(attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseError | boolean*/\n  {\n    const isInvalid = super.validate(attrs, options);\n\n    if (isInvalid) {\n      return isInvalid;\n    }\n\n    if ('name' in attrs && attrs.name !== this.getName()) {\n      const newName = attrs.name;\n\n      if (this.id && this.id !== attrs.objectId) {\n        // Check to see if the objectId being set matches this.id\n        // This happens during a fetch -- the id is set before calling fetch\n        // Let the name be set in this case\n        return new _ParseError.default(_ParseError.default.OTHER_CAUSE, \"A role's name can only be set before it has been saved.\");\n      }\n\n      if (typeof newName !== 'string') {\n        return new _ParseError.default(_ParseError.default.OTHER_CAUSE, \"A role's name must be a String.\");\n      }\n\n      if (!/^[0-9a-zA-Z\\-_ ]+$/.test(newName)) {\n        return new _ParseError.default(_ParseError.default.OTHER_CAUSE, \"A role's name can be only contain alphanumeric characters, _, \" + '-, and spaces.');\n      }\n    }\n\n    return false;\n  }\n\n}\n\n_ParseObject.default.registerSubclass('_Role', ParseRole);\n\nvar _default = ParseRole;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseRole.js"],"names":["Object","defineProperty","exports","value","default","_ParseACL","_interopRequireDefault","require","_ParseError","_ParseObject","obj","__esModule","ParseRole","constructor","name","acl","setName","setACL","getName","get","options","set","getUsers","relation","getRoles","validate","attrs","isInvalid","newName","id","objectId","OTHER_CAUSE","test","registerSubclass","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n/**\n * Represents a Role on the Parse server. Roles represent groupings of\n * Users for the purposes of granting permissions (e.g. specifying an ACL\n * for an Object). Roles are specified by their sets of child users and\n * child roles, all of which are granted any permissions that the parent\n * role has.\n *\n * <p>Roles must have a name (which cannot be changed after creation of the\n * role), and must specify an ACL.</p>\n *\n * @alias Parse.Role\n * @augments Parse.Object\n */\n\n\nclass ParseRole extends _ParseObject.default {\n  /**\n   * @param {string} name The name of the Role to create.\n   * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\n   * A Parse.Role is a local representation of a role persisted to the Parse\n   * cloud.\n   */\n  constructor(name\n  /*: string*/\n  , acl\n  /*: ParseACL*/\n  ) {\n    super('_Role');\n\n    if (typeof name === 'string' && acl instanceof _ParseACL.default) {\n      this.setName(name);\n      this.setACL(acl);\n    }\n  }\n  /**\n   * Gets the name of the role.  You can alternatively call role.get(\"name\")\n   *\n   * @returns {string} the name of the role.\n   */\n\n\n  getName()\n  /*: ?string*/\n  {\n    const name = this.get('name');\n\n    if (name == null || typeof name === 'string') {\n      return name;\n    }\n\n    return '';\n  }\n  /**\n   * Sets the name for a role. This value must be set before the role has\n   * been saved to the server, and cannot be set once the role has been\n   * saved.\n   *\n   * <p>\n   *   A role's name can only contain alphanumeric characters, _, -, and\n   *   spaces.\n   * </p>\n   *\n   * <p>This is equivalent to calling role.set(\"name\", name)</p>\n   *\n   * @param {string} name The name of the role.\n   * @param {object} options Standard options object with success and error\n   *     callbacks.\n   * @returns {(ParseObject|boolean)} true if the set succeeded.\n   */\n\n\n  setName(name\n  /*: string*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseObject | boolean*/\n  {\n    return this.set('name', name, options);\n  }\n  /**\n   * Gets the Parse.Relation for the Parse.Users that are direct\n   * children of this role. These users are granted any privileges that this\n   * role has been granted (e.g. read or write access through ACLs). You can\n   * add or remove users from the role through this relation.\n   *\n   * <p>This is equivalent to calling role.relation(\"users\")</p>\n   *\n   * @returns {Parse.Relation} the relation for the users belonging to this\n   *     role.\n   */\n\n\n  getUsers()\n  /*: ParseRelation*/\n  {\n    return this.relation('users');\n  }\n  /**\n   * Gets the Parse.Relation for the Parse.Roles that are direct\n   * children of this role. These roles' users are granted any privileges that\n   * this role has been granted (e.g. read or write access through ACLs). You\n   * can add or remove child roles from this role through this relation.\n   *\n   * <p>This is equivalent to calling role.relation(\"roles\")</p>\n   *\n   * @returns {Parse.Relation} the relation for the roles belonging to this\n   *     role.\n   */\n\n\n  getRoles()\n  /*: ParseRelation*/\n  {\n    return this.relation('roles');\n  }\n\n  validate(attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: mixed*/\n  )\n  /*: ParseError | boolean*/\n  {\n    const isInvalid = super.validate(attrs, options);\n\n    if (isInvalid) {\n      return isInvalid;\n    }\n\n    if ('name' in attrs && attrs.name !== this.getName()) {\n      const newName = attrs.name;\n\n      if (this.id && this.id !== attrs.objectId) {\n        // Check to see if the objectId being set matches this.id\n        // This happens during a fetch -- the id is set before calling fetch\n        // Let the name be set in this case\n        return new _ParseError.default(_ParseError.default.OTHER_CAUSE, \"A role's name can only be set before it has been saved.\");\n      }\n\n      if (typeof newName !== 'string') {\n        return new _ParseError.default(_ParseError.default.OTHER_CAUSE, \"A role's name must be a String.\");\n      }\n\n      if (!/^[0-9a-zA-Z\\-_ ]+$/.test(newName)) {\n        return new _ParseError.default(_ParseError.default.OTHER_CAUSE, \"A role's name can be only contain alphanumeric characters, _, \" + '-, and spaces.');\n      }\n    }\n\n    return false;\n  }\n\n}\n\n_ParseObject.default.registerSubclass('_Role', ParseRole);\n\nvar _default = ParseRole;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}