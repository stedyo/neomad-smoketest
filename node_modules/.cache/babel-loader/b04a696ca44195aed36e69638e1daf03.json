{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst ParseError = require('./ParseError').default;\n\nlet XHR = null;\n\nif (typeof XMLHttpRequest !== 'undefined') {\n  XHR = XMLHttpRequest;\n}\n/*:: type Base64 = { base64: string };*/\n\n/*:: type Uri = { uri: string };*/\n\n/*:: type FileData = Array<number> | Base64 | Blob | Uri;*/\n\n/*:: export type FileSource =\n  | {\n      format: 'file',\n      file: Blob,\n      type: string,\n    }\n  | {\n      format: 'base64',\n      base64: string,\n      type: string,\n    }\n  | {\n      format: 'uri',\n      uri: string,\n      type: string,\n    };*/\n\n\nconst dataUriRegexp = /^data:([a-zA-Z]+\\/[-a-zA-Z0-9+.]+)(;charset=[a-zA-Z0-9\\-\\/]*)?;base64,/;\n\nfunction b64Digit(number\n/*: number*/\n)\n/*: string*/\n{\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n\n  if (number === 62) {\n    return '+';\n  }\n\n  if (number === 63) {\n    return '/';\n  }\n\n  throw new TypeError('Tried to encode large digit ' + number + ' in base64.');\n}\n/**\n * A Parse.File is a local representation of a file that is saved to the Parse\n * cloud.\n *\n * @alias Parse.File\n */\n\n\nclass ParseFile {\n  /*:: _name: string;*/\n\n  /*:: _url: ?string;*/\n\n  /*:: _source: FileSource;*/\n\n  /*:: _previousSave: ?Promise<ParseFile>;*/\n\n  /*:: _data: ?string;*/\n\n  /*:: _requestTask: ?any;*/\n\n  /*:: _metadata: ?Object;*/\n\n  /*:: _tags: ?Object;*/\n\n  /**\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers, or\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. an Object like { uri: \"...\" } with a uri String.\n   *     4. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:\n   * <pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   * @param metadata {Object} Optional key value pairs to be stored with file object\n   * @param tags {Object} Optional key value pairs to be stored with file object\n   */\n  constructor(name\n  /*: string*/\n  , data\n  /*:: ?: FileData*/\n  , type\n  /*:: ?: string*/\n  , metadata\n  /*:: ?: Object*/\n  , tags\n  /*:: ?: Object*/\n  ) {\n    const specifiedType = type || '';\n    this._name = name;\n    this._metadata = metadata || {};\n    this._tags = tags || {};\n\n    if (data !== undefined) {\n      if (Array.isArray(data)) {\n        this._data = ParseFile.encodeBase64(data);\n        this._source = {\n          format: 'base64',\n          base64: this._data,\n          type: specifiedType\n        };\n      } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n        this._source = {\n          format: 'file',\n          file: data,\n          type: specifiedType\n        };\n      } else if (data && typeof data.uri === 'string' && data.uri !== undefined) {\n        this._source = {\n          format: 'uri',\n          uri: data.uri,\n          type: specifiedType\n        };\n      } else if (data && typeof data.base64 === 'string') {\n        const base64 = data.base64;\n        const commaIndex = base64.indexOf(',');\n\n        if (commaIndex !== -1) {\n          const matches = dataUriRegexp.exec(base64.slice(0, commaIndex + 1)); // if data URI with type and charset, there will be 4 matches.\n\n          this._data = base64.slice(commaIndex + 1);\n          this._source = {\n            format: 'base64',\n            base64: this._data,\n            type: matches[1]\n          };\n        } else {\n          this._data = base64;\n          this._source = {\n            format: 'base64',\n            base64: base64,\n            type: specifiedType\n          };\n        }\n      } else {\n        throw new TypeError('Cannot create a Parse.File with that data.');\n      }\n    }\n  }\n  /**\n   * Return the data for the file, downloading it if not already present.\n   * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n   * Data is cleared if saved with File object selected with a file upload control\n   *\n   * @returns {Promise} Promise that is resolve with base64 data\n   */\n\n\n  async getData()\n  /*: Promise<String>*/\n  {\n    if (this._data) {\n      return this._data;\n    }\n\n    if (!this._url) {\n      throw new Error('Cannot retrieve data for unsaved ParseFile.');\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    const result = await controller.download(this._url, {\n      requestTask: task => this._requestTask = task\n    });\n    this._data = result.base64;\n    return this._data;\n  }\n  /**\n   * Gets the name of the file. Before save is called, this is the filename\n   * given by the user. After save is called, that name gets prefixed with a\n   * unique identifier.\n   *\n   * @returns {string}\n   */\n\n\n  name()\n  /*: string*/\n  {\n    return this._name;\n  }\n  /**\n   * Gets the url of the file. It is only available after you save the file or\n   * after you get the file from a Parse.Object.\n   *\n   * @param {object} options An object to specify url options\n   * @returns {string}\n   */\n\n\n  url(options\n  /*:: ?: { forceSecure?: boolean }*/\n  )\n  /*: ?string*/\n  {\n    options = options || {};\n\n    if (!this._url) {\n      return;\n    }\n\n    if (options.forceSecure) {\n      return this._url.replace(/^http:\\/\\//i, 'https://');\n    } else {\n      return this._url;\n    }\n  }\n  /**\n   * Gets the metadata of the file.\n   *\n   * @returns {object}\n   */\n\n\n  metadata()\n  /*: Object*/\n  {\n    return this._metadata;\n  }\n  /**\n   * Gets the tags of the file.\n   *\n   * @returns {object}\n   */\n\n\n  tags()\n  /*: Object*/\n  {\n    return this._tags;\n  }\n  /**\n   * Saves the file to the Parse cloud.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *     behalf of a specific user.\n   *   <li>progress: In Browser only, callback for upload progress. For example:\n   * <pre>\n   * let parseFile = new Parse.File(name, file);\n   * parseFile.save({\n   *   progress: (progressValue, loaded, total, { type }) => {\n   *     if (type === \"upload\" && progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * </ul>\n   * @returns {Promise} Promise that is resolved when the save finishes.\n   */\n\n\n  save(options\n  /*:: ?: FullOptions*/\n  ) {\n    options = options || {};\n\n    options.requestTask = task => this._requestTask = task;\n\n    options.metadata = this._metadata;\n    options.tags = this._tags;\n\n    const controller = _CoreManager.default.getFileController();\n\n    if (!this._previousSave) {\n      if (this._source.format === 'file') {\n        this._previousSave = controller.saveFile(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._data = null;\n          this._requestTask = null;\n          return this;\n        });\n      } else if (this._source.format === 'uri') {\n        this._previousSave = controller.download(this._source.uri, options).then(result => {\n          if (!(result && result.base64)) {\n            return {};\n          }\n\n          const newSource = {\n            format: 'base64',\n            base64: result.base64,\n            type: result.contentType\n          };\n          this._data = result.base64;\n          this._requestTask = null;\n          return controller.saveBase64(this._name, newSource, options);\n        }).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      } else {\n        this._previousSave = controller.saveBase64(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      }\n    }\n\n    if (this._previousSave) {\n      return this._previousSave;\n    }\n  }\n  /**\n   * Aborts the request if it has already been sent.\n   */\n\n\n  cancel() {\n    if (this._requestTask && typeof this._requestTask.abort === 'function') {\n      this._requestTask.abort();\n    }\n\n    this._requestTask = null;\n  }\n  /**\n   * Deletes the file from the Parse cloud.\n   * In Cloud Code and Node only with Master Key.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * <pre>\n   * @returns {Promise} Promise that is resolved when the delete finishes.\n   */\n\n\n  destroy(options\n  /*:: ?: FullOptions*/\n  = {}) {\n    if (!this._name) {\n      throw new ParseError(ParseError.FILE_DELETE_UNNAMED_ERROR, 'Cannot delete an unnamed file.');\n    }\n\n    const destroyOptions = {\n      useMasterKey: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    return controller.deleteFile(this._name, destroyOptions).then(() => {\n      this._data = null;\n      this._requestTask = null;\n      return this;\n    });\n  }\n\n  toJSON()\n  /*: { name: ?string, url: ?string }*/\n  {\n    return {\n      __type: 'File',\n      name: this._name,\n      url: this._url\n    };\n  }\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (this === other) {\n      return true;\n    } // Unsaved Files are never equal, since they will be saved to different URLs\n\n\n    return other instanceof ParseFile && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== 'undefined';\n  }\n  /**\n   * Sets metadata to be saved with file object. Overwrites existing metadata\n   *\n   * @param {object} metadata Key value pairs to be stored with file object\n   */\n\n\n  setMetadata(metadata\n  /*: any*/\n  ) {\n    if (metadata && typeof metadata === 'object') {\n      Object.keys(metadata).forEach(key => {\n        this.addMetadata(key, metadata[key]);\n      });\n    }\n  }\n  /**\n   * Sets metadata to be saved with file object. Adds to existing metadata.\n   *\n   * @param {string} key key to store the metadata\n   * @param {*} value metadata\n   */\n\n\n  addMetadata(key\n  /*: string*/\n  , value\n  /*: any*/\n  ) {\n    if (typeof key === 'string') {\n      this._metadata[key] = value;\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Overwrites existing tags\n   *\n   * @param {object} tags Key value pairs to be stored with file object\n   */\n\n\n  setTags(tags\n  /*: any*/\n  ) {\n    if (tags && typeof tags === 'object') {\n      Object.keys(tags).forEach(key => {\n        this.addTag(key, tags[key]);\n      });\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Adds to existing tags.\n   *\n   * @param {string} key key to store tags\n   * @param {*} value tag\n   */\n\n\n  addTag(key\n  /*: string*/\n  , value\n  /*: string*/\n  ) {\n    if (typeof key === 'string') {\n      this._tags[key] = value;\n    }\n  }\n\n  static fromJSON(obj)\n  /*: ParseFile*/\n  {\n    if (obj.__type !== 'File') {\n      throw new TypeError('JSON object does not represent a ParseFile');\n    }\n\n    const file = new ParseFile(obj.name);\n    file._url = obj.url;\n    return file;\n  }\n\n  static encodeBase64(bytes\n  /*: Array<number>*/\n  )\n  /*: string*/\n  {\n    const chunks = [];\n    chunks.length = Math.ceil(bytes.length / 3);\n\n    for (let i = 0; i < chunks.length; i++) {\n      const b1 = bytes[i * 3];\n      const b2 = bytes[i * 3 + 1] || 0;\n      const b3 = bytes[i * 3 + 2] || 0;\n      const has2 = i * 3 + 1 < bytes.length;\n      const has3 = i * 3 + 2 < bytes.length;\n      chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n    }\n\n    return chunks.join('');\n  }\n\n}\n\nconst DefaultController = {\n  saveFile: async function (name\n  /*: string*/\n  , source\n  /*: FileSource*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (source.format !== 'file') {\n      throw new Error('saveFile can only be used with File-type sources.');\n    }\n\n    const base64Data = await new Promise((res, rej) => {\n      // eslint-disable-next-line no-undef\n      const reader = new FileReader();\n\n      reader.onload = () => res(reader.result);\n\n      reader.onerror = error => rej(error);\n\n      reader.readAsDataURL(source.file);\n    }); // we only want the data after the comma\n    // For example: \"data:application/pdf;base64,JVBERi0xLjQKJ...\" we would only want \"JVBERi0xLjQKJ...\"\n\n    const [first, second] = base64Data.split(','); // in the event there is no 'data:application/pdf;base64,' at the beginning of the base64 string\n    // use the entire string instead\n\n    const data = second ? second : first;\n    const newSource = {\n      format: 'base64',\n      base64: data,\n      type: source.type || (source.file ? source.file.type : null)\n    };\n    return await DefaultController.saveBase64(name, newSource, options);\n  },\n  saveBase64: function (name\n  /*: string*/\n  , source\n  /*: FileSource*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (source.format !== 'base64') {\n      throw new Error('saveBase64 can only be used with Base64-type sources.');\n    }\n\n    const data\n    /*: { base64: any, _ContentType?: any, fileData: Object }*/\n    = {\n      base64: source.base64,\n      fileData: {\n        metadata: _objectSpread({}, options.metadata),\n        tags: _objectSpread({}, options.tags)\n      }\n    };\n    delete options.metadata;\n    delete options.tags;\n\n    if (source.type) {\n      data._ContentType = source.type;\n    }\n\n    return _CoreManager.default.getRESTController().request('POST', 'files/' + name, data, options);\n  },\n  download: function (uri, options) {\n    if (XHR) {\n      return this.downloadAjax(uri, options);\n    } else {\n      return new Promise((resolve, reject) => {\n        const client = uri.indexOf('https') === 0 ? require('https') : require('http');\n        const req = client.get(uri, resp => {\n          resp.setEncoding('base64');\n          let base64 = '';\n          resp.on('data', data => base64 += data);\n          resp.on('end', () => {\n            resolve({\n              base64,\n              contentType: resp.headers['content-type']\n            });\n          });\n        });\n        req.on('abort', () => {\n          resolve({});\n        });\n        req.on('error', reject);\n        options.requestTask(req);\n      });\n    }\n  },\n  downloadAjax: function (uri, options) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XHR();\n      xhr.open('GET', uri, true);\n      xhr.responseType = 'arraybuffer';\n\n      xhr.onerror = function (e) {\n        reject(e);\n      };\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState !== xhr.DONE) {\n          return;\n        }\n\n        if (!this.response) {\n          return resolve({});\n        }\n\n        const bytes = new Uint8Array(this.response);\n        resolve({\n          base64: ParseFile.encodeBase64(bytes),\n          contentType: xhr.getResponseHeader('content-type')\n        });\n      };\n\n      options.requestTask(xhr);\n      xhr.send();\n    });\n  },\n  deleteFile: function (name\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    const headers = {\n      'X-Parse-Application-ID': _CoreManager.default.get('APPLICATION_ID')\n    };\n\n    if (options.useMasterKey) {\n      headers['X-Parse-Master-Key'] = _CoreManager.default.get('MASTER_KEY');\n    }\n\n    let url = _CoreManager.default.get('SERVER_URL');\n\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n\n    url += 'files/' + name;\n    return _CoreManager.default.getRESTController().ajax('DELETE', url, '', headers).catch(response => {\n      // TODO: return JSON object in server\n      if (!response || response === 'SyntaxError: Unexpected end of JSON input') {\n        return Promise.resolve();\n      } else {\n        return _CoreManager.default.getRESTController().handleError(response);\n      }\n    });\n  },\n\n  _setXHR(xhr\n  /*: any*/\n  ) {\n    XHR = xhr;\n  },\n\n  _getXHR() {\n    return XHR;\n  }\n\n};\n\n_CoreManager.default.setFileController(DefaultController);\n\nvar _default = ParseFile;\nexports.default = _default;\nexports.b64Digit = b64Digit;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseFile.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","ParseError","XHR","XMLHttpRequest","dataUriRegexp","b64Digit","number","String","fromCharCode","TypeError","ParseFile","constructor","name","data","type","metadata","tags","specifiedType","_name","_metadata","_tags","undefined","Array","isArray","_data","encodeBase64","_source","format","base64","Blob","file","uri","commaIndex","indexOf","matches","exec","slice","getData","_url","Error","controller","getFileController","result","download","requestTask","task","_requestTask","url","options","forceSecure","replace","save","_previousSave","saveFile","then","res","newSource","contentType","saveBase64","cancel","abort","destroy","FILE_DELETE_UNNAMED_ERROR","destroyOptions","useMasterKey","hasOwnProperty","deleteFile","toJSON","__type","equals","other","setMetadata","addMetadata","setTags","addTag","fromJSON","bytes","chunks","Math","ceil","b1","b2","b3","has2","has3","join","DefaultController","base64Data","Promise","rej","reader","FileReader","onload","onerror","error","readAsDataURL","first","second","split","fileData","_ContentType","getRESTController","request","downloadAjax","resolve","reject","client","req","get","resp","setEncoding","on","headers","xhr","open","responseType","e","onreadystatechange","readyState","DONE","response","Uint8Array","getResponseHeader","send","ajax","catch","handleError","_setXHR","_getXHR","setFileController","_default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,YAAY,GAAGC,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAAzC;;AAEA,SAASD,sBAAT,CAAgCE,GAAhC,EAAqC;AACnC,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AACnCJ,IAAAA,OAAO,EAAEI;AAD0B,GAArC;AAGD;;AAED,SAASE,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AACvC,MAAIC,IAAI,GAAGb,MAAM,CAACa,IAAP,CAAYF,MAAZ,CAAX;;AAEA,MAAIX,MAAM,CAACc,qBAAX,EAAkC;AAChC,QAAIC,OAAO,GAAGf,MAAM,CAACc,qBAAP,CAA6BH,MAA7B,CAAd;AACAC,IAAAA,cAAc,KAAKG,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AACzD,aAAOjB,MAAM,CAACkB,wBAAP,CAAgCP,MAAhC,EAAwCM,GAAxC,EAA6CE,UAApD;AACD,KAF4B,CAAf,CAAd,EAEKN,IAAI,CAACO,IAAL,CAAUC,KAAV,CAAgBR,IAAhB,EAAsBE,OAAtB,CAFL;AAGD;;AAED,SAAOF,IAAP;AACD;;AAED,SAASS,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AACzC,QAAIG,MAAM,GAAG,QAAQF,SAAS,CAACD,CAAD,CAAjB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;AACAA,IAAAA,CAAC,GAAG,CAAJ,GAAQd,OAAO,CAACV,MAAM,CAAC2B,MAAD,CAAP,EAAiB,CAAC,CAAlB,CAAP,CAA4BC,OAA5B,CAAoC,UAAUC,GAAV,EAAe;AACzDC,MAAAA,eAAe,CAACP,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AACD,KAFO,CAAR,GAEK7B,MAAM,CAAC+B,yBAAP,GAAmC/B,MAAM,CAACgC,gBAAP,CAAwBT,MAAxB,EAAgCvB,MAAM,CAAC+B,yBAAP,CAAiCJ,MAAjC,CAAhC,CAAnC,GAA+GjB,OAAO,CAACV,MAAM,CAAC2B,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AACjK7B,MAAAA,MAAM,CAACC,cAAP,CAAsBsB,MAAtB,EAA8BM,GAA9B,EAAmC7B,MAAM,CAACkB,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AACD,KAFmH,CAFpH;AAKD;;AAED,SAAON,MAAP;AACD;;AAED,SAASO,eAAT,CAAyBtB,GAAzB,EAA8BqB,GAA9B,EAAmC1B,KAAnC,EAA0C;AACxC,MAAI0B,GAAG,IAAIrB,GAAX,EAAgB;AACdR,IAAAA,MAAM,CAACC,cAAP,CAAsBO,GAAtB,EAA2BqB,GAA3B,EAAgC;AAC9B1B,MAAAA,KAAK,EAAEA,KADuB;AAE9BgB,MAAAA,UAAU,EAAE,IAFkB;AAG9Bc,MAAAA,YAAY,EAAE,IAHgB;AAI9BC,MAAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACL1B,IAAAA,GAAG,CAACqB,GAAD,CAAH,GAAW1B,KAAX;AACD;;AAED,SAAOK,GAAP;AACD;;AAED,MAAM2B,UAAU,GAAG5B,OAAO,CAAC,cAAD,CAAP,CAAwBH,OAA3C;;AAEA,IAAIgC,GAAG,GAAG,IAAV;;AAEA,IAAI,OAAOC,cAAP,KAA0B,WAA9B,EAA2C;AACzCD,EAAAA,GAAG,GAAGC,cAAN;AACD;AAED;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;AAgBA,MAAMC,aAAa,GAAG,wEAAtB;;AAEA,SAASC,QAAT,CAAkBC;AAClB;AADA;AAGA;AACA;AACE,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,KAAKF,MAAzB,CAAP;AACD;;AAED,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,MAAMF,MAAM,GAAG,EAAf,CAApB,CAAP;AACD;;AAED,MAAIA,MAAM,GAAG,EAAb,EAAiB;AACf,WAAOC,MAAM,CAACC,YAAP,CAAoB,MAAMF,MAAM,GAAG,EAAf,CAApB,CAAP;AACD;;AAED,MAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB,WAAO,GAAP;AACD;;AAED,MAAIA,MAAM,KAAK,EAAf,EAAmB;AACjB,WAAO,GAAP;AACD;;AAED,QAAM,IAAIG,SAAJ,CAAc,iCAAiCH,MAAjC,GAA0C,aAAxD,CAAN;AACD;AACD;;;;;;;;AAQA,MAAMI,SAAN,CAAgB;AACd;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BAC,EAAAA,WAAW,CAACC;AACZ;AADW,IAETC;AACF;AAHW,IAITC;AACF;AALW,IAMTC;AACF;AAPW,IAQTC;AACF;AATW,IAUT;AACA,UAAMC,aAAa,GAAGH,IAAI,IAAI,EAA9B;AACA,SAAKI,KAAL,GAAaN,IAAb;AACA,SAAKO,SAAL,GAAiBJ,QAAQ,IAAI,EAA7B;AACA,SAAKK,KAAL,GAAaJ,IAAI,IAAI,EAArB;;AAEA,QAAIH,IAAI,KAAKQ,SAAb,EAAwB;AACtB,UAAIC,KAAK,CAACC,OAAN,CAAcV,IAAd,CAAJ,EAAyB;AACvB,aAAKW,KAAL,GAAad,SAAS,CAACe,YAAV,CAAuBZ,IAAvB,CAAb;AACA,aAAKa,OAAL,GAAe;AACbC,UAAAA,MAAM,EAAE,QADK;AAEbC,UAAAA,MAAM,EAAE,KAAKJ,KAFA;AAGbV,UAAAA,IAAI,EAAEG;AAHO,SAAf;AAKD,OAPD,MAOO,IAAI,OAAOY,IAAP,KAAgB,WAAhB,IAA+BhB,IAAI,YAAYgB,IAAnD,EAAyD;AAC9D,aAAKH,OAAL,GAAe;AACbC,UAAAA,MAAM,EAAE,MADK;AAEbG,UAAAA,IAAI,EAAEjB,IAFO;AAGbC,UAAAA,IAAI,EAAEG;AAHO,SAAf;AAKD,OANM,MAMA,IAAIJ,IAAI,IAAI,OAAOA,IAAI,CAACkB,GAAZ,KAAoB,QAA5B,IAAwClB,IAAI,CAACkB,GAAL,KAAaV,SAAzD,EAAoE;AACzE,aAAKK,OAAL,GAAe;AACbC,UAAAA,MAAM,EAAE,KADK;AAEbI,UAAAA,GAAG,EAAElB,IAAI,CAACkB,GAFG;AAGbjB,UAAAA,IAAI,EAAEG;AAHO,SAAf;AAKD,OANM,MAMA,IAAIJ,IAAI,IAAI,OAAOA,IAAI,CAACe,MAAZ,KAAuB,QAAnC,EAA6C;AAClD,cAAMA,MAAM,GAAGf,IAAI,CAACe,MAApB;AACA,cAAMI,UAAU,GAAGJ,MAAM,CAACK,OAAP,CAAe,GAAf,CAAnB;;AAEA,YAAID,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrB,gBAAME,OAAO,GAAG9B,aAAa,CAAC+B,IAAd,CAAmBP,MAAM,CAACQ,KAAP,CAAa,CAAb,EAAgBJ,UAAU,GAAG,CAA7B,CAAnB,CAAhB,CADqB,CACgD;;AAErE,eAAKR,KAAL,GAAaI,MAAM,CAACQ,KAAP,CAAaJ,UAAU,GAAG,CAA1B,CAAb;AACA,eAAKN,OAAL,GAAe;AACbC,YAAAA,MAAM,EAAE,QADK;AAEbC,YAAAA,MAAM,EAAE,KAAKJ,KAFA;AAGbV,YAAAA,IAAI,EAAEoB,OAAO,CAAC,CAAD;AAHA,WAAf;AAKD,SATD,MASO;AACL,eAAKV,KAAL,GAAaI,MAAb;AACA,eAAKF,OAAL,GAAe;AACbC,YAAAA,MAAM,EAAE,QADK;AAEbC,YAAAA,MAAM,EAAEA,MAFK;AAGbd,YAAAA,IAAI,EAAEG;AAHO,WAAf;AAKD;AACF,OArBM,MAqBA;AACL,cAAM,IAAIR,SAAJ,CAAc,4CAAd,CAAN;AACD;AACF;AACF;AACD;;;;;;;;;AASA,QAAM4B,OAAN;AACA;AACA;AACE,QAAI,KAAKb,KAAT,EAAgB;AACd,aAAO,KAAKA,KAAZ;AACD;;AAED,QAAI,CAAC,KAAKc,IAAV,EAAgB;AACd,YAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;AACD;;AAED,UAAMC,UAAU,GAAGrE,YAAY,CAACD,OAAb,CAAqBuE,iBAArB,EAAnB;;AAEA,UAAMC,MAAM,GAAG,MAAMF,UAAU,CAACG,QAAX,CAAoB,KAAKL,IAAzB,EAA+B;AAClDM,MAAAA,WAAW,EAAEC,IAAI,IAAI,KAAKC,YAAL,GAAoBD;AADS,KAA/B,CAArB;AAGA,SAAKrB,KAAL,GAAakB,MAAM,CAACd,MAApB;AACA,WAAO,KAAKJ,KAAZ;AACD;AACD;;;;;;;;;AASAZ,EAAAA,IAAI;AACJ;AACA;AACE,WAAO,KAAKM,KAAZ;AACD;AACD;;;;;;;;;AASA6B,EAAAA,GAAG,CAACC;AACJ;AADG;AAGH;AACA;AACEA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,QAAI,CAAC,KAAKV,IAAV,EAAgB;AACd;AACD;;AAED,QAAIU,OAAO,CAACC,WAAZ,EAAyB;AACvB,aAAO,KAAKX,IAAL,CAAUY,OAAV,CAAkB,aAAlB,EAAiC,UAAjC,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKZ,IAAZ;AACD;AACF;AACD;;;;;;;AAOAvB,EAAAA,QAAQ;AACR;AACA;AACE,WAAO,KAAKI,SAAZ;AACD;AACD;;;;;;;AAOAH,EAAAA,IAAI;AACJ;AACA;AACE,WAAO,KAAKI,KAAZ;AACD;AACD;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA+B,EAAAA,IAAI,CAACH;AACL;AADI,IAEF;AACAA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEAA,IAAAA,OAAO,CAACJ,WAAR,GAAsBC,IAAI,IAAI,KAAKC,YAAL,GAAoBD,IAAlD;;AAEAG,IAAAA,OAAO,CAACjC,QAAR,GAAmB,KAAKI,SAAxB;AACA6B,IAAAA,OAAO,CAAChC,IAAR,GAAe,KAAKI,KAApB;;AAEA,UAAMoB,UAAU,GAAGrE,YAAY,CAACD,OAAb,CAAqBuE,iBAArB,EAAnB;;AAEA,QAAI,CAAC,KAAKW,aAAV,EAAyB;AACvB,UAAI,KAAK1B,OAAL,CAAaC,MAAb,KAAwB,MAA5B,EAAoC;AAClC,aAAKyB,aAAL,GAAqBZ,UAAU,CAACa,QAAX,CAAoB,KAAKnC,KAAzB,EAAgC,KAAKQ,OAArC,EAA8CsB,OAA9C,EAAuDM,IAAvD,CAA4DC,GAAG,IAAI;AACtF,eAAKrC,KAAL,GAAaqC,GAAG,CAAC3C,IAAjB;AACA,eAAK0B,IAAL,GAAYiB,GAAG,CAACR,GAAhB;AACA,eAAKvB,KAAL,GAAa,IAAb;AACA,eAAKsB,YAAL,GAAoB,IAApB;AACA,iBAAO,IAAP;AACD,SANoB,CAArB;AAOD,OARD,MAQO,IAAI,KAAKpB,OAAL,CAAaC,MAAb,KAAwB,KAA5B,EAAmC;AACxC,aAAKyB,aAAL,GAAqBZ,UAAU,CAACG,QAAX,CAAoB,KAAKjB,OAAL,CAAaK,GAAjC,EAAsCiB,OAAtC,EAA+CM,IAA/C,CAAoDZ,MAAM,IAAI;AACjF,cAAI,EAAEA,MAAM,IAAIA,MAAM,CAACd,MAAnB,CAAJ,EAAgC;AAC9B,mBAAO,EAAP;AACD;;AAED,gBAAM4B,SAAS,GAAG;AAChB7B,YAAAA,MAAM,EAAE,QADQ;AAEhBC,YAAAA,MAAM,EAAEc,MAAM,CAACd,MAFC;AAGhBd,YAAAA,IAAI,EAAE4B,MAAM,CAACe;AAHG,WAAlB;AAKA,eAAKjC,KAAL,GAAakB,MAAM,CAACd,MAApB;AACA,eAAKkB,YAAL,GAAoB,IAApB;AACA,iBAAON,UAAU,CAACkB,UAAX,CAAsB,KAAKxC,KAA3B,EAAkCsC,SAAlC,EAA6CR,OAA7C,CAAP;AACD,SAboB,EAalBM,IAbkB,CAabC,GAAG,IAAI;AACb,eAAKrC,KAAL,GAAaqC,GAAG,CAAC3C,IAAjB;AACA,eAAK0B,IAAL,GAAYiB,GAAG,CAACR,GAAhB;AACA,eAAKD,YAAL,GAAoB,IAApB;AACA,iBAAO,IAAP;AACD,SAlBoB,CAArB;AAmBD,OApBM,MAoBA;AACL,aAAKM,aAAL,GAAqBZ,UAAU,CAACkB,UAAX,CAAsB,KAAKxC,KAA3B,EAAkC,KAAKQ,OAAvC,EAAgDsB,OAAhD,EAAyDM,IAAzD,CAA8DC,GAAG,IAAI;AACxF,eAAKrC,KAAL,GAAaqC,GAAG,CAAC3C,IAAjB;AACA,eAAK0B,IAAL,GAAYiB,GAAG,CAACR,GAAhB;AACA,eAAKD,YAAL,GAAoB,IAApB;AACA,iBAAO,IAAP;AACD,SALoB,CAArB;AAMD;AACF;;AAED,QAAI,KAAKM,aAAT,EAAwB;AACtB,aAAO,KAAKA,aAAZ;AACD;AACF;AACD;;;;;AAKAO,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKb,YAAL,IAAqB,OAAO,KAAKA,YAAL,CAAkBc,KAAzB,KAAmC,UAA5D,EAAwE;AACtE,WAAKd,YAAL,CAAkBc,KAAlB;AACD;;AAED,SAAKd,YAAL,GAAoB,IAApB;AACD;AACD;;;;;;;;;;;;;AAaAe,EAAAA,OAAO,CAACb;AACR;AADe,IAEb,EAFK,EAED;AACJ,QAAI,CAAC,KAAK9B,KAAV,EAAiB;AACf,YAAM,IAAIjB,UAAJ,CAAeA,UAAU,CAAC6D,yBAA1B,EAAqD,gCAArD,CAAN;AACD;;AAED,UAAMC,cAAc,GAAG;AACrBC,MAAAA,YAAY,EAAE;AADO,KAAvB;;AAIA,QAAIhB,OAAO,CAACiB,cAAR,CAAuB,cAAvB,CAAJ,EAA4C;AAC1CF,MAAAA,cAAc,CAACC,YAAf,GAA8BhB,OAAO,CAACgB,YAAtC;AACD;;AAED,UAAMxB,UAAU,GAAGrE,YAAY,CAACD,OAAb,CAAqBuE,iBAArB,EAAnB;;AAEA,WAAOD,UAAU,CAAC0B,UAAX,CAAsB,KAAKhD,KAA3B,EAAkC6C,cAAlC,EAAkDT,IAAlD,CAAuD,MAAM;AAClE,WAAK9B,KAAL,GAAa,IAAb;AACA,WAAKsB,YAAL,GAAoB,IAApB;AACA,aAAO,IAAP;AACD,KAJM,CAAP;AAKD;;AAEDqB,EAAAA,MAAM;AACN;AACA;AACE,WAAO;AACLC,MAAAA,MAAM,EAAE,MADH;AAELxD,MAAAA,IAAI,EAAE,KAAKM,KAFN;AAGL6B,MAAAA,GAAG,EAAE,KAAKT;AAHL,KAAP;AAKD;;AAED+B,EAAAA,MAAM,CAACC;AACP;AADM;AAGN;AACA;AACE,QAAI,SAASA,KAAb,EAAoB;AAClB,aAAO,IAAP;AACD,KAHH,CAGI;;;AAGF,WAAOA,KAAK,YAAY5D,SAAjB,IAA8B,KAAKE,IAAL,OAAgB0D,KAAK,CAAC1D,IAAN,EAA9C,IAA8D,KAAKmC,GAAL,OAAeuB,KAAK,CAACvB,GAAN,EAA7E,IAA4F,OAAO,KAAKA,GAAL,EAAP,KAAsB,WAAzH;AACD;AACD;;;;;;;AAOAwB,EAAAA,WAAW,CAACxD;AACZ;AADW,IAET;AACA,QAAIA,QAAQ,IAAI,OAAOA,QAAP,KAAoB,QAApC,EAA8C;AAC5CjD,MAAAA,MAAM,CAACa,IAAP,CAAYoC,QAAZ,EAAsBrB,OAAtB,CAA8BC,GAAG,IAAI;AACnC,aAAK6E,WAAL,CAAiB7E,GAAjB,EAAsBoB,QAAQ,CAACpB,GAAD,CAA9B;AACD,OAFD;AAGD;AACF;AACD;;;;;;;;AAQA6E,EAAAA,WAAW,CAAC7E;AACZ;AADW,IAET1B;AACF;AAHW,IAIT;AACA,QAAI,OAAO0B,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAKwB,SAAL,CAAexB,GAAf,IAAsB1B,KAAtB;AACD;AACF;AACD;;;;;;;AAOAwG,EAAAA,OAAO,CAACzD;AACR;AADO,IAEL;AACA,QAAIA,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AACpClD,MAAAA,MAAM,CAACa,IAAP,CAAYqC,IAAZ,EAAkBtB,OAAlB,CAA0BC,GAAG,IAAI;AAC/B,aAAK+E,MAAL,CAAY/E,GAAZ,EAAiBqB,IAAI,CAACrB,GAAD,CAArB;AACD,OAFD;AAGD;AACF;AACD;;;;;;;;AAQA+E,EAAAA,MAAM,CAAC/E;AACP;AADM,IAEJ1B;AACF;AAHM,IAIJ;AACA,QAAI,OAAO0B,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAKyB,KAAL,CAAWzB,GAAX,IAAkB1B,KAAlB;AACD;AACF;;AAED,SAAO0G,QAAP,CAAgBrG,GAAhB;AACA;AACA;AACE,QAAIA,GAAG,CAAC8F,MAAJ,KAAe,MAAnB,EAA2B;AACzB,YAAM,IAAI3D,SAAJ,CAAc,4CAAd,CAAN;AACD;;AAED,UAAMqB,IAAI,GAAG,IAAIpB,SAAJ,CAAcpC,GAAG,CAACsC,IAAlB,CAAb;AACAkB,IAAAA,IAAI,CAACQ,IAAL,GAAYhE,GAAG,CAACyE,GAAhB;AACA,WAAOjB,IAAP;AACD;;AAED,SAAOL,YAAP,CAAoBmD;AACpB;AADA;AAGA;AACA;AACE,UAAMC,MAAM,GAAG,EAAf;AACAA,IAAAA,MAAM,CAACrF,MAAP,GAAgBsF,IAAI,CAACC,IAAL,CAAUH,KAAK,CAACpF,MAAN,GAAe,CAAzB,CAAhB;;AAEA,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuF,MAAM,CAACrF,MAA3B,EAAmCF,CAAC,EAApC,EAAwC;AACtC,YAAM0F,EAAE,GAAGJ,KAAK,CAACtF,CAAC,GAAG,CAAL,CAAhB;AACA,YAAM2F,EAAE,GAAGL,KAAK,CAACtF,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAL,IAAoB,CAA/B;AACA,YAAM4F,EAAE,GAAGN,KAAK,CAACtF,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAL,IAAoB,CAA/B;AACA,YAAM6F,IAAI,GAAG7F,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAYsF,KAAK,CAACpF,MAA/B;AACA,YAAM4F,IAAI,GAAG9F,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAYsF,KAAK,CAACpF,MAA/B;AACAqF,MAAAA,MAAM,CAACvF,CAAD,CAAN,GAAY,CAACe,QAAQ,CAAC2E,EAAE,IAAI,CAAN,GAAU,IAAX,CAAT,EAA2B3E,QAAQ,CAAC2E,EAAE,IAAI,CAAN,GAAU,IAAV,GAAiBC,EAAE,IAAI,CAAN,GAAU,IAA5B,CAAnC,EAAsEE,IAAI,GAAG9E,QAAQ,CAAC4E,EAAE,IAAI,CAAN,GAAU,IAAV,GAAiBC,EAAE,IAAI,CAAN,GAAU,IAA5B,CAAX,GAA+C,GAAzH,EAA8HE,IAAI,GAAG/E,QAAQ,CAAC6E,EAAE,GAAG,IAAN,CAAX,GAAyB,GAA3J,EAAgKG,IAAhK,CAAqK,EAArK,CAAZ;AACD;;AAED,WAAOR,MAAM,CAACQ,IAAP,CAAY,EAAZ,CAAP;AACD;;AAjca;;AAqchB,MAAMC,iBAAiB,GAAG;AACxBjC,EAAAA,QAAQ,EAAE,gBAAgBzC;AAC1B;AADU,IAERnB;AACF;AAHU,IAIRuD;AACF;AALU,IAMR;AACA,QAAIvD,MAAM,CAACkC,MAAP,KAAkB,MAAtB,EAA8B;AAC5B,YAAM,IAAIY,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAED,UAAMgD,UAAU,GAAG,MAAM,IAAIC,OAAJ,CAAY,CAACjC,GAAD,EAAMkC,GAAN,KAAc;AACjD;AACA,YAAMC,MAAM,GAAG,IAAIC,UAAJ,EAAf;;AAEAD,MAAAA,MAAM,CAACE,MAAP,GAAgB,MAAMrC,GAAG,CAACmC,MAAM,CAAChD,MAAR,CAAzB;;AAEAgD,MAAAA,MAAM,CAACG,OAAP,GAAiBC,KAAK,IAAIL,GAAG,CAACK,KAAD,CAA7B;;AAEAJ,MAAAA,MAAM,CAACK,aAAP,CAAqBtG,MAAM,CAACqC,IAA5B;AACD,KATwB,CAAzB,CALA,CAcI;AACJ;;AAEA,UAAM,CAACkE,KAAD,EAAQC,MAAR,IAAkBV,UAAU,CAACW,KAAX,CAAiB,GAAjB,CAAxB,CAjBA,CAiB+C;AAC/C;;AAEA,UAAMrF,IAAI,GAAGoF,MAAM,GAAGA,MAAH,GAAYD,KAA/B;AACA,UAAMxC,SAAS,GAAG;AAChB7B,MAAAA,MAAM,EAAE,QADQ;AAEhBC,MAAAA,MAAM,EAAEf,IAFQ;AAGhBC,MAAAA,IAAI,EAAErB,MAAM,CAACqB,IAAP,KAAgBrB,MAAM,CAACqC,IAAP,GAAcrC,MAAM,CAACqC,IAAP,CAAYhB,IAA1B,GAAiC,IAAjD;AAHU,KAAlB;AAKA,WAAO,MAAMwE,iBAAiB,CAAC5B,UAAlB,CAA6B9C,IAA7B,EAAmC4C,SAAnC,EAA8CR,OAA9C,CAAb;AACD,GAlCuB;AAmCxBU,EAAAA,UAAU,EAAE,UAAU9C;AACtB;AADY,IAEVnB;AACF;AAHY,IAIVuD;AACF;AALY,IAMV;AACA,QAAIvD,MAAM,CAACkC,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,YAAM,IAAIY,KAAJ,CAAU,uDAAV,CAAN;AACD;;AAED,UAAM1B;AACN;AADU,MAER;AACAe,MAAAA,MAAM,EAAEnC,MAAM,CAACmC,MADf;AAEAuE,MAAAA,QAAQ,EAAE;AACRpF,QAAAA,QAAQ,EAAE3B,aAAa,CAAC,EAAD,EAAK4D,OAAO,CAACjC,QAAb,CADf;AAERC,QAAAA,IAAI,EAAE5B,aAAa,CAAC,EAAD,EAAK4D,OAAO,CAAChC,IAAb;AAFX;AAFV,KAFF;AASA,WAAOgC,OAAO,CAACjC,QAAf;AACA,WAAOiC,OAAO,CAAChC,IAAf;;AAEA,QAAIvB,MAAM,CAACqB,IAAX,EAAiB;AACfD,MAAAA,IAAI,CAACuF,YAAL,GAAoB3G,MAAM,CAACqB,IAA3B;AACD;;AAED,WAAO3C,YAAY,CAACD,OAAb,CAAqBmI,iBAArB,GAAyCC,OAAzC,CAAiD,MAAjD,EAAyD,WAAW1F,IAApE,EAA0EC,IAA1E,EAAgFmC,OAAhF,CAAP;AACD,GA/DuB;AAgExBL,EAAAA,QAAQ,EAAE,UAAUZ,GAAV,EAAeiB,OAAf,EAAwB;AAChC,QAAI9C,GAAJ,EAAS;AACP,aAAO,KAAKqG,YAAL,CAAkBxE,GAAlB,EAAuBiB,OAAvB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAIwC,OAAJ,CAAY,CAACgB,OAAD,EAAUC,MAAV,KAAqB;AACtC,cAAMC,MAAM,GAAG3E,GAAG,CAACE,OAAJ,CAAY,OAAZ,MAAyB,CAAzB,GAA6B5D,OAAO,CAAC,OAAD,CAApC,GAAgDA,OAAO,CAAC,MAAD,CAAtE;AACA,cAAMsI,GAAG,GAAGD,MAAM,CAACE,GAAP,CAAW7E,GAAX,EAAgB8E,IAAI,IAAI;AAClCA,UAAAA,IAAI,CAACC,WAAL,CAAiB,QAAjB;AACA,cAAIlF,MAAM,GAAG,EAAb;AACAiF,UAAAA,IAAI,CAACE,EAAL,CAAQ,MAAR,EAAgBlG,IAAI,IAAIe,MAAM,IAAIf,IAAlC;AACAgG,UAAAA,IAAI,CAACE,EAAL,CAAQ,KAAR,EAAe,MAAM;AACnBP,YAAAA,OAAO,CAAC;AACN5E,cAAAA,MADM;AAEN6B,cAAAA,WAAW,EAAEoD,IAAI,CAACG,OAAL,CAAa,cAAb;AAFP,aAAD,CAAP;AAID,WALD;AAMD,SAVW,CAAZ;AAWAL,QAAAA,GAAG,CAACI,EAAJ,CAAO,OAAP,EAAgB,MAAM;AACpBP,UAAAA,OAAO,CAAC,EAAD,CAAP;AACD,SAFD;AAGAG,QAAAA,GAAG,CAACI,EAAJ,CAAO,OAAP,EAAgBN,MAAhB;AACAzD,QAAAA,OAAO,CAACJ,WAAR,CAAoB+D,GAApB;AACD,OAlBM,CAAP;AAmBD;AACF,GAxFuB;AAyFxBJ,EAAAA,YAAY,EAAE,UAAUxE,GAAV,EAAeiB,OAAf,EAAwB;AACpC,WAAO,IAAIwC,OAAJ,CAAY,CAACgB,OAAD,EAAUC,MAAV,KAAqB;AACtC,YAAMQ,GAAG,GAAG,IAAI/G,GAAJ,EAAZ;AACA+G,MAAAA,GAAG,CAACC,IAAJ,CAAS,KAAT,EAAgBnF,GAAhB,EAAqB,IAArB;AACAkF,MAAAA,GAAG,CAACE,YAAJ,GAAmB,aAAnB;;AAEAF,MAAAA,GAAG,CAACpB,OAAJ,GAAc,UAAUuB,CAAV,EAAa;AACzBX,QAAAA,MAAM,CAACW,CAAD,CAAN;AACD,OAFD;;AAIAH,MAAAA,GAAG,CAACI,kBAAJ,GAAyB,YAAY;AACnC,YAAIJ,GAAG,CAACK,UAAJ,KAAmBL,GAAG,CAACM,IAA3B,EAAiC;AAC/B;AACD;;AAED,YAAI,CAAC,KAAKC,QAAV,EAAoB;AAClB,iBAAOhB,OAAO,CAAC,EAAD,CAAd;AACD;;AAED,cAAM5B,KAAK,GAAG,IAAI6C,UAAJ,CAAe,KAAKD,QAApB,CAAd;AACAhB,QAAAA,OAAO,CAAC;AACN5E,UAAAA,MAAM,EAAElB,SAAS,CAACe,YAAV,CAAuBmD,KAAvB,CADF;AAENnB,UAAAA,WAAW,EAAEwD,GAAG,CAACS,iBAAJ,CAAsB,cAAtB;AAFP,SAAD,CAAP;AAID,OAdD;;AAgBA1E,MAAAA,OAAO,CAACJ,WAAR,CAAoBqE,GAApB;AACAA,MAAAA,GAAG,CAACU,IAAJ;AACD,KA3BM,CAAP;AA4BD,GAtHuB;AAuHxBzD,EAAAA,UAAU,EAAE,UAAUtD;AACtB;AADY,IAEVoC;AACF;AAHY,IAIV;AACA,UAAMgE,OAAO,GAAG;AACd,gCAA0B7I,YAAY,CAACD,OAAb,CAAqB0I,GAArB,CAAyB,gBAAzB;AADZ,KAAhB;;AAIA,QAAI5D,OAAO,CAACgB,YAAZ,EAA0B;AACxBgD,MAAAA,OAAO,CAAC,oBAAD,CAAP,GAAgC7I,YAAY,CAACD,OAAb,CAAqB0I,GAArB,CAAyB,YAAzB,CAAhC;AACD;;AAED,QAAI7D,GAAG,GAAG5E,YAAY,CAACD,OAAb,CAAqB0I,GAArB,CAAyB,YAAzB,CAAV;;AAEA,QAAI7D,GAAG,CAACA,GAAG,CAACvD,MAAJ,GAAa,CAAd,CAAH,KAAwB,GAA5B,EAAiC;AAC/BuD,MAAAA,GAAG,IAAI,GAAP;AACD;;AAEDA,IAAAA,GAAG,IAAI,WAAWnC,IAAlB;AACA,WAAOzC,YAAY,CAACD,OAAb,CAAqBmI,iBAArB,GAAyCuB,IAAzC,CAA8C,QAA9C,EAAwD7E,GAAxD,EAA6D,EAA7D,EAAiEiE,OAAjE,EAA0Ea,KAA1E,CAAgFL,QAAQ,IAAI;AACjG;AACA,UAAI,CAACA,QAAD,IAAaA,QAAQ,KAAK,2CAA9B,EAA2E;AACzE,eAAOhC,OAAO,CAACgB,OAAR,EAAP;AACD,OAFD,MAEO;AACL,eAAOrI,YAAY,CAACD,OAAb,CAAqBmI,iBAArB,GAAyCyB,WAAzC,CAAqDN,QAArD,CAAP;AACD;AACF,KAPM,CAAP;AAQD,GAnJuB;;AAqJxBO,EAAAA,OAAO,CAACd;AACR;AADO,IAEL;AACA/G,IAAAA,GAAG,GAAG+G,GAAN;AACD,GAzJuB;;AA2JxBe,EAAAA,OAAO,GAAG;AACR,WAAO9H,GAAP;AACD;;AA7JuB,CAA1B;;AAiKA/B,YAAY,CAACD,OAAb,CAAqB+J,iBAArB,CAAuC3C,iBAAvC;;AAEA,IAAI4C,QAAQ,GAAGxH,SAAf;AACA1C,OAAO,CAACE,OAAR,GAAkBgK,QAAlB;AACAlK,OAAO,CAACqC,QAAR,GAAmBA,QAAnB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst ParseError = require('./ParseError').default;\n\nlet XHR = null;\n\nif (typeof XMLHttpRequest !== 'undefined') {\n  XHR = XMLHttpRequest;\n}\n\n/*:: type Base64 = { base64: string };*/\n\n/*:: type Uri = { uri: string };*/\n\n/*:: type FileData = Array<number> | Base64 | Blob | Uri;*/\n\n/*:: export type FileSource =\n  | {\n      format: 'file',\n      file: Blob,\n      type: string,\n    }\n  | {\n      format: 'base64',\n      base64: string,\n      type: string,\n    }\n  | {\n      format: 'uri',\n      uri: string,\n      type: string,\n    };*/\nconst dataUriRegexp = /^data:([a-zA-Z]+\\/[-a-zA-Z0-9+.]+)(;charset=[a-zA-Z0-9\\-\\/]*)?;base64,/;\n\nfunction b64Digit(number\n/*: number*/\n)\n/*: string*/\n{\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n\n  if (number === 62) {\n    return '+';\n  }\n\n  if (number === 63) {\n    return '/';\n  }\n\n  throw new TypeError('Tried to encode large digit ' + number + ' in base64.');\n}\n/**\n * A Parse.File is a local representation of a file that is saved to the Parse\n * cloud.\n *\n * @alias Parse.File\n */\n\n\nclass ParseFile {\n  /*:: _name: string;*/\n\n  /*:: _url: ?string;*/\n\n  /*:: _source: FileSource;*/\n\n  /*:: _previousSave: ?Promise<ParseFile>;*/\n\n  /*:: _data: ?string;*/\n\n  /*:: _requestTask: ?any;*/\n\n  /*:: _metadata: ?Object;*/\n\n  /*:: _tags: ?Object;*/\n\n  /**\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers, or\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. an Object like { uri: \"...\" } with a uri String.\n   *     4. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:\n   * <pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   * @param metadata {Object} Optional key value pairs to be stored with file object\n   * @param tags {Object} Optional key value pairs to be stored with file object\n   */\n  constructor(name\n  /*: string*/\n  , data\n  /*:: ?: FileData*/\n  , type\n  /*:: ?: string*/\n  , metadata\n  /*:: ?: Object*/\n  , tags\n  /*:: ?: Object*/\n  ) {\n    const specifiedType = type || '';\n    this._name = name;\n    this._metadata = metadata || {};\n    this._tags = tags || {};\n\n    if (data !== undefined) {\n      if (Array.isArray(data)) {\n        this._data = ParseFile.encodeBase64(data);\n        this._source = {\n          format: 'base64',\n          base64: this._data,\n          type: specifiedType\n        };\n      } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n        this._source = {\n          format: 'file',\n          file: data,\n          type: specifiedType\n        };\n      } else if (data && typeof data.uri === 'string' && data.uri !== undefined) {\n        this._source = {\n          format: 'uri',\n          uri: data.uri,\n          type: specifiedType\n        };\n      } else if (data && typeof data.base64 === 'string') {\n        const base64 = data.base64;\n        const commaIndex = base64.indexOf(',');\n\n        if (commaIndex !== -1) {\n          const matches = dataUriRegexp.exec(base64.slice(0, commaIndex + 1)); // if data URI with type and charset, there will be 4 matches.\n\n          this._data = base64.slice(commaIndex + 1);\n          this._source = {\n            format: 'base64',\n            base64: this._data,\n            type: matches[1]\n          };\n        } else {\n          this._data = base64;\n          this._source = {\n            format: 'base64',\n            base64: base64,\n            type: specifiedType\n          };\n        }\n      } else {\n        throw new TypeError('Cannot create a Parse.File with that data.');\n      }\n    }\n  }\n  /**\n   * Return the data for the file, downloading it if not already present.\n   * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n   * Data is cleared if saved with File object selected with a file upload control\n   *\n   * @returns {Promise} Promise that is resolve with base64 data\n   */\n\n\n  async getData()\n  /*: Promise<String>*/\n  {\n    if (this._data) {\n      return this._data;\n    }\n\n    if (!this._url) {\n      throw new Error('Cannot retrieve data for unsaved ParseFile.');\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    const result = await controller.download(this._url, {\n      requestTask: task => this._requestTask = task\n    });\n    this._data = result.base64;\n    return this._data;\n  }\n  /**\n   * Gets the name of the file. Before save is called, this is the filename\n   * given by the user. After save is called, that name gets prefixed with a\n   * unique identifier.\n   *\n   * @returns {string}\n   */\n\n\n  name()\n  /*: string*/\n  {\n    return this._name;\n  }\n  /**\n   * Gets the url of the file. It is only available after you save the file or\n   * after you get the file from a Parse.Object.\n   *\n   * @param {object} options An object to specify url options\n   * @returns {string}\n   */\n\n\n  url(options\n  /*:: ?: { forceSecure?: boolean }*/\n  )\n  /*: ?string*/\n  {\n    options = options || {};\n\n    if (!this._url) {\n      return;\n    }\n\n    if (options.forceSecure) {\n      return this._url.replace(/^http:\\/\\//i, 'https://');\n    } else {\n      return this._url;\n    }\n  }\n  /**\n   * Gets the metadata of the file.\n   *\n   * @returns {object}\n   */\n\n\n  metadata()\n  /*: Object*/\n  {\n    return this._metadata;\n  }\n  /**\n   * Gets the tags of the file.\n   *\n   * @returns {object}\n   */\n\n\n  tags()\n  /*: Object*/\n  {\n    return this._tags;\n  }\n  /**\n   * Saves the file to the Parse cloud.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *     behalf of a specific user.\n   *   <li>progress: In Browser only, callback for upload progress. For example:\n   * <pre>\n   * let parseFile = new Parse.File(name, file);\n   * parseFile.save({\n   *   progress: (progressValue, loaded, total, { type }) => {\n   *     if (type === \"upload\" && progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * </ul>\n   * @returns {Promise} Promise that is resolved when the save finishes.\n   */\n\n\n  save(options\n  /*:: ?: FullOptions*/\n  ) {\n    options = options || {};\n\n    options.requestTask = task => this._requestTask = task;\n\n    options.metadata = this._metadata;\n    options.tags = this._tags;\n\n    const controller = _CoreManager.default.getFileController();\n\n    if (!this._previousSave) {\n      if (this._source.format === 'file') {\n        this._previousSave = controller.saveFile(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._data = null;\n          this._requestTask = null;\n          return this;\n        });\n      } else if (this._source.format === 'uri') {\n        this._previousSave = controller.download(this._source.uri, options).then(result => {\n          if (!(result && result.base64)) {\n            return {};\n          }\n\n          const newSource = {\n            format: 'base64',\n            base64: result.base64,\n            type: result.contentType\n          };\n          this._data = result.base64;\n          this._requestTask = null;\n          return controller.saveBase64(this._name, newSource, options);\n        }).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      } else {\n        this._previousSave = controller.saveBase64(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      }\n    }\n\n    if (this._previousSave) {\n      return this._previousSave;\n    }\n  }\n  /**\n   * Aborts the request if it has already been sent.\n   */\n\n\n  cancel() {\n    if (this._requestTask && typeof this._requestTask.abort === 'function') {\n      this._requestTask.abort();\n    }\n\n    this._requestTask = null;\n  }\n  /**\n   * Deletes the file from the Parse cloud.\n   * In Cloud Code and Node only with Master Key.\n   *\n   * @param {object} options\n   *  * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * <pre>\n   * @returns {Promise} Promise that is resolved when the delete finishes.\n   */\n\n\n  destroy(options\n  /*:: ?: FullOptions*/\n  = {}) {\n    if (!this._name) {\n      throw new ParseError(ParseError.FILE_DELETE_UNNAMED_ERROR, 'Cannot delete an unnamed file.');\n    }\n\n    const destroyOptions = {\n      useMasterKey: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getFileController();\n\n    return controller.deleteFile(this._name, destroyOptions).then(() => {\n      this._data = null;\n      this._requestTask = null;\n      return this;\n    });\n  }\n\n  toJSON()\n  /*: { name: ?string, url: ?string }*/\n  {\n    return {\n      __type: 'File',\n      name: this._name,\n      url: this._url\n    };\n  }\n\n  equals(other\n  /*: mixed*/\n  )\n  /*: boolean*/\n  {\n    if (this === other) {\n      return true;\n    } // Unsaved Files are never equal, since they will be saved to different URLs\n\n\n    return other instanceof ParseFile && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== 'undefined';\n  }\n  /**\n   * Sets metadata to be saved with file object. Overwrites existing metadata\n   *\n   * @param {object} metadata Key value pairs to be stored with file object\n   */\n\n\n  setMetadata(metadata\n  /*: any*/\n  ) {\n    if (metadata && typeof metadata === 'object') {\n      Object.keys(metadata).forEach(key => {\n        this.addMetadata(key, metadata[key]);\n      });\n    }\n  }\n  /**\n   * Sets metadata to be saved with file object. Adds to existing metadata.\n   *\n   * @param {string} key key to store the metadata\n   * @param {*} value metadata\n   */\n\n\n  addMetadata(key\n  /*: string*/\n  , value\n  /*: any*/\n  ) {\n    if (typeof key === 'string') {\n      this._metadata[key] = value;\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Overwrites existing tags\n   *\n   * @param {object} tags Key value pairs to be stored with file object\n   */\n\n\n  setTags(tags\n  /*: any*/\n  ) {\n    if (tags && typeof tags === 'object') {\n      Object.keys(tags).forEach(key => {\n        this.addTag(key, tags[key]);\n      });\n    }\n  }\n  /**\n   * Sets tags to be saved with file object. Adds to existing tags.\n   *\n   * @param {string} key key to store tags\n   * @param {*} value tag\n   */\n\n\n  addTag(key\n  /*: string*/\n  , value\n  /*: string*/\n  ) {\n    if (typeof key === 'string') {\n      this._tags[key] = value;\n    }\n  }\n\n  static fromJSON(obj)\n  /*: ParseFile*/\n  {\n    if (obj.__type !== 'File') {\n      throw new TypeError('JSON object does not represent a ParseFile');\n    }\n\n    const file = new ParseFile(obj.name);\n    file._url = obj.url;\n    return file;\n  }\n\n  static encodeBase64(bytes\n  /*: Array<number>*/\n  )\n  /*: string*/\n  {\n    const chunks = [];\n    chunks.length = Math.ceil(bytes.length / 3);\n\n    for (let i = 0; i < chunks.length; i++) {\n      const b1 = bytes[i * 3];\n      const b2 = bytes[i * 3 + 1] || 0;\n      const b3 = bytes[i * 3 + 2] || 0;\n      const has2 = i * 3 + 1 < bytes.length;\n      const has3 = i * 3 + 2 < bytes.length;\n      chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n    }\n\n    return chunks.join('');\n  }\n\n}\n\nconst DefaultController = {\n  saveFile: async function (name\n  /*: string*/\n  , source\n  /*: FileSource*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (source.format !== 'file') {\n      throw new Error('saveFile can only be used with File-type sources.');\n    }\n\n    const base64Data = await new Promise((res, rej) => {\n      // eslint-disable-next-line no-undef\n      const reader = new FileReader();\n\n      reader.onload = () => res(reader.result);\n\n      reader.onerror = error => rej(error);\n\n      reader.readAsDataURL(source.file);\n    }); // we only want the data after the comma\n    // For example: \"data:application/pdf;base64,JVBERi0xLjQKJ...\" we would only want \"JVBERi0xLjQKJ...\"\n\n    const [first, second] = base64Data.split(','); // in the event there is no 'data:application/pdf;base64,' at the beginning of the base64 string\n    // use the entire string instead\n\n    const data = second ? second : first;\n    const newSource = {\n      format: 'base64',\n      base64: data,\n      type: source.type || (source.file ? source.file.type : null)\n    };\n    return await DefaultController.saveBase64(name, newSource, options);\n  },\n  saveBase64: function (name\n  /*: string*/\n  , source\n  /*: FileSource*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (source.format !== 'base64') {\n      throw new Error('saveBase64 can only be used with Base64-type sources.');\n    }\n\n    const data\n    /*: { base64: any, _ContentType?: any, fileData: Object }*/\n    = {\n      base64: source.base64,\n      fileData: {\n        metadata: _objectSpread({}, options.metadata),\n        tags: _objectSpread({}, options.tags)\n      }\n    };\n    delete options.metadata;\n    delete options.tags;\n\n    if (source.type) {\n      data._ContentType = source.type;\n    }\n\n    return _CoreManager.default.getRESTController().request('POST', 'files/' + name, data, options);\n  },\n  download: function (uri, options) {\n    if (XHR) {\n      return this.downloadAjax(uri, options);\n    } else {\n      return new Promise((resolve, reject) => {\n        const client = uri.indexOf('https') === 0 ? require('https') : require('http');\n        const req = client.get(uri, resp => {\n          resp.setEncoding('base64');\n          let base64 = '';\n          resp.on('data', data => base64 += data);\n          resp.on('end', () => {\n            resolve({\n              base64,\n              contentType: resp.headers['content-type']\n            });\n          });\n        });\n        req.on('abort', () => {\n          resolve({});\n        });\n        req.on('error', reject);\n        options.requestTask(req);\n      });\n    }\n  },\n  downloadAjax: function (uri, options) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XHR();\n      xhr.open('GET', uri, true);\n      xhr.responseType = 'arraybuffer';\n\n      xhr.onerror = function (e) {\n        reject(e);\n      };\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState !== xhr.DONE) {\n          return;\n        }\n\n        if (!this.response) {\n          return resolve({});\n        }\n\n        const bytes = new Uint8Array(this.response);\n        resolve({\n          base64: ParseFile.encodeBase64(bytes),\n          contentType: xhr.getResponseHeader('content-type')\n        });\n      };\n\n      options.requestTask(xhr);\n      xhr.send();\n    });\n  },\n  deleteFile: function (name\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    const headers = {\n      'X-Parse-Application-ID': _CoreManager.default.get('APPLICATION_ID')\n    };\n\n    if (options.useMasterKey) {\n      headers['X-Parse-Master-Key'] = _CoreManager.default.get('MASTER_KEY');\n    }\n\n    let url = _CoreManager.default.get('SERVER_URL');\n\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n\n    url += 'files/' + name;\n    return _CoreManager.default.getRESTController().ajax('DELETE', url, '', headers).catch(response => {\n      // TODO: return JSON object in server\n      if (!response || response === 'SyntaxError: Unexpected end of JSON input') {\n        return Promise.resolve();\n      } else {\n        return _CoreManager.default.getRESTController().handleError(response);\n      }\n    });\n  },\n\n  _setXHR(xhr\n  /*: any*/\n  ) {\n    XHR = xhr;\n  },\n\n  _getXHR() {\n    return XHR;\n  }\n\n};\n\n_CoreManager.default.setFileController(DefaultController);\n\nvar _default = ParseFile;\nexports.default = _default;\nexports.b64Digit = b64Digit;"]},"metadata":{},"sourceType":"script"}