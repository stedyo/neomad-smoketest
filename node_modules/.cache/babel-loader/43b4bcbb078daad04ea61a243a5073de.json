{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseSession = _interopRequireDefault(require(\"./ParseSession\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\n\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes\n  /*: ?AttributeMap*/\n  ) {\n    super('_User');\n\n    if (attributes && typeof attributes === 'object') {\n      if (!this.set(attributes || {})) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n\n\n  _upgradeToRevocableSession(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n    const upgradeOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      upgradeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n\n\n  linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  = {})\n  /*: Promise<ParseUser>*/\n  {\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n\n          getAuthType() {\n            return authType;\n          }\n\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    if (options && options.hasOwnProperty('authData')) {\n      const authData = this.get('authData') || {};\n\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n\n      authData[authType] = options.authData;\n\n      const controller = _CoreManager.default.getUserController();\n\n      return controller.linkWith(this, authData, saveOpts);\n    } else {\n      return new Promise((resolve, reject) => {\n        provider.authenticate({\n          success: (provider, result) => {\n            const opts = {};\n            opts.authData = result;\n            this.linkWith(provider, opts, saveOpts).then(() => {\n              resolve(this);\n            }, error => {\n              reject(error);\n            });\n          },\n          error: (provider, error) => {\n            reject(error);\n          }\n        });\n      });\n    }\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n\n\n  _linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  = {})\n  /*: Promise<ParseUser>*/\n  {\n    return this.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n\n\n  _synchronizeAuthData(provider\n  /*: string*/\n  ) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData');\n\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n\n    const success = provider.restoreAuthentication(authData[authType]);\n\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n  /**\n   * Synchronizes authData for all providers.\n   */\n\n\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n\n\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n\n\n  _unlinkFrom(provider\n  /*: any*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n\n      return Promise.resolve(this);\n    });\n  }\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n\n\n  _isLinked(provider\n  /*: any*/\n  )\n  /*: boolean*/\n  {\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData') || {};\n\n    if (typeof authData !== 'object') {\n      return false;\n    }\n\n    return !!authData[authType];\n  }\n  /**\n   * Deauthenticates all providers.\n   */\n\n\n  _logOutWithAll() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n\n\n  _logOutWith(provider\n  /*: any*/\n  ) {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n\n\n  _preserveFieldsOnFetch()\n  /*: AttributeMap*/\n  {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n\n\n  isCurrent()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {Promise<boolean>} true if user is cached on disk\n   */\n\n\n  async isCurrentAsync()\n  /*: Promise<boolean>*/\n  {\n    const current = await ParseUser.currentAsync();\n    return !!current && current.id === this.id;\n  }\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n\n\n  getUsername()\n  /*: ?string*/\n  {\n    const username = this.get('username');\n\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n\n\n  setUsername(username\n  /*: string*/\n  ) {\n    // Strip anonymity\n    const authData = this.get('authData');\n\n    if (authData && typeof authData === 'object' && authData.hasOwnProperty('anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n\n    this.set('username', username);\n  }\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n\n\n  setPassword(password\n  /*: string*/\n  ) {\n    this.set('password', password);\n  }\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n\n\n  getEmail()\n  /*: ?string*/\n  {\n    const email = this.get('email');\n\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n\n\n  setEmail(email\n  /*: string*/\n  ) {\n    return this.set('email', email);\n  }\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n\n\n  getSessionToken()\n  /*: ?string*/\n  {\n    const token = this.get('sessionToken');\n\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n\n    return '';\n  }\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n\n\n  authenticated()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n\n\n  signUp(attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const signupOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      signupOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      signupOptions.installationId = options.installationId;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.signUp(this, attrs, signupOptions);\n  }\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n\n\n  logIn(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const loginOptions = {\n      usePost: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      loginOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      loginOptions.installationId = options.installationId;\n    }\n\n    if (options.hasOwnProperty('usePost')) {\n      loginOptions.usePost = options.usePost;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logIn(this, loginOptions);\n  }\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n\n\n  async save(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.save.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  async destroy(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.destroy.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().removeUserFromDisk();\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  async fetch(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.fetch.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  async fetchWithInclude(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.fetchWithInclude.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n\n    return this;\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  verifyPassword(password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n\n\n  static extend(protoProps\n  /*: { [prop: string]: any }*/\n  , classProps\n  /*: { [prop: string]: any }*/\n  ) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return ParseUser;\n  }\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.Object} The currently logged in Parse.User.\n   */\n\n\n  static current()\n  /*: ?ParseUser*/\n  {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUser();\n  }\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n\n\n  static currentAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (!canUseCurrentUser) {\n      return Promise.resolve(null);\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUserAsync();\n  }\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n\n\n  static signUp(username\n  /*: string*/\n  , password\n  /*: string*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static logIn(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    } else if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    const user = new this();\n\n    user._finishFetch({\n      username: username,\n      password: password\n    });\n\n    return user.logIn(options);\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static become(sessionToken\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n\n    options = options || {};\n    const becomeOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      becomeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n\n\n  static me(sessionToken\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  = {}) {\n    const controller = _CoreManager.default.getUserController();\n\n    const meOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.useMasterKey) {\n      meOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static hydrate(userJSON\n  /*: AttributeMap*/\n  ) {\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n\n\n  static logOut(options\n  /*: RequestOptions*/\n  = {}) {\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logOut(options);\n  }\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestPasswordReset(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestEmailVerification(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} username  A username to be used for identificaiton\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  static verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n\n    if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    options = options || {};\n    const verificationOption = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      verificationOption.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.verifyPassword(username, password, verificationOption);\n  }\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n\n\n  static allowCustomUserClass(isAllowed\n  /*: boolean*/\n  ) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n\n\n  static enableRevocableSession(options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n\n\n  static _registerAuthenticationProvider(provider\n  /*: any*/\n  ) {\n    authProviders[provider.getAuthType()] = provider; // Synchronize the current user with the auth provider.\n\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static _logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  ) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n\n  static _setCurrentUserCache(user\n  /*: ParseUser*/\n  ) {\n    currentUserCache = user;\n  }\n\n}\n\n_ParseObject.default.registerSubclass('_User', ParseUser);\n\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = JSON.stringify(json);\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n\n  setCurrentUser(user) {\n    currentUserCache = user;\n\n    user._cleanupAuthData();\n\n    user._synchronizeAllAuthData();\n\n    return DefaultController.updateUserOnDisk(user);\n  },\n\n  currentUser()\n  /*: ?ParseUser*/\n  {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    let userData = _Storage.default.getItem(path);\n\n    currentUserCacheMatchesDisk = true;\n\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    userData = JSON.parse(userData);\n\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n\n      delete userData._id;\n    }\n\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n\n    const current = _ParseObject.default.fromJSON(userData);\n\n    currentUserCache = current;\n\n    current._synchronizeAllAuthData();\n\n    return current;\n  },\n\n  currentUserAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (currentUserCache) {\n      return Promise.resolve(currentUserCache);\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return Promise.resolve(null);\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n\n      if (!userData) {\n        currentUserCache = null;\n        return Promise.resolve(null);\n      }\n\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n\n      userData = JSON.parse(userData);\n\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n\n        delete userData._id;\n      }\n\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n\n      const current = _ParseObject.default.fromJSON(userData);\n\n      currentUserCache = current;\n\n      current._synchronizeAllAuthData();\n\n      return Promise.resolve(current);\n    });\n  },\n\n  signUp(user\n  /*: ParseUser*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n\n    if (!username || !username.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n\n    if (!password || !password.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  logIn(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n\n      user._setExisted(true);\n\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n\n      user._finishFetch(response);\n\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return Promise.resolve(user);\n      }\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  become(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  hydrate(user\n  /*: ParseUser*/\n  , userJSON\n  /*: AttributeMap*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    user._finishFetch(userJSON);\n\n    user._setExisted(true);\n\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    } else {\n      return Promise.resolve(user);\n    }\n  },\n\n  me(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return user;\n    });\n  },\n\n  logOut(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    if (options.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n      let promise = _Storage.default.removeItemAsync(path);\n\n      if (currentUser !== null) {\n        const currentSession = currentUser.getSessionToken();\n\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n\n        currentUser._logOutWithAll();\n\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n      }\n\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n\n  requestPasswordReset(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email: email\n    }, options);\n  },\n\n  async upgradeToRevocableSession(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const token = user.getSessionToken();\n\n    if (!token) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n\n    options.sessionToken = token;\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const result = await RESTController.request('POST', 'upgradeToRevocableSession', {}, options);\n    const session = new _ParseSession.default();\n\n    session._finishFetch(result);\n\n    user._finishFetch({\n      sessionToken: session.getSessionToken()\n    });\n\n    const current = await user.isCurrentAsync();\n\n    if (current) {\n      return DefaultController.setCurrentUser(user);\n    }\n\n    return Promise.resolve(user);\n  },\n\n  linkWith(user\n  /*: ParseUser*/\n  , authData\n  /*: AuthData*/\n  , options\n  /*: FullOptions*/\n  ) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'verifyPassword', {\n      username,\n      password\n    }, options);\n  },\n\n  requestEmailVerification(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email: email\n    }, options);\n  }\n\n};\n\n_CoreManager.default.setUserController(DefaultController);\n\nvar _default = ParseUser;\nexports.default = _default;","map":{"version":3,"sources":["/Users/szd/Dev/ycomms-smoketest-landing-page/node_modules/parse/lib/node/ParseUser.js"],"names":["Object","defineProperty","exports","value","default","_CoreManager","_interopRequireDefault","require","_isRevocableSession","_ParseError","_ParseObject","_ParseSession","_Storage","obj","__esModule","CURRENT_USER_KEY","canUseCurrentUser","get","currentUserCacheMatchesDisk","currentUserCache","authProviders","ParseUser","constructor","attributes","set","Error","_upgradeToRevocableSession","options","upgradeOptions","hasOwnProperty","useMasterKey","controller","getUserController","upgradeToRevocableSession","linkWith","provider","saveOpts","sessionToken","getSessionToken","authType","authProvider","restoreAuthentication","getAuthType","authData","Promise","resolve","reject","authenticate","success","result","opts","then","error","_linkWith","_synchronizeAuthData","isCurrent","_unlinkFrom","_synchronizeAllAuthData","key","_cleanupAuthData","_isLinked","_logOutWithAll","_logOutWith","deauthenticate","_preserveFieldsOnFetch","current","id","isCurrentAsync","currentAsync","getUsername","username","setUsername","anonymous","setPassword","password","getEmail","email","setEmail","token","authenticated","signUp","attrs","signupOptions","installationId","logIn","loginOptions","usePost","save","args","apply","updateUserOnDisk","destroy","removeUserFromDisk","fetch","fetchWithInclude","verifyPassword","readOnlyAttributes","extend","protoProps","classProps","prop","prototype","enumerable","writable","configurable","currentUser","currentUserAsync","user","OTHER_CAUSE","_finishFetch","become","becomeOptions","me","meOptions","hydrate","userJSON","logInWith","logOut","requestPasswordReset","requestOptions","requestEmailVerification","verificationOption","allowCustomUserClass","isAllowed","enableRevocableSession","enableUnsafeCurrentUser","disableUnsafeCurrentUser","_registerAuthenticationProvider","_logInWith","_clearCache","_setCurrentUserCache","registerSubclass","DefaultController","path","generatePath","json","toJSON","className","userData","JSON","stringify","crypto","getCryptoController","encrypt","setItemAsync","removeItemAsync","setCurrentUser","async","getItem","decrypt","parse","_id","objectId","_sessionToken","fromJSON","getItemAsync","toString","length","undefined","RESTController","getRESTController","stateController","getObjectStateController","auth","request","response","_migrateId","_setExisted","setPendingOp","_getStateIdentifier","promise","currentSession","SESSION_MISSING","session","setUserController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\n\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n\nvar _ParseSession = _interopRequireDefault(require(\"./ParseSession\"));\n\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\n\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes\n  /*: ?AttributeMap*/\n  ) {\n    super('_User');\n\n    if (attributes && typeof attributes === 'object') {\n      if (!this.set(attributes || {})) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n\n\n  _upgradeToRevocableSession(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<void>*/\n  {\n    options = options || {};\n    const upgradeOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      upgradeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n\n\n  linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  = {})\n  /*: Promise<ParseUser>*/\n  {\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n\n          getAuthType() {\n            return authType;\n          }\n\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    if (options && options.hasOwnProperty('authData')) {\n      const authData = this.get('authData') || {};\n\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n\n      authData[authType] = options.authData;\n\n      const controller = _CoreManager.default.getUserController();\n\n      return controller.linkWith(this, authData, saveOpts);\n    } else {\n      return new Promise((resolve, reject) => {\n        provider.authenticate({\n          success: (provider, result) => {\n            const opts = {};\n            opts.authData = result;\n            this.linkWith(provider, opts, saveOpts).then(() => {\n              resolve(this);\n            }, error => {\n              reject(error);\n            });\n          },\n          error: (provider, error) => {\n            reject(error);\n          }\n        });\n      });\n    }\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n\n\n  _linkWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  = {})\n  /*: Promise<ParseUser>*/\n  {\n    return this.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n\n\n  _synchronizeAuthData(provider\n  /*: string*/\n  ) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData');\n\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n\n    const success = provider.restoreAuthentication(authData[authType]);\n\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n  /**\n   * Synchronizes authData for all providers.\n   */\n\n\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n\n\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n\n\n  _unlinkFrom(provider\n  /*: any*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n\n      return Promise.resolve(this);\n    });\n  }\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n\n\n  _isLinked(provider\n  /*: any*/\n  )\n  /*: boolean*/\n  {\n    let authType;\n\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n\n    const authData = this.get('authData') || {};\n\n    if (typeof authData !== 'object') {\n      return false;\n    }\n\n    return !!authData[authType];\n  }\n  /**\n   * Deauthenticates all providers.\n   */\n\n\n  _logOutWithAll() {\n    const authData = this.get('authData');\n\n    if (typeof authData !== 'object') {\n      return;\n    }\n\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n\n\n  _logOutWith(provider\n  /*: any*/\n  ) {\n    if (!this.isCurrent()) {\n      return;\n    }\n\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n\n\n  _preserveFieldsOnFetch()\n  /*: AttributeMap*/\n  {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n\n\n  isCurrent()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {Promise<boolean>} true if user is cached on disk\n   */\n\n\n  async isCurrentAsync()\n  /*: Promise<boolean>*/\n  {\n    const current = await ParseUser.currentAsync();\n    return !!current && current.id === this.id;\n  }\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n\n\n  getUsername()\n  /*: ?string*/\n  {\n    const username = this.get('username');\n\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n\n\n  setUsername(username\n  /*: string*/\n  ) {\n    // Strip anonymity\n    const authData = this.get('authData');\n\n    if (authData && typeof authData === 'object' && authData.hasOwnProperty('anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n\n    this.set('username', username);\n  }\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n\n\n  setPassword(password\n  /*: string*/\n  ) {\n    this.set('password', password);\n  }\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n\n\n  getEmail()\n  /*: ?string*/\n  {\n    const email = this.get('email');\n\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n\n    return '';\n  }\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n\n\n  setEmail(email\n  /*: string*/\n  ) {\n    return this.set('email', email);\n  }\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n\n\n  getSessionToken()\n  /*: ?string*/\n  {\n    const token = this.get('sessionToken');\n\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n\n    return '';\n  }\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n\n\n  authenticated()\n  /*: boolean*/\n  {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n\n\n  signUp(attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const signupOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      signupOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      signupOptions.installationId = options.installationId;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.signUp(this, attrs, signupOptions);\n  }\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n\n\n  logIn(options\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    options = options || {};\n    const loginOptions = {\n      usePost: true\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      loginOptions.useMasterKey = options.useMasterKey;\n    }\n\n    if (options.hasOwnProperty('installationId')) {\n      loginOptions.installationId = options.installationId;\n    }\n\n    if (options.hasOwnProperty('usePost')) {\n      loginOptions.usePost = options.usePost;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logIn(this, loginOptions);\n  }\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n\n\n  async save(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.save.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  async destroy(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.destroy.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().removeUserFromDisk();\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  async fetch(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.fetch.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n\n\n  async fetchWithInclude(...args)\n  /*: Promise<ParseUser>*/\n  {\n    await super.fetchWithInclude.apply(this, args);\n    const current = await this.isCurrentAsync();\n\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n\n    return this;\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  verifyPassword(password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n\n\n  static extend(protoProps\n  /*: { [prop: string]: any }*/\n  , classProps\n  /*: { [prop: string]: any }*/\n  ) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          Object.defineProperty(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return ParseUser;\n  }\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.Object} The currently logged in Parse.User.\n   */\n\n\n  static current()\n  /*: ?ParseUser*/\n  {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUser();\n  }\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n\n\n  static currentAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (!canUseCurrentUser) {\n      return Promise.resolve(null);\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.currentUserAsync();\n  }\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n\n\n  static signUp(username\n  /*: string*/\n  , password\n  /*: string*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static logIn(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: FullOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    } else if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    const user = new this();\n\n    user._finishFetch({\n      username: username,\n      password: password\n    });\n\n    return user.logIn(options);\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static become(sessionToken\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n\n    options = options || {};\n    const becomeOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      becomeOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n\n\n  static me(sessionToken\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  = {}) {\n    const controller = _CoreManager.default.getUserController();\n\n    const meOptions\n    /*: RequestOptions*/\n    = {\n      sessionToken: sessionToken\n    };\n\n    if (options.useMasterKey) {\n      meOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n\n\n  static hydrate(userJSON\n  /*: AttributeMap*/\n  ) {\n    const controller = _CoreManager.default.getUserController();\n\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n\n\n  static logOut(options\n  /*: RequestOptions*/\n  = {}) {\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.logOut(options);\n  }\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestPasswordReset(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static requestEmailVerification(email\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n    const requestOptions = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} username  A username to be used for identificaiton\n   * @param {string} password A password to be verified\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with a user\n   *  when the password is correct.\n   */\n\n\n  static verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*:: ?: RequestOptions*/\n  ) {\n    if (typeof username !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n\n    if (typeof password !== 'string') {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n\n    options = options || {};\n    const verificationOption = {};\n\n    if (options.hasOwnProperty('useMasterKey')) {\n      verificationOption.useMasterKey = options.useMasterKey;\n    }\n\n    const controller = _CoreManager.default.getUserController();\n\n    return controller.verifyPassword(username, password, verificationOption);\n  }\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n\n\n  static allowCustomUserClass(isAllowed\n  /*: boolean*/\n  ) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n\n\n  static enableRevocableSession(options\n  /*:: ?: RequestOptions*/\n  ) {\n    options = options || {};\n\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n\n\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n\n\n  static _registerAuthenticationProvider(provider\n  /*: any*/\n  ) {\n    authProviders[provider.getAuthType()] = provider; // Synchronize the current user with the auth provider.\n\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n  /**\n   * @param provider\n   * @param options\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n\n\n  static _logInWith(provider\n  /*: any*/\n  , options\n  /*: { authData?: AuthData }*/\n  , saveOpts\n  /*:: ?: FullOptions*/\n  ) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n\n  static _setCurrentUserCache(user\n  /*: ParseUser*/\n  ) {\n    currentUserCache = user;\n  }\n\n}\n\n_ParseObject.default.registerSubclass('_User', ParseUser);\n\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = JSON.stringify(json);\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n\n  setCurrentUser(user) {\n    currentUserCache = user;\n\n    user._cleanupAuthData();\n\n    user._synchronizeAllAuthData();\n\n    return DefaultController.updateUserOnDisk(user);\n  },\n\n  currentUser()\n  /*: ?ParseUser*/\n  {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    let userData = _Storage.default.getItem(path);\n\n    currentUserCacheMatchesDisk = true;\n\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n\n    userData = JSON.parse(userData);\n\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n\n      delete userData._id;\n    }\n\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n\n    const current = _ParseObject.default.fromJSON(userData);\n\n    currentUserCache = current;\n\n    current._synchronizeAllAuthData();\n\n    return current;\n  },\n\n  currentUserAsync()\n  /*: Promise<?ParseUser>*/\n  {\n    if (currentUserCache) {\n      return Promise.resolve(currentUserCache);\n    }\n\n    if (currentUserCacheMatchesDisk) {\n      return Promise.resolve(null);\n    }\n\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n\n      if (!userData) {\n        currentUserCache = null;\n        return Promise.resolve(null);\n      }\n\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n\n      userData = JSON.parse(userData);\n\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n\n        delete userData._id;\n      }\n\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n\n      const current = _ParseObject.default.fromJSON(userData);\n\n      currentUserCache = current;\n\n      current._synchronizeAllAuthData();\n\n      return Promise.resolve(current);\n    });\n  },\n\n  signUp(user\n  /*: ParseUser*/\n  , attrs\n  /*: AttributeMap*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n\n    if (!username || !username.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n\n    if (!password || !password.length) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  logIn(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const stateController = _CoreManager.default.getObjectStateController();\n\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n\n      user._setExisted(true);\n\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n\n      user._finishFetch(response);\n\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return Promise.resolve(user);\n      }\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  become(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n\n  hydrate(user\n  /*: ParseUser*/\n  , userJSON\n  /*: AttributeMap*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    user._finishFetch(userJSON);\n\n    user._setExisted(true);\n\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    } else {\n      return Promise.resolve(user);\n    }\n  },\n\n  me(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n\n      user._setExisted(true);\n\n      return user;\n    });\n  },\n\n  logOut(options\n  /*: RequestOptions*/\n  )\n  /*: Promise<ParseUser>*/\n  {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    if (options.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n\n      let promise = _Storage.default.removeItemAsync(path);\n\n      if (currentUser !== null) {\n        const currentSession = currentUser.getSessionToken();\n\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n\n        currentUser._logOutWithAll();\n\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n      }\n\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n\n  requestPasswordReset(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email: email\n    }, options);\n  },\n\n  async upgradeToRevocableSession(user\n  /*: ParseUser*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const token = user.getSessionToken();\n\n    if (!token) {\n      return Promise.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n\n    options.sessionToken = token;\n\n    const RESTController = _CoreManager.default.getRESTController();\n\n    const result = await RESTController.request('POST', 'upgradeToRevocableSession', {}, options);\n    const session = new _ParseSession.default();\n\n    session._finishFetch(result);\n\n    user._finishFetch({\n      sessionToken: session.getSessionToken()\n    });\n\n    const current = await user.isCurrentAsync();\n\n    if (current) {\n      return DefaultController.setCurrentUser(user);\n    }\n\n    return Promise.resolve(user);\n  },\n\n  linkWith(user\n  /*: ParseUser*/\n  , authData\n  /*: AuthData*/\n  , options\n  /*: FullOptions*/\n  ) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n\n      return user;\n    });\n  },\n\n  verifyPassword(username\n  /*: string*/\n  , password\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('GET', 'verifyPassword', {\n      username,\n      password\n    }, options);\n  },\n\n  requestEmailVerification(email\n  /*: string*/\n  , options\n  /*: RequestOptions*/\n  ) {\n    const RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email: email\n    }, options);\n  }\n\n};\n\n_CoreManager.default.setUserController(DefaultController);\n\nvar _default = ParseUser;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}